import {
  require_assert
} from "./chunk-DM4IVGPD.js";
import "./chunk-SBZBGNP7.js";
import {
  require_bignumber
} from "./chunk-T5YSO3U6.js";
import "./chunk-Y7KBQV2K.js";
import {
  require_bs58
} from "./chunk-AO24BX75.js";
import {
  require_browser
} from "./chunk-EG3M35UM.js";
import {
  index_browser_esm_exports,
  init_index_browser_esm,
  require_Layout
} from "./chunk-MEJREJFC.js";
import "./chunk-HMPCMTOO.js";
import "./chunk-SDM3EV4Y.js";
import "./chunk-JAYH4MBK.js";
import "./chunk-JPHBH7D5.js";
import {
  require_bn
} from "./chunk-KZOBSIPY.js";
import "./chunk-OJ46EPHK.js";
import {
  __commonJS,
  __publicField,
  __toCommonJS
} from "./chunk-MVEJMUOB.js";

// node_modules/@metaplex-foundation/cusper/dist/src/parse-error.js
var require_parse_error = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/parse-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorCodeFromLogs = void 0;
    var errorLineRx = /Custom program error: (0x[a-f0-9]+)/i;
    function errorCodeFromLogs(logs) {
      for (const line of logs) {
        const match = line.match(errorLineRx);
        if (match == null)
          continue;
        const hexCode = match[1];
        try {
          return parseInt(hexCode);
        } catch (_) {
        }
      }
      return null;
    }
    exports.errorCodeFromLogs = errorCodeFromLogs;
  }
});

// node_modules/@metaplex-foundation/cusper/dist/src/errors/anchor.js
var require_anchor = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/errors/anchor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LangErrorMessage = exports.LangErrorCode = void 0;
    exports.LangErrorCode = {
      // Instructions.
      InstructionMissing: 100,
      InstructionFallbackNotFound: 101,
      InstructionDidNotDeserialize: 102,
      InstructionDidNotSerialize: 103,
      // IDL instructions.
      IdlInstructionStub: 1e3,
      IdlInstructionInvalidProgram: 1001,
      // Constraints.
      ConstraintMut: 2e3,
      ConstraintHasOne: 2001,
      ConstraintSigner: 2002,
      ConstraintRaw: 2003,
      ConstraintOwner: 2004,
      ConstraintRentExempt: 2005,
      ConstraintSeeds: 2006,
      ConstraintExecutable: 2007,
      ConstraintState: 2008,
      ConstraintAssociated: 2009,
      ConstraintAssociatedInit: 2010,
      ConstraintClose: 2011,
      ConstraintAddress: 2012,
      ConstraintZero: 2013,
      ConstraintTokenMint: 2014,
      ConstraintTokenOwner: 2015,
      ConstraintMintMintAuthority: 2016,
      ConstraintMintFreezeAuthority: 2017,
      ConstraintMintDecimals: 2018,
      ConstraintSpace: 2019,
      // Accounts.
      AccountDiscriminatorAlreadySet: 3e3,
      AccountDiscriminatorNotFound: 3001,
      AccountDiscriminatorMismatch: 3002,
      AccountDidNotDeserialize: 3003,
      AccountDidNotSerialize: 3004,
      AccountNotEnoughKeys: 3005,
      AccountNotMutable: 3006,
      AccountOwnedByWrongProgram: 3007,
      InvalidProgramId: 3008,
      InvalidProgramExecutable: 3009,
      AccountNotSigner: 3010,
      AccountNotSystemOwned: 3011,
      AccountNotInitialized: 3012,
      AccountNotProgramData: 3013,
      // State.
      StateInvalidAddress: 4e3,
      // Used for APIs that shouldn't be used anymore.
      Deprecated: 5e3
    };
    exports.LangErrorMessage = /* @__PURE__ */ new Map([
      // Instructions.
      [
        exports.LangErrorCode.InstructionMissing,
        "8 byte instruction identifier not provided"
      ],
      [
        exports.LangErrorCode.InstructionFallbackNotFound,
        "Fallback functions are not supported"
      ],
      [
        exports.LangErrorCode.InstructionDidNotDeserialize,
        "The program could not deserialize the given instruction"
      ],
      [
        exports.LangErrorCode.InstructionDidNotSerialize,
        "The program could not serialize the given instruction"
      ],
      // Idl instructions.
      [
        exports.LangErrorCode.IdlInstructionStub,
        "The program was compiled without idl instructions"
      ],
      [
        exports.LangErrorCode.IdlInstructionInvalidProgram,
        "The transaction was given an invalid program for the IDL instruction"
      ],
      // Constraints.
      [exports.LangErrorCode.ConstraintMut, "A mut constraint was violated"],
      [exports.LangErrorCode.ConstraintHasOne, "A has_one constraint was violated"],
      [exports.LangErrorCode.ConstraintSigner, "A signer constraint was violated"],
      [exports.LangErrorCode.ConstraintRaw, "A raw constraint was violated"],
      [exports.LangErrorCode.ConstraintOwner, "An owner constraint was violated"],
      [exports.LangErrorCode.ConstraintRentExempt, "A rent exempt constraint was violated"],
      [exports.LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"],
      [exports.LangErrorCode.ConstraintExecutable, "An executable constraint was violated"],
      [exports.LangErrorCode.ConstraintState, "A state constraint was violated"],
      [exports.LangErrorCode.ConstraintAssociated, "An associated constraint was violated"],
      [
        exports.LangErrorCode.ConstraintAssociatedInit,
        "An associated init constraint was violated"
      ],
      [exports.LangErrorCode.ConstraintClose, "A close constraint was violated"],
      [exports.LangErrorCode.ConstraintAddress, "An address constraint was violated"],
      [exports.LangErrorCode.ConstraintZero, "Expected zero account discriminant"],
      [exports.LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"],
      [exports.LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"],
      [
        exports.LangErrorCode.ConstraintMintMintAuthority,
        "A mint mint authority constraint was violated"
      ],
      [
        exports.LangErrorCode.ConstraintMintFreezeAuthority,
        "A mint freeze authority constraint was violated"
      ],
      [
        exports.LangErrorCode.ConstraintMintDecimals,
        "A mint decimals constraint was violated"
      ],
      [exports.LangErrorCode.ConstraintSpace, "A space constraint was violated"],
      // Accounts.
      [
        exports.LangErrorCode.AccountDiscriminatorAlreadySet,
        "The account discriminator was already set on this account"
      ],
      [
        exports.LangErrorCode.AccountDiscriminatorNotFound,
        "No 8 byte discriminator was found on the account"
      ],
      [
        exports.LangErrorCode.AccountDiscriminatorMismatch,
        "8 byte discriminator did not match what was expected"
      ],
      [exports.LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"],
      [exports.LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"],
      [
        exports.LangErrorCode.AccountNotEnoughKeys,
        "Not enough account keys given to the instruction"
      ],
      [exports.LangErrorCode.AccountNotMutable, "The given account is not mutable"],
      [
        exports.LangErrorCode.AccountOwnedByWrongProgram,
        "The given account is owned by a different program than expected"
      ],
      [exports.LangErrorCode.InvalidProgramId, "Program ID was not as expected"],
      [exports.LangErrorCode.InvalidProgramExecutable, "Program account is not executable"],
      [exports.LangErrorCode.AccountNotSigner, "The given account did not sign"],
      [
        exports.LangErrorCode.AccountNotSystemOwned,
        "The given account is not owned by the system program"
      ],
      [
        exports.LangErrorCode.AccountNotInitialized,
        "The program expected this account to be already initialized"
      ],
      [
        exports.LangErrorCode.AccountNotProgramData,
        "The given account is not a program data account"
      ],
      // State.
      [
        exports.LangErrorCode.StateInvalidAddress,
        "The given state account does not have the correct address"
      ],
      // Misc.
      [
        exports.LangErrorCode.Deprecated,
        "The API being used is deprecated and should no longer be used"
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/cusper/dist/src/errors/token-lending.js
var require_token_lending = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/errors/token-lending.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenLendingErrors = void 0;
    exports.tokenLendingErrors = /* @__PURE__ */ new Map([
      [
        0,
        {
          code: 0,
          message: 'Failed to unpack instruction data"',
          name: "InstructionUnpackError"
        }
      ],
      [
        1,
        {
          code: 1,
          message: 'Account is already initialized"',
          name: "AlreadyInitialized"
        }
      ],
      [
        2,
        {
          code: 2,
          message: 'Lamport balance below rent-exempt threshold"',
          name: "NotRentExempt"
        }
      ],
      [
        3,
        {
          code: 3,
          message: 'Market authority is invalid"',
          name: "InvalidMarketAuthority"
        }
      ],
      [
        4,
        {
          code: 4,
          message: 'Market owner is invalid"',
          name: "InvalidMarketOwner"
        }
      ],
      [
        5,
        {
          code: 5,
          message: 'Input account owner is not the program address"',
          name: "InvalidAccountOwner"
        }
      ],
      [
        6,
        {
          code: 6,
          message: 'Input token account is not owned by the correct token program id"',
          name: "InvalidTokenOwner"
        }
      ],
      [
        7,
        {
          code: 7,
          message: 'Input token account is not valid"',
          name: "InvalidTokenAccount"
        }
      ],
      [
        8,
        {
          code: 8,
          message: 'Input token mint account is not valid"',
          name: "InvalidTokenMint"
        }
      ],
      [
        9,
        {
          code: 9,
          message: 'Input token program account is not valid"',
          name: "InvalidTokenProgram"
        }
      ],
      [
        10,
        {
          code: 10,
          message: 'Input amount is invalid"',
          name: "InvalidAmount"
        }
      ],
      [
        11,
        {
          code: 11,
          message: 'Input config value is invalid"',
          name: "InvalidConfig"
        }
      ],
      [
        12,
        {
          code: 12,
          message: 'Input account must be a signer"',
          name: "InvalidSigner"
        }
      ],
      [
        13,
        {
          code: 13,
          message: 'Invalid account input"',
          name: "InvalidAccountInput"
        }
      ],
      [
        14,
        {
          code: 14,
          message: 'Math operation overflow"',
          name: "MathOverflow"
        }
      ],
      [
        15,
        {
          code: 15,
          message: 'Token initialize mint failed"',
          name: "TokenInitializeMintFailed"
        }
      ],
      [
        16,
        {
          code: 16,
          message: 'Token initialize account failed"',
          name: "TokenInitializeAccountFailed"
        }
      ],
      [
        17,
        {
          code: 17,
          message: 'Token transfer failed"',
          name: "TokenTransferFailed"
        }
      ],
      [
        18,
        {
          code: 18,
          message: 'Token mint to failed"',
          name: "TokenMintToFailed"
        }
      ],
      [
        19,
        {
          code: 19,
          message: 'Token burn failed"',
          name: "TokenBurnFailed"
        }
      ],
      [
        20,
        {
          code: 20,
          message: 'Insufficient liquidity available"',
          name: "InsufficientLiquidity"
        }
      ],
      [
        21,
        {
          code: 21,
          message: 'Input reserve has collateral disabled"',
          name: "ReserveCollateralDisabled"
        }
      ],
      [
        22,
        {
          code: 22,
          message: 'Reserve state needs to be refreshed"',
          name: "ReserveStale"
        }
      ],
      [
        23,
        {
          code: 23,
          message: 'Withdraw amount too small"',
          name: "WithdrawTooSmall"
        }
      ],
      [
        24,
        {
          code: 24,
          message: 'Withdraw amount too large"',
          name: "WithdrawTooLarge"
        }
      ],
      [
        25,
        {
          code: 25,
          message: 'Borrow amount too small to receive liquidity after fees"',
          name: "BorrowTooSmall"
        }
      ],
      [
        26,
        {
          code: 26,
          message: 'Borrow amount too large for deposited collateral"',
          name: "BorrowTooLarge"
        }
      ],
      [
        27,
        {
          code: 27,
          message: 'Repay amount too small to transfer liquidity"',
          name: "RepayTooSmall"
        }
      ],
      [
        28,
        {
          code: 28,
          message: 'Liquidation amount too small to receive collateral"',
          name: "LiquidationTooSmall"
        }
      ],
      [
        29,
        {
          code: 29,
          message: 'Cannot liquidate healthy obligations"',
          name: "ObligationHealthy"
        }
      ],
      [
        30,
        {
          code: 30,
          message: 'Obligation state needs to be refreshed"',
          name: "ObligationStale"
        }
      ],
      [
        31,
        {
          code: 31,
          message: 'Obligation reserve limit exceeded"',
          name: "ObligationReserveLimit"
        }
      ],
      [
        32,
        {
          code: 32,
          message: 'Obligation owner is invalid"',
          name: "InvalidObligationOwner"
        }
      ],
      [
        33,
        {
          code: 33,
          message: 'Obligation deposits are empty"',
          name: "ObligationDepositsEmpty"
        }
      ],
      [
        34,
        {
          code: 34,
          message: 'Obligation borrows are empty"',
          name: "ObligationBorrowsEmpty"
        }
      ],
      [
        35,
        {
          code: 35,
          message: 'Obligation deposits have zero value"',
          name: "ObligationDepositsZero"
        }
      ],
      [
        36,
        {
          code: 36,
          message: 'Obligation borrows have zero value"',
          name: "ObligationBorrowsZero"
        }
      ],
      [
        37,
        {
          code: 37,
          message: 'Invalid obligation collateral"',
          name: "InvalidObligationCollateral"
        }
      ],
      [
        38,
        {
          code: 38,
          message: 'Invalid obligation liquidity"',
          name: "InvalidObligationLiquidity"
        }
      ],
      [
        39,
        {
          code: 39,
          message: 'Obligation collateral is empty"',
          name: "ObligationCollateralEmpty"
        }
      ],
      [
        40,
        {
          code: 40,
          message: 'Obligation liquidity is empty"',
          name: "ObligationLiquidityEmpty"
        }
      ],
      [
        41,
        {
          code: 41,
          message: 'Interest rate is negative"',
          name: "NegativeInterestRate"
        }
      ],
      [
        42,
        {
          code: 42,
          message: 'Input oracle config is invalid"',
          name: "InvalidOracleConfig"
        }
      ],
      [
        43,
        {
          code: 43,
          message: 'Input flash loan receiver program account is not valid"',
          name: "InvalidFlashLoanReceiverProgram"
        }
      ],
      [
        44,
        {
          code: 44,
          message: 'Not enough liquidity after flash loan"',
          name: "NotEnoughLiquidityAfterFlashLoan"
        }
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/cusper/dist/src/resolve-error.js
var require_resolve_error = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/resolve-error.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenLendingError = exports.AnchorError = exports.CustomProgramError = exports.CusperUnknownError = exports.initCusper = exports.ErrorResolver = void 0;
    var parse_error_1 = require_parse_error();
    var anchor = __importStar(require_anchor());
    var token_lending_1 = require_token_lending();
    var ErrorResolver = class {
      constructor(resolveErrorFromCode) {
        this.resolveErrorFromCode = resolveErrorFromCode;
      }
      /**
       * Attempts to resolve the provided error code to a known or custom error.
       *
       * @param captureBoundaryFn is used to exclude everything after (including)
       * that function from the stack trace if possible
       * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is
       * returned when resolution fails
       */
      errorFromCode(code, captureBoundaryFn, fallbackToUnknown = true) {
        let err = this.resolveErrorFromCode != null ? this.resolveErrorFromCode(code) : null;
        if (err != null) {
          return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);
        }
        err = AnchorError.fromCode(code);
        if (err != null) {
          return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);
        }
        err = TokenLendingError.fromCode(code);
        if (err != null) {
          return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);
        }
        if (fallbackToUnknown) {
          err = new CusperUnknownError(code, "CusperUnknownError", "cusper does not know this error");
          return this.passPreparedError(err, captureBoundaryFn !== null && captureBoundaryFn !== void 0 ? captureBoundaryFn : this.errorFromCode);
        }
      }
      /**
       * Attempts to parse the error code from the provied logs and then resolve it
       * to a known or custom error.
       * @param fallbackToUnknown unless `false` a {@link CusperUnknownError} is
       * returned when resolution fails
       */
      errorFromProgramLogs(logs, fallbackToUnknown = true) {
        const code = (0, parse_error_1.errorCodeFromLogs)(logs);
        return code == null ? null : this.errorFromCode(code, this.errorFromProgramLogs, fallbackToUnknown);
      }
      /**
       * Throws an error that it attempts to resolve from the logs of the provided error.
       * If no error can be resolved it throws a {@link CusperUnknownError} instead
       */
      throwError(error) {
        const err = error.logs != null && this.errorFromProgramLogs(error.logs, true) || new CusperUnknownError(-1, "Error created without logs and thus without error code");
        throw this.passPreparedError(err, this.throwError);
      }
      passPreparedError(err, captureBoundaryFn) {
        if (err == null)
          return null;
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(err, captureBoundaryFn);
        }
        return err;
      }
    };
    exports.ErrorResolver = ErrorResolver;
    function initCusper(resolveErrorFromCode) {
      return new ErrorResolver(resolveErrorFromCode);
    }
    exports.initCusper = initCusper;
    var CusperUnknownError = class extends Error {
      constructor(code, ...params) {
        super(...params);
        this.code = code;
        this.name = "CusperUnknownError";
      }
    };
    exports.CusperUnknownError = CusperUnknownError;
    var CustomProgramError = class extends Error {
      /**
       * Creates an instance of a {@link CustomProgramError}.
       *
       * @param code the error code for which this error was resolved
       * @param name the name of the error
       */
      constructor(code, name, ...params) {
        super(...params);
        this.code = code;
        this.name = `CustomProgramError#${name}`;
      }
    };
    exports.CustomProgramError = CustomProgramError;
    var AnchorError = class _AnchorError extends Error {
      constructor(code, name, ...params) {
        super(...params);
        this.code = code;
        this.name = `AnchorError#${name}`;
      }
      static fromCode(code) {
        const errorMeta = _AnchorError.errorMap.get(code);
        return errorMeta != null ? new _AnchorError(errorMeta.code, errorMeta.name, errorMeta.message) : null;
      }
      toString() {
        return `${this.name}: ${this.message}`;
      }
    };
    exports.AnchorError = AnchorError;
    AnchorError.errorMap = Object.entries(anchor.LangErrorCode).reduce((acc, [key, code]) => {
      acc.set(code, {
        code,
        name: key,
        message: anchor.LangErrorMessage.get(code)
      });
      return acc;
    }, /* @__PURE__ */ new Map());
    var TokenLendingError = class _TokenLendingError extends Error {
      constructor(code, name, ...params) {
        super(...params);
        this.code = code;
        this.name = `TokenLendingError#${name}`;
      }
      static fromCode(code) {
        const errorMeta = _TokenLendingError.errorMap.get(code);
        return errorMeta != null ? new _TokenLendingError(errorMeta.code, errorMeta.name, errorMeta.message) : null;
      }
      toString() {
        return `${this.name}: ${this.message}`;
      }
    };
    exports.TokenLendingError = TokenLendingError;
    TokenLendingError.errorMap = token_lending_1.tokenLendingErrors;
  }
});

// node_modules/@metaplex-foundation/cusper/dist/src/types.js
var require_types = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@metaplex-foundation/cusper/dist/src/cusper.js
var require_cusper = __commonJS({
  "node_modules/@metaplex-foundation/cusper/dist/src/cusper.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_resolve_error(), exports);
    __exportStar(require_types(), exports);
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js
var require_types2 = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isElementCollectionFixedSizeBeet = exports.isFixableBeet = exports.assertFixedSizeBeet = exports.isFixedSizeBeet = exports.BEET_TYPE_ARG_INNER = exports.BEET_TYPE_ARG_LEN = exports.BEET_PACKAGE = void 0;
    var assert_1 = require_assert();
    exports.BEET_PACKAGE = "@metaplex-foundation/beet";
    exports.BEET_TYPE_ARG_LEN = "len";
    exports.BEET_TYPE_ARG_INNER = "Beet<{innner}>";
    function isFixedSizeBeet(x) {
      return Object.keys(x).includes("byteSize");
    }
    exports.isFixedSizeBeet = isFixedSizeBeet;
    function assertFixedSizeBeet(x, msg = `${x} should have been a fixed beet`) {
      (0, assert_1.strict)(isFixedSizeBeet(x), msg);
    }
    exports.assertFixedSizeBeet = assertFixedSizeBeet;
    function isFixableBeet(x) {
      return typeof x.toFixedFromData === "function" && typeof x.toFixedFromValue === "function";
    }
    exports.isFixableBeet = isFixableBeet;
    function isElementCollectionFixedSizeBeet(x) {
      const keys = Object.keys(x);
      return keys.includes("length") && keys.includes("elementByteSize") && keys.includes("lenPrefixByteSize");
    }
    exports.isElementCollectionFixedSizeBeet = isElementCollectionFixedSizeBeet;
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js
var require_numbers = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/numbers.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.numbersTypeMap = exports.bool = exports.i512 = exports.i256 = exports.i128 = exports.i64 = exports.i32 = exports.i16 = exports.i8 = exports.u512 = exports.u256 = exports.u128 = exports.u64 = exports.u32 = exports.u16 = exports.u8 = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var types_1 = require_types2();
    exports.u8 = {
      write: function(buf, offset, value) {
        buf.writeUInt8(value, offset);
      },
      read: function(buf, offset) {
        return buf.readUInt8(offset);
      },
      byteSize: 1,
      description: "u8"
    };
    exports.u16 = {
      write: function(buf, offset, value) {
        buf.writeUInt16LE(value, offset);
      },
      read: function(buf, offset) {
        return buf.readUInt16LE(offset);
      },
      byteSize: 2,
      description: "u16"
    };
    exports.u32 = {
      write: function(buf, offset, value) {
        buf.writeUInt32LE(value, offset);
      },
      read: function(buf, offset) {
        return buf.readUInt32LE(offset);
      },
      byteSize: 4,
      description: "u32"
    };
    function unsignedLargeBeet(byteSize, description) {
      return {
        write: function(buf, offset, value) {
          const bn = bn_js_1.default.isBN(value) ? value : new bn_js_1.default(value);
          const bytesArray = bn.toArray("le", this.byteSize);
          const bytesArrayBuf = Buffer.from(bytesArray);
          bytesArrayBuf.copy(buf, offset, 0, this.byteSize);
        },
        read: function(buf, offset) {
          const slice = buf.slice(offset, offset + this.byteSize);
          return new bn_js_1.default(slice, "le");
        },
        byteSize,
        description
      };
    }
    exports.u64 = unsignedLargeBeet(8, "u64");
    exports.u128 = unsignedLargeBeet(16, "u128");
    exports.u256 = unsignedLargeBeet(32, "u256");
    exports.u512 = unsignedLargeBeet(64, "u512");
    exports.i8 = {
      write: function(buf, offset, value) {
        buf.writeInt8(value, offset);
      },
      read: function(buf, offset) {
        return buf.readInt8(offset);
      },
      byteSize: 1,
      description: "i8"
    };
    exports.i16 = {
      write: function(buf, offset, value) {
        buf.writeInt16LE(value, offset);
      },
      read: function(buf, offset) {
        return buf.readInt16LE(offset);
      },
      byteSize: 2,
      description: "i16"
    };
    exports.i32 = {
      write: function(buf, offset, value) {
        buf.writeInt32LE(value, offset);
      },
      read: function(buf, offset) {
        return buf.readInt32LE(offset);
      },
      byteSize: 4,
      description: "i32"
    };
    function signedLargeBeet(byteSize, description) {
      const bitSize = byteSize * 8;
      return {
        write: function(buf, offset, value) {
          const bn = (bn_js_1.default.isBN(value) ? value : new bn_js_1.default(value)).toTwos(bitSize);
          const bytesArray = bn.toArray("le", this.byteSize);
          const bytesArrayBuf = Buffer.from(bytesArray);
          bytesArrayBuf.copy(buf, offset, 0, this.byteSize);
        },
        read: function(buf, offset) {
          const slice = buf.slice(offset, offset + this.byteSize);
          const x = new bn_js_1.default(slice, "le");
          return x.fromTwos(bitSize);
        },
        byteSize,
        description
      };
    }
    exports.i64 = signedLargeBeet(8, "i64");
    exports.i128 = signedLargeBeet(16, "i128");
    exports.i256 = signedLargeBeet(32, "i256");
    exports.i512 = signedLargeBeet(64, "i512");
    exports.bool = {
      write: function(buf, offset, value) {
        const n = value ? 1 : 0;
        exports.u8.write(buf, offset, n);
      },
      read: function(buf, offset) {
        return exports.u8.read(buf, offset) === 1;
      },
      byteSize: 1,
      description: "bool"
    };
    exports.numbersTypeMap = {
      // <= 32-bit numbers and boolean
      u8: { beet: "u8", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      u16: { beet: "u16", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      u32: { beet: "u32", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      i8: { beet: "i8", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      i16: { beet: "i16", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      i32: { beet: "i32", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "number" },
      bool: { beet: "bool", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "boolean" },
      // Big Number, they use, the 'bignum' type which is defined in this package
      u64: { beet: "u64", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      u128: { beet: "u128", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      u256: { beet: "u256", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      u512: { beet: "u512", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      i64: { beet: "i64", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      i128: { beet: "i128", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      i256: { beet: "i256", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE },
      i512: { beet: "i512", isFixable: false, sourcePack: types_1.BEET_PACKAGE, ts: "bignum", pack: types_1.BEET_PACKAGE }
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/ansicolors/ansicolors.js
var require_ansicolors = __commonJS({
  "node_modules/ansicolors/ansicolors.js"(exports, module) {
    "use strict";
    var colorNums = {
      white: 37,
      black: 30,
      blue: 34,
      cyan: 36,
      green: 32,
      magenta: 35,
      red: 31,
      yellow: 33,
      brightBlack: 90,
      brightRed: 91,
      brightGreen: 92,
      brightYellow: 93,
      brightBlue: 94,
      brightMagenta: 95,
      brightCyan: 96,
      brightWhite: 97
    };
    var backgroundColorNums = {
      bgBlack: 40,
      bgRed: 41,
      bgGreen: 42,
      bgYellow: 43,
      bgBlue: 44,
      bgMagenta: 45,
      bgCyan: 46,
      bgWhite: 47,
      bgBrightBlack: 100,
      bgBrightRed: 101,
      bgBrightGreen: 102,
      bgBrightYellow: 103,
      bgBrightBlue: 104,
      bgBrightMagenta: 105,
      bgBrightCyan: 106,
      bgBrightWhite: 107
    };
    var open = {};
    var close = {};
    var colors = {};
    Object.keys(colorNums).forEach(function(k) {
      var o = open[k] = "\x1B[" + colorNums[k] + "m";
      var c = close[k] = "\x1B[39m";
      colors[k] = function(s) {
        return o + s + c;
      };
    });
    Object.keys(backgroundColorNums).forEach(function(k) {
      var o = open[k] = "\x1B[" + backgroundColorNums[k] + "m";
      var c = close[k] = "\x1B[49m";
      colors[k] = function(s) {
        return o + s + c;
      };
    });
    module.exports = colors;
    colors.open = open;
    colors.close = close;
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnreachableCaseError = exports.stringify = exports.bytes = exports.beetBytes = exports.logTrace = exports.logDebug = exports.logInfo = exports.logError = void 0;
    var debug_1 = __importDefault(require_browser2());
    var ansicolors_1 = __importDefault(require_ansicolors());
    var types_1 = require_types2();
    var { brightBlack } = ansicolors_1.default;
    exports.logError = (0, debug_1.default)("beet:error");
    exports.logInfo = (0, debug_1.default)("beet:info");
    exports.logDebug = (0, debug_1.default)("beet:debug");
    exports.logTrace = (0, debug_1.default)("beet:trace");
    function beetBytes(beet, isFixable = false) {
      let bytes2;
      if ((0, types_1.isFixableBeet)(beet)) {
        bytes2 = "? B";
      } else if ((0, types_1.isElementCollectionFixedSizeBeet)(beet)) {
        const len = isFixable ? "length" : beet.length;
        const lenBytes = beet.lenPrefixByteSize;
        bytes2 = lenBytes > 0 ? `${lenBytes} + (${beet.elementByteSize} * ${len}) B  (${beet.byteSize} B)` : `(${beet.elementByteSize} * ${len}) B (${beet.byteSize} B)`;
      } else {
        bytes2 = `${beet.byteSize} B`;
      }
      return brightBlack(bytes2);
    }
    exports.beetBytes = beetBytes;
    function bytes(n) {
      return brightBlack(`${n} B`);
    }
    exports.bytes = bytes;
    function stringify(x) {
      return x.toString === "function" ? x.toString() : x;
    }
    exports.stringify = stringify;
    var UnreachableCaseError = class extends Error {
      constructor(value) {
        super(`Unreachable case: ${value}`);
      }
    };
    exports.UnreachableCaseError = UnreachableCaseError;
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js
var require_beet_fixable = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.fixable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fixBeetFromValue = exports.fixBeetFromData = void 0;
    var types_1 = require_types2();
    var utils_1 = require_utils();
    function fixBeetFromData(beet, buf, offset) {
      if ((0, types_1.isFixedSizeBeet)(beet)) {
        return beet;
      }
      if ((0, types_1.isFixableBeet)(beet)) {
        return beet.toFixedFromData(buf, offset);
      }
      throw new utils_1.UnreachableCaseError(beet);
    }
    exports.fixBeetFromData = fixBeetFromData;
    function fixBeetFromValue(beet, val) {
      if ((0, types_1.isFixedSizeBeet)(beet)) {
        return beet;
      }
      if ((0, types_1.isFixableBeet)(beet)) {
        return beet.toFixedFromValue(val);
      }
      throw new utils_1.UnreachableCaseError(beet);
    }
    exports.fixBeetFromValue = fixBeetFromValue;
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js
var require_collections = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/collections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionsTypeMap = exports.uint8Array = exports.fixedSizeUint8Array = exports.fixedSizeBuffer = exports.array = exports.fixedSizeArray = exports.uniformFixedSizeArray = void 0;
    var types_1 = require_types2();
    var assert_1 = require_assert();
    var numbers_1 = require_numbers();
    var types_2 = require_types2();
    var utils_1 = require_utils();
    var beet_fixable_1 = require_beet_fixable();
    function uniformFixedSizeArray(element, len, lenPrefix = false) {
      const arraySize = element.byteSize * len;
      const byteSize = lenPrefix ? 4 + arraySize : arraySize;
      return {
        write: function(buf, offset, value) {
          assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);
          if (lenPrefix) {
            numbers_1.u32.write(buf, offset, len);
            offset += 4;
          }
          for (let i = 0; i < len; i++) {
            element.write(buf, offset + i * element.byteSize, value[i]);
          }
        },
        read: function(buf, offset) {
          if (lenPrefix) {
            const size = numbers_1.u32.read(buf, offset);
            assert_1.strict.equal(size, len, "invalid byte size");
            offset += 4;
          }
          const arr = new Array(len);
          for (let i = 0; i < len; i++) {
            arr[i] = element.read(buf, offset + i * element.byteSize);
          }
          return arr;
        },
        byteSize,
        length: len,
        elementByteSize: element.byteSize,
        lenPrefixByteSize: 4,
        description: `Array<${element.description}>(${len})`
      };
    }
    exports.uniformFixedSizeArray = uniformFixedSizeArray;
    function fixedSizeArray(elements, elementsByteSize) {
      const len = elements.length;
      const firstElement = len === 0 ? "<EMPTY>" : elements[0].description;
      return {
        write: function(buf, offset, value) {
          assert_1.strict.equal(value.length, len, `array length ${value.length} should match len ${len}`);
          numbers_1.u32.write(buf, offset, len);
          let cursor = offset + 4;
          for (let i = 0; i < len; i++) {
            const element = elements[i];
            element.write(buf, cursor, value[i]);
            cursor += element.byteSize;
          }
        },
        read: function(buf, offset) {
          const size = numbers_1.u32.read(buf, offset);
          assert_1.strict.equal(size, len, "invalid byte size");
          let cursor = offset + 4;
          const arr = new Array(len);
          for (let i = 0; i < len; i++) {
            const element = elements[i];
            arr[i] = element.read(buf, cursor);
            cursor += element.byteSize;
          }
          return arr;
        },
        byteSize: 4 + elementsByteSize,
        length: len,
        description: `Array<${firstElement}>(${len})[ 4 + ${elementsByteSize} ]`
      };
    }
    exports.fixedSizeArray = fixedSizeArray;
    function array(element) {
      return {
        toFixedFromData(buf, offset) {
          const len = numbers_1.u32.read(buf, offset);
          (0, utils_1.logTrace)(`${this.description}[${len}]`);
          const cursorStart = offset + 4;
          let cursor = cursorStart;
          const fixedElements = new Array(len);
          for (let i = 0; i < len; i++) {
            const fixedElement = (0, beet_fixable_1.fixBeetFromData)(element, buf, cursor);
            fixedElements[i] = fixedElement;
            cursor += fixedElement.byteSize;
          }
          return fixedSizeArray(fixedElements, cursor - cursorStart);
        },
        toFixedFromValue(vals) {
          (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array`);
          let elementsSize = 0;
          const fixedElements = new Array(vals.length);
          for (let i = 0; i < vals.length; i++) {
            const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(element, vals[i]);
            fixedElements[i] = fixedElement;
            elementsSize += fixedElement.byteSize;
          }
          return fixedSizeArray(fixedElements, elementsSize);
        },
        description: `array`
      };
    }
    exports.array = array;
    function fixedSizeBuffer(bytes) {
      return {
        write: function(buf, offset, value) {
          value.copy(buf, offset, 0, bytes);
        },
        read: function(buf, offset) {
          return buf.slice(offset, offset + bytes);
        },
        byteSize: bytes,
        description: `Buffer(${bytes})`
      };
    }
    exports.fixedSizeBuffer = fixedSizeBuffer;
    function fixedSizeUint8Array(len, lenPrefix = false) {
      const arrayBufferBeet = fixedSizeBuffer(len);
      const byteSize = lenPrefix ? len + 4 : len;
      return {
        write: function(buf, offset, value) {
          assert_1.strict.equal(value.byteLength, len, `Uint8Array length ${value.byteLength} should match len ${len}`);
          if (lenPrefix) {
            numbers_1.u32.write(buf, offset, len);
            offset += 4;
          }
          const valueBuf = Buffer.from(value);
          arrayBufferBeet.write(buf, offset, valueBuf);
        },
        read: function(buf, offset) {
          if (lenPrefix) {
            const size = numbers_1.u32.read(buf, offset);
            assert_1.strict.equal(size, len, "invalid byte size");
            offset += 4;
          }
          const arrayBuffer = arrayBufferBeet.read(buf, offset);
          return Uint8Array.from(arrayBuffer);
        },
        byteSize,
        description: `Uint8Array(${len})`
      };
    }
    exports.fixedSizeUint8Array = fixedSizeUint8Array;
    exports.uint8Array = {
      toFixedFromData(buf, offset) {
        const len = numbers_1.u32.read(buf, offset);
        (0, utils_1.logTrace)(`${this.description}[${len}]`);
        return fixedSizeUint8Array(len, true);
      },
      toFixedFromValue(val) {
        const len = val.byteLength;
        return fixedSizeUint8Array(len, true);
      },
      description: `Uint8Array`
    };
    exports.collectionsTypeMap = {
      Array: {
        beet: "array",
        isFixable: true,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Array",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      FixedSizeArray: {
        beet: "fixedSizeArray",
        isFixable: false,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Array",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      UniformFixedSizeArray: {
        beet: "uniformFixedSizeArray",
        isFixable: false,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Array",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      Buffer: {
        beet: "fixedSizeBuffer",
        isFixable: false,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Buffer",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      FixedSizeUint8Array: {
        beet: "fixedSizeUint8Array",
        isFixable: false,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Uint8Array",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      Uint8Array: {
        beet: "uint8Array",
        isFixable: true,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "Uint8Array",
        arg: types_1.BEET_TYPE_ARG_LEN
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js
var require_composites = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/composites.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compositesTypeMap = exports.coption = exports.coptionSome = exports.coptionNone = exports.isNoneBuffer = exports.isSomeBuffer = void 0;
    var assert_1 = require_assert();
    var types_1 = require_types2();
    var types_2 = require_types2();
    var utils_1 = require_utils();
    var beet_fixable_1 = require_beet_fixable();
    var NONE = 0;
    var SOME = 1;
    function isSomeBuffer(buf, offset) {
      return buf[offset] === SOME;
    }
    exports.isSomeBuffer = isSomeBuffer;
    function isNoneBuffer(buf, offset) {
      return buf[offset] === NONE;
    }
    exports.isNoneBuffer = isNoneBuffer;
    function coptionNone(description) {
      (0, utils_1.logTrace)(`coptionNone(${description})`);
      return {
        write: function(buf, offset, value) {
          (0, assert_1.strict)(value == null, "coptionNone can only handle `null` values");
          buf[offset] = NONE;
        },
        read: function(buf, offset) {
          (0, assert_1.strict)(isNoneBuffer(buf, offset), "coptionNone can only handle `NONE` data");
          return null;
        },
        byteSize: 1,
        description: `COption<None(${description})>`
      };
    }
    exports.coptionNone = coptionNone;
    function coptionSome(inner) {
      const byteSize = 1 + inner.byteSize;
      const beet = {
        write: function(buf, offset, value) {
          (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling write`);
          (0, assert_1.strict)(value != null, "coptionSome cannot handle `null` values");
          buf[offset] = SOME;
          inner.write(buf, offset + 1, value);
        },
        read: function(buf, offset) {
          (0, types_1.assertFixedSizeBeet)(inner, `coption inner type ${inner.description} needs to be fixed before calling read`);
          (0, assert_1.strict)(isSomeBuffer(buf, offset), "coptionSome can only handle `SOME` data");
          return inner.read(buf, offset + 1);
        },
        description: `COption<${inner.description}>[1 + ${inner.byteSize}]`,
        byteSize,
        inner
      };
      (0, utils_1.logTrace)(beet.description);
      return beet;
    }
    exports.coptionSome = coptionSome;
    function coption(inner) {
      return {
        toFixedFromData(buf, offset) {
          if (isSomeBuffer(buf, offset)) {
            const innerFixed = (0, beet_fixable_1.fixBeetFromData)(inner, buf, offset + 1);
            return coptionSome(innerFixed);
          } else {
            (0, assert_1.strict)(isNoneBuffer(buf, offset), `Expected ${buf} to hold a COption`);
            return coptionNone(inner.description);
          }
        },
        toFixedFromValue(val) {
          return val == null ? coptionNone(inner.description) : coptionSome((0, beet_fixable_1.fixBeetFromValue)(inner, val));
        },
        description: `COption<${inner.description}>`
      };
    }
    exports.coption = coption;
    exports.compositesTypeMap = {
      option: {
        beet: "coption",
        isFixable: true,
        sourcePack: types_2.BEET_PACKAGE,
        ts: "COption<Inner>",
        arg: types_1.BEET_TYPE_ARG_INNER,
        pack: types_2.BEET_PACKAGE
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js
var require_string = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringTypeMap = exports.utf8String = exports.fixedSizeUtf8String = void 0;
    var types_1 = require_types2();
    var assert_1 = require_assert();
    var numbers_1 = require_numbers();
    var utils_1 = require_utils();
    var fixedSizeUtf8String = (stringByteLength) => {
      return {
        write: function(buf, offset, value) {
          const stringBuf = Buffer.from(value, "utf8");
          assert_1.strict.equal(stringBuf.byteLength, stringByteLength, `${value} has invalid byte size`);
          numbers_1.u32.write(buf, offset, stringByteLength);
          stringBuf.copy(buf, offset + 4, 0, stringByteLength);
        },
        read: function(buf, offset) {
          const size = numbers_1.u32.read(buf, offset);
          assert_1.strict.equal(size, stringByteLength, `invalid byte size`);
          const stringSlice = buf.slice(offset + 4, offset + 4 + stringByteLength);
          return stringSlice.toString("utf8");
        },
        elementByteSize: 1,
        length: stringByteLength,
        lenPrefixByteSize: 4,
        byteSize: 4 + stringByteLength,
        description: `Utf8String(4 + ${stringByteLength})`
      };
    };
    exports.fixedSizeUtf8String = fixedSizeUtf8String;
    exports.utf8String = {
      toFixedFromData(buf, offset) {
        const len = numbers_1.u32.read(buf, offset);
        (0, utils_1.logTrace)(`${this.description}[${len}]`);
        return (0, exports.fixedSizeUtf8String)(len);
      },
      toFixedFromValue(val) {
        const len = Buffer.from(val).byteLength;
        return (0, exports.fixedSizeUtf8String)(len);
      },
      description: `Utf8String`
    };
    exports.stringTypeMap = {
      fixedSizeString: {
        beet: "fixedSizeUtf8String",
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "string",
        arg: types_1.BEET_TYPE_ARG_LEN
      },
      string: {
        beet: "utf8String",
        isFixable: true,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "string"
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js
var require_read_write = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/read-write.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeetReader = exports.BeetWriter = void 0;
    var assert_1 = require_assert();
    var BeetWriter = class {
      constructor(byteSize) {
        this.buf = Buffer.alloc(byteSize);
        this._offset = 0;
      }
      get buffer() {
        return this.buf;
      }
      get offset() {
        return this._offset;
      }
      maybeResize(bytesNeeded) {
        if (this._offset + bytesNeeded > this.buf.length) {
          assert_1.strict.fail(`We shouldn't ever need to resize, but ${this._offset + bytesNeeded} > ${this.buf.length}`);
        }
      }
      write(beet, value) {
        this.maybeResize(beet.byteSize);
        beet.write(this.buf, this._offset, value);
        this._offset += beet.byteSize;
      }
      writeStruct(instance, fields) {
        for (const [key, beet] of fields) {
          const value = instance[key];
          this.write(beet, value);
        }
      }
    };
    exports.BeetWriter = BeetWriter;
    var BeetReader = class {
      constructor(buffer, _offset = 0) {
        this.buffer = buffer;
        this._offset = _offset;
      }
      get offset() {
        return this._offset;
      }
      read(beet) {
        const value = beet.read(this.buffer, this._offset);
        this._offset += beet.byteSize;
        return value;
      }
      readStruct(fields) {
        const acc = {};
        for (const [key, beet] of fields) {
          acc[key] = this.read(beet);
        }
        return acc;
      }
    };
    exports.BeetReader = BeetReader;
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js
var require_struct = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BeetArgsStruct = exports.isBeetStruct = exports.BeetStruct = void 0;
    var read_write_1 = require_read_write();
    var utils_1 = require_utils();
    var BeetStruct = class _BeetStruct {
      /**
       * Creates an instance of the BeetStruct.
       *
       * @param fields de/serializers for each field of the {@link Class}
       * @param construct the function that creates an instance of {@link Class}
       * from the args
       * @param description identifies this struct for diagnostics/debugging
       * purposes
       */
      constructor(fields, construct, description = _BeetStruct.description) {
        this.fields = fields;
        this.construct = construct;
        this.description = description;
        this.byteSize = this.getByteSize();
        if (utils_1.logDebug.enabled) {
          const flds = fields.map(([key, val]) => `${String(key)}: ${val.description} ${(0, utils_1.beetBytes)(val)}`).join("\n  ");
          (0, utils_1.logDebug)(`struct ${description} {
  ${flds}
} ${(0, utils_1.beetBytes)(this)}`);
        }
      }
      /**
       * Along with `write` this allows structs to be treated as {@link Beet}s and
       * thus supports composing/nesting them the same way.
       * @private
       */
      read(buf, offset) {
        const [value] = this.deserialize(buf, offset);
        return value;
      }
      /**
       * Along with `read` this allows structs to be treated as {@link Beet}s and
       * thus supports composing/nesting them the same way.
       * @private
       */
      write(buf, offset, value) {
        const [innerBuf, innerOffset] = this.serialize(value);
        innerBuf.copy(buf, offset, 0, innerOffset);
      }
      /**
       * Deserializes an instance of the Class from the provided buffer starting to
       * read at the provided offset.
       *
       * @returns `[instance of Class, offset into buffer after deserialization completed]`
       */
      deserialize(buffer, offset = 0) {
        if (utils_1.logTrace.enabled) {
          (0, utils_1.logTrace)("deserializing [%s] from %d bytes buffer", this.description, buffer.byteLength);
          (0, utils_1.logTrace)(buffer);
          (0, utils_1.logTrace)(buffer.toJSON().data);
        }
        const reader = new read_write_1.BeetReader(buffer, offset);
        const args = reader.readStruct(this.fields);
        return [this.construct(args), reader.offset];
      }
      /**
       * Serializes the provided instance into a new {@link Buffer}
       *
       * @param instance of the struct to serialize
       * @param byteSize allows to override the size fo the created Buffer and
       * defaults to the size of the struct to serialize
       */
      serialize(instance, byteSize = this.byteSize) {
        (0, utils_1.logTrace)("serializing [%s] %o to %d bytes buffer", this.description, instance, byteSize);
        const writer = new read_write_1.BeetWriter(byteSize);
        writer.writeStruct(instance, this.fields);
        return [writer.buffer, writer.offset];
      }
      getByteSize() {
        return this.fields.reduce((acc, [_, beet]) => acc + beet.byteSize, 0);
      }
      get type() {
        return _BeetStruct.TYPE;
      }
    };
    exports.BeetStruct = BeetStruct;
    BeetStruct.description = "BeetStruct";
    BeetStruct.TYPE = "BeetStruct";
    function isBeetStruct(beet) {
      return beet.type === BeetStruct.TYPE;
    }
    exports.isBeetStruct = isBeetStruct;
    var BeetArgsStruct = class _BeetArgsStruct extends BeetStruct {
      constructor(fields, description = _BeetArgsStruct.description) {
        super(fields, (args) => args, description);
      }
    };
    exports.BeetArgsStruct = BeetArgsStruct;
    BeetArgsStruct.description = "BeetArgsStruct";
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js
var require_struct_fixable = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/struct.fixable.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixableBeetArgsStruct = exports.isFixableBeetStruct = exports.FixableBeetStruct = void 0;
    var beet_fixable_1 = require_beet_fixable();
    var struct_1 = require_struct();
    var types_1 = require_types2();
    var assert_1 = require_assert();
    var utils_1 = require_utils();
    var ansicolors_1 = __importDefault(require_ansicolors());
    var { brightBlack } = ansicolors_1.default;
    var FixableBeetStruct = class _FixableBeetStruct {
      /**
       * Creates an instance of the {@link FixableBeetStruct}.
       *
       * @param fields fixed or fixable de/serializers for each field of the {@link Class}
       * @param construct the function that creates an instance of {@link Class}
       * from the args
       * @param description identifies this struct for diagnostics/debugging
       * purposes
       */
      constructor(fields, construct, description = _FixableBeetStruct.description) {
        this.fields = fields;
        this.construct = construct;
        this.description = description;
        let minByteSize = 0;
        if (utils_1.logDebug.enabled) {
          const flds = fields.map(([key, val]) => {
            if ((0, types_1.isFixedSizeBeet)(val)) {
              minByteSize += val.byteSize;
            }
            return `${key}: ${val.description} ${(0, utils_1.beetBytes)(val)}`;
          }).join("\n  ");
          const bytes = `> ${minByteSize} B`;
          (0, utils_1.logDebug)(`struct ${description} {
  ${flds}
} ${brightBlack(bytes)}`);
        }
      }
      /**
       * Deserializes an instance of the Class from the provided buffer starting to
       * read at the provided offset.
       *
       * @returns `[instance of Class, offset into buffer after deserialization completed]`
       */
      deserialize(buffer, offset = 0) {
        return this.toFixedFromData(buffer, offset).deserialize(buffer, offset);
      }
      /**
       * Serializes the provided instance into a new {@link Buffer}
       *
       * **NOTE:** that the `instance` is traversed and each of its fields accessed
       * twice, once to derive a _fixed size_ {@link BeetStruct} and then use it to
       * serialize the `instance`.
       * Therefore ensure that none of the properties that are part of the struct
       * have side effects, i.e. via `Getter`s.
       *
       * @param instance of the struct to serialize
       * @param byteSize allows to override the size fo the created Buffer and
       * defaults to the size of the struct to serialize
       */
      serialize(instance, byteSize) {
        return this.toFixedFromValue(instance).serialize(instance, byteSize);
      }
      toFixedFromData(buf, offset) {
        let cursor = offset;
        const fixedFields = new Array(this.fields.length);
        for (let i = 0; i < this.fields.length; i++) {
          const [key, beet] = this.fields[i];
          const fixedBeet = (0, beet_fixable_1.fixBeetFromData)(beet, buf, cursor);
          fixedFields[i] = [key, fixedBeet];
          cursor += fixedBeet.byteSize;
        }
        return this.description !== _FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);
      }
      toFixedFromValue(args) {
        const argsKeys = Object.keys(args);
        const fixedFields = new Array(this.fields.length);
        for (let i = 0; i < this.fields.length; i++) {
          const [key, beet] = this.fields[i];
          (0, assert_1.strict)(argsKeys.includes(key), `Value with keys [ ${argsKeys} ] should include struct key '${key}' but doesn't.`);
          const val = args[key];
          const fixedBeet = (0, beet_fixable_1.fixBeetFromValue)(beet, val);
          fixedFields[i] = [key, fixedBeet];
        }
        return this.description !== _FixableBeetStruct.description ? new struct_1.BeetStruct(fixedFields, this.construct, this.description) : new struct_1.BeetStruct(fixedFields, this.construct);
      }
      get type() {
        return _FixableBeetStruct.TYPE;
      }
    };
    exports.FixableBeetStruct = FixableBeetStruct;
    FixableBeetStruct.description = "FixableBeetStruct";
    FixableBeetStruct.TYPE = "FixableBeetStruct";
    function isFixableBeetStruct(beet) {
      return beet.type === FixableBeetStruct.TYPE;
    }
    exports.isFixableBeetStruct = isFixableBeetStruct;
    var FixableBeetArgsStruct = class _FixableBeetArgsStruct extends FixableBeetStruct {
      constructor(fields, description = _FixableBeetArgsStruct.description) {
        super(fields, (args) => args, description);
      }
    };
    exports.FixableBeetArgsStruct = FixableBeetArgsStruct;
    FixableBeetArgsStruct.description = "FixableBeetArgsStruct";
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js
var require_unit = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/unit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unitTypeMap = exports.unit = void 0;
    var types_1 = require_types2();
    exports.unit = {
      write: function(_buf, _offset, _value) {
      },
      read: function(_buf, _offset) {
        return void 0;
      },
      byteSize: 0,
      description: "unit"
    };
    exports.unitTypeMap = {
      unit: {
        beet: "unit",
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "void"
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js
var require_enums = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/enums.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;
    var types_1 = require_types2();
    var numbers_1 = require_numbers();
    var assert_1 = require_assert();
    var struct_1 = require_struct();
    var struct_fixable_1 = require_struct_fixable();
    var unit_1 = require_unit();
    function resolveEnumVariant(value, isNumVariant) {
      return isNumVariant ? `${value}` : value;
    }
    function fixedScalarEnum(enumType) {
      const keys = Object.keys(enumType);
      return {
        write(buf, offset, value) {
          const isNumVariant = typeof value === "number";
          const variantKey = resolveEnumVariant(value, isNumVariant);
          if (!keys.includes(variantKey)) {
            assert_1.strict.fail(`${value} should be a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(", ")} ], but isn't`);
          }
          if (isNumVariant) {
            numbers_1.u8.write(buf, offset, value);
          } else {
            const enumValue = enumType[variantKey];
            numbers_1.u8.write(buf, offset, enumValue);
          }
        },
        read(buf, offset) {
          const value = numbers_1.u8.read(buf, offset);
          const isNumVariant = typeof value === "number";
          const variantKey = resolveEnumVariant(value, isNumVariant);
          if (!keys.includes(variantKey)) {
            assert_1.strict.fail(`${value} should be a of a variant of the provided enum type, i.e. [ ${Object.values(enumType).join(", ")} ], but isn't`);
          }
          return isNumVariant ? value : enumType[variantKey];
        },
        byteSize: numbers_1.u8.byteSize,
        description: "Enum"
      };
    }
    exports.fixedScalarEnum = fixedScalarEnum;
    function uniformDataEnum(inner) {
      return {
        write: function(buf, offset, value) {
          numbers_1.u8.write(buf, offset, value.kind);
          inner.write(buf, offset + 1, value.data);
        },
        read: function(buf, offset) {
          const kind = numbers_1.u8.read(buf, offset);
          const data = inner.read(buf, offset + 1);
          return { kind, data };
        },
        byteSize: 1 + inner.byteSize,
        description: `UniformDataEnum<${inner.description}>`
      };
    }
    exports.uniformDataEnum = uniformDataEnum;
    function enumDataVariantBeet(inner, discriminant, kind) {
      return {
        write(buf, offset, value) {
          numbers_1.u8.write(buf, offset, discriminant);
          inner.write(buf, offset + numbers_1.u8.byteSize, value);
        },
        read(buf, offset) {
          const val = inner.read(buf, offset + numbers_1.u8.byteSize);
          return { __kind: kind, ...val };
        },
        byteSize: inner.byteSize + numbers_1.u8.byteSize,
        description: `EnumData<${inner.description}>`
      };
    }
    function dataEnum(variants) {
      for (const [_, beet] of variants) {
        (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) || (0, struct_fixable_1.isFixableBeetStruct)(beet) || // scalar variant
        beet === unit_1.unit, "dataEnum: variants must be a data beet struct or a scalar unit");
      }
      return {
        toFixedFromData(buf, offset) {
          const discriminant = numbers_1.u8.read(buf, offset);
          const variant = variants[discriminant];
          (0, assert_1.strict)(variant != null, `Discriminant ${discriminant} out of range for ${variants.length} variants`);
          const [__kind, dataBeet] = variant;
          const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromData(buf, offset + 1);
          return enumDataVariantBeet(fixed, discriminant, __kind);
        },
        toFixedFromValue(val) {
          if (val.__kind == null) {
            const keys = Object.keys(val).join(", ");
            const validKinds = variants.map(([__kind2]) => __kind2).join(", ");
            assert_1.strict.fail(`Value with fields [ ${keys} ] is missing __kind, which needs to be set to one of [ ${validKinds} ]`);
          }
          const discriminant = variants.findIndex(([__kind2]) => __kind2 === val.__kind);
          if (discriminant < 0) {
            const validKinds = variants.map(([__kind2]) => __kind2).join(", ");
            assert_1.strict.fail(`${val.__kind} is not a valid kind, needs to be one of [ ${validKinds} ]`);
          }
          const variant = variants[discriminant];
          const { __kind, ...dataValue } = val;
          const [__variantKind, dataBeet] = variant;
          const fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromValue(dataValue);
          return enumDataVariantBeet(fixed, discriminant, __variantKind);
        },
        description: `DataEnum<${variants.length} variants>`
      };
    }
    exports.dataEnum = dataEnum;
    exports.enumsTypeMap = {
      fixedScalarEnum: {
        beet: "fixedScalarEnum",
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "<TypeName>",
        arg: types_1.BEET_TYPE_ARG_INNER,
        pack: types_1.BEET_PACKAGE
      },
      dataEnum: {
        beet: "dataEnum",
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "DataEnum<Kind, Inner>",
        arg: types_1.BEET_TYPE_ARG_INNER,
        pack: types_1.BEET_PACKAGE
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js
var require_aliases = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliasesTypeMap = exports.bytes = void 0;
    var collections_1 = require_collections();
    exports.bytes = collections_1.uint8Array;
    exports.aliasesTypeMap = {
      // @ts-ignore
      bytes: collections_1.collectionsTypeMap.Uint8Array
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js
var require_tuples = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/tuples.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tuplesTypeMap = exports.tuple = exports.fixedSizeTuple = void 0;
    var types_1 = require_types2();
    var assert_1 = require_assert();
    var beet_fixable_1 = require_beet_fixable();
    function fixedSizeTuple(elements) {
      const len = elements.length;
      const elDescs = elements.map((x) => x.description);
      const byteSizes = elements.map((x) => x.byteSize);
      const byteSize = byteSizes.reduce((acc, x) => acc + x, 0);
      return {
        write: function(buf, offset, value) {
          assert_1.strict.equal(value.length, len, `tuple value element size ${value.length} should match len ${len}`);
          let cursor = offset;
          for (let i = 0; i < len; i++) {
            const v = value[i];
            const beetEl = elements[i];
            beetEl.write(buf, cursor, v);
            cursor += beetEl.byteSize;
          }
        },
        read: function(buf, offset) {
          const els = [];
          let cursor = offset;
          for (let i = 0; i < len; i++) {
            const elBeet = elements[i];
            els[i] = elBeet.read(buf, cursor);
            cursor += elBeet.byteSize;
          }
          return els;
        },
        byteSize,
        length: len,
        description: `FixedSizeTuple<${elDescs.join(",")}>[ ${byteSizes.join(", ")} ]`
      };
    }
    exports.fixedSizeTuple = fixedSizeTuple;
    function tuple(elements) {
      const len = elements.length;
      const elDescs = elements.map((x) => x.description);
      return {
        toFixedFromData(buf, offset) {
          let cursor = offset;
          const fixedElements = new Array(len);
          for (let i = 0; i < len; i++) {
            const fixedElement = (0, beet_fixable_1.fixBeetFromData)(elements[i], buf, cursor);
            fixedElements[i] = fixedElement;
            cursor += fixedElement.byteSize;
          }
          return fixedSizeTuple(fixedElements);
        },
        toFixedFromValue(vals) {
          (0, assert_1.strict)(Array.isArray(vals), `${vals} should be an array of tuple values`);
          assert_1.strict.equal(vals.length, len, `There should be ${len} tuple values, but there are ${vals.length}`);
          const fixedElements = new Array(len);
          for (let i = 0; i < vals.length; i++) {
            const fixedElement = (0, beet_fixable_1.fixBeetFromValue)(elements[i], vals[i]);
            fixedElements[i] = fixedElement;
          }
          return fixedSizeTuple(fixedElements);
        },
        description: `Tuple<${elDescs.join(",")}>`
      };
    }
    exports.tuple = tuple;
    exports.tuplesTypeMap = {
      Tuple: {
        beet: "tuple",
        isFixable: true,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "[__tuple_elements__]"
      },
      FixedSizeTuple: {
        beet: "fixedSizeTuple",
        isFixable: false,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "[__tuple_elements__]"
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js
var require_maps = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/maps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapsTypeMap = exports.map = void 0;
    var types_1 = require_types2();
    var numbers_1 = require_numbers();
    var utils_1 = require_utils();
    var assert_1 = require_assert();
    function fixedSizeMap(keyElement, valElement, fixedElements, len) {
      const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);
      const valElementFixed = (0, types_1.isFixedSizeBeet)(valElement);
      function determineSizes() {
        if (keyElementFixed && valElementFixed) {
          const elementByteSize2 = keyElement.byteSize + valElement.byteSize;
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + len * elementByteSize2
          };
        } else if (keyElementFixed) {
          let valsByteSize = 0;
          for (const [_, v] of fixedElements.values()) {
            valsByteSize += v.byteSize;
          }
          const elementByteSize2 = keyElement.byteSize + Math.ceil(valsByteSize / len);
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + keyElement.byteSize * len + valsByteSize
          };
        } else if (valElementFixed) {
          let keysByteSize = 0;
          for (const [k, _] of fixedElements.values()) {
            keysByteSize += k.byteSize;
          }
          const elementByteSize2 = Math.ceil(keysByteSize / len) + valElement.byteSize;
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + keysByteSize + valElement.byteSize * len
          };
        } else {
          let keysByteSize = 0;
          let valsByteSize = 0;
          for (const [k, v] of fixedElements.values()) {
            keysByteSize += k.byteSize;
            valsByteSize += v.byteSize;
          }
          const elementByteSize2 = Math.ceil(keysByteSize / len + valsByteSize / len);
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + keysByteSize + valsByteSize
          };
        }
      }
      const { elementByteSize, byteSize } = determineSizes();
      return {
        write: function(buf, offset, map2) {
          let cursor = offset + 4;
          let size = 0;
          for (const [k, v] of map2.entries()) {
            let fixedKey = keyElementFixed ? keyElement : null;
            let fixedVal = valElementFixed ? valElement : null;
            if (fixedKey == null || fixedVal == null) {
              const els = fixedElements.get(k);
              (0, assert_1.strict)(els != null, `Should be able to find beet els for ${(0, utils_1.stringify)(k)}, but could not`);
              fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = els[0];
              fixedVal !== null && fixedVal !== void 0 ? fixedVal : fixedVal = els[1];
            }
            fixedKey.write(buf, cursor, k);
            cursor += fixedKey.byteSize;
            fixedVal.write(buf, cursor, v);
            cursor += fixedVal.byteSize;
            size++;
          }
          numbers_1.u32.write(buf, offset, size);
          assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);
        },
        read: function(buf, offset) {
          const size = numbers_1.u32.read(buf, offset);
          assert_1.strict.equal(size, len, `Expected map to have size ${len}, but has ${size}.`);
          let cursor = offset + 4;
          const map2 = /* @__PURE__ */ new Map();
          for (let i = 0; i < size; i++) {
            const fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);
            const k = fixedKey.read(buf, cursor);
            cursor += fixedKey.byteSize;
            const fixedVal = valElementFixed ? valElement : valElement.toFixedFromData(buf, cursor);
            const v = fixedVal.read(buf, cursor);
            cursor += fixedVal.byteSize;
            map2.set(k, v);
          }
          return map2;
        },
        elementByteSize,
        byteSize,
        length: len,
        lenPrefixByteSize: 4,
        description: `Map<${keyElement.description}, ${valElement.description}>`
      };
    }
    function map(keyElement, valElement) {
      const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);
      const valIsFixed = (0, types_1.isFixedSizeBeet)(valElement);
      return {
        toFixedFromData(buf, offset) {
          const len = numbers_1.u32.read(buf, offset);
          let cursor = offset + 4;
          if (keyIsFixed && valIsFixed) {
            return fixedSizeMap(keyElement, valElement, /* @__PURE__ */ new Map(), len);
          }
          const fixedBeets = /* @__PURE__ */ new Map();
          for (let i = 0; i < len; i++) {
            const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);
            const key = keyFixed.read(buf, cursor);
            cursor += keyFixed.byteSize;
            const valFixed = valIsFixed ? valElement : valElement.toFixedFromData(buf, cursor);
            cursor += valFixed.byteSize;
            fixedBeets.set(key, [keyFixed, valFixed]);
          }
          return fixedSizeMap(keyElement, valElement, fixedBeets, len);
        },
        toFixedFromValue(mapVal) {
          const len = mapVal.size;
          if (keyIsFixed && valIsFixed) {
            return fixedSizeMap(keyElement, valElement, /* @__PURE__ */ new Map(), len);
          }
          const fixedBeets = /* @__PURE__ */ new Map();
          for (const [k, v] of mapVal) {
            const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);
            const valFixed = valIsFixed ? valElement : valElement.toFixedFromValue(v);
            fixedBeets.set(k, [keyFixed, valFixed]);
          }
          return fixedSizeMap(keyElement, valElement, fixedBeets, len);
        },
        description: `FixableMap<${keyElement.description}, ${valElement.description}>`
      };
    }
    exports.map = map;
    exports.mapsTypeMap = {
      Map: {
        beet: "map",
        isFixable: true,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "Map"
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/sets.js
var require_sets = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beets/sets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setsTypeMap = exports.set = void 0;
    var types_1 = require_types2();
    var numbers_1 = require_numbers();
    var utils_1 = require_utils();
    var assert_1 = require_assert();
    function fixedSizeSet(keyElement, fixedElements, len) {
      const keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);
      function determineSizes() {
        if (keyElementFixed) {
          const elementByteSize2 = keyElement.byteSize;
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + len * elementByteSize2
          };
        } else {
          let keysByteSize = 0;
          for (const k of fixedElements.values()) {
            keysByteSize += k.byteSize;
          }
          const elementByteSize2 = Math.ceil(keysByteSize / len);
          return {
            elementByteSize: elementByteSize2,
            byteSize: 4 + keysByteSize
          };
        }
      }
      const { elementByteSize, byteSize } = determineSizes();
      return {
        write: function(buf, offset, set2) {
          let cursor = offset + 4;
          let size = 0;
          for (const k of set2.keys()) {
            let fixedKey = keyElementFixed ? keyElement : null;
            if (fixedKey == null) {
              const el = fixedElements.get(k);
              (0, assert_1.strict)(el != null, `Should be able to find beet el for ${(0, utils_1.stringify)(k)}, but could not`);
              fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = el;
            }
            fixedKey.write(buf, cursor, k);
            cursor += fixedKey.byteSize;
            size++;
          }
          numbers_1.u32.write(buf, offset, size);
          assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);
        },
        read: function(buf, offset) {
          const size = numbers_1.u32.read(buf, offset);
          assert_1.strict.equal(size, len, `Expected set to have size ${len}, but has ${size}.`);
          let cursor = offset + 4;
          const set2 = /* @__PURE__ */ new Set();
          for (let i = 0; i < size; i++) {
            const fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);
            const k = fixedKey.read(buf, cursor);
            cursor += fixedKey.byteSize;
            set2.add(k);
          }
          return set2;
        },
        elementByteSize,
        byteSize,
        length: len,
        lenPrefixByteSize: 4,
        description: `Set<${keyElement.description}>`
      };
    }
    function set(keyElement) {
      const keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);
      return {
        toFixedFromData(buf, offset) {
          const len = numbers_1.u32.read(buf, offset);
          let cursor = offset + 4;
          if (keyIsFixed) {
            return fixedSizeSet(keyElement, /* @__PURE__ */ new Map(), len);
          }
          const fixedBeets = /* @__PURE__ */ new Map();
          for (let i = 0; i < len; i++) {
            const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);
            const key = keyFixed.read(buf, cursor);
            cursor += keyFixed.byteSize;
            fixedBeets.set(key, keyFixed);
          }
          return fixedSizeSet(keyElement, fixedBeets, len);
        },
        toFixedFromValue(setVal) {
          const len = setVal.size;
          if (keyIsFixed) {
            return fixedSizeSet(keyElement, /* @__PURE__ */ new Map(), len);
          }
          const fixedBeets = /* @__PURE__ */ new Map();
          for (const k of setVal) {
            const keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);
            fixedBeets.set(k, keyFixed);
          }
          return fixedSizeSet(keyElement, fixedBeets, len);
        },
        description: `FixableSet<${keyElement.description}>`
      };
    }
    exports.set = set;
    exports.setsTypeMap = {
      Set: {
        beet: "set",
        isFixable: true,
        sourcePack: types_1.BEET_PACKAGE,
        ts: "Set"
      }
    };
  }
});

// node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.js
var require_beet = __commonJS({
  "node_modules/@metaplex-foundation/beet/dist/cjs/src/beet.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedTypeMap = void 0;
    var collections_1 = require_collections();
    var composites_1 = require_composites();
    var numbers_1 = require_numbers();
    var string_1 = require_string();
    var enums_1 = require_enums();
    var aliases_1 = require_aliases();
    var tuples_1 = require_tuples();
    var maps_1 = require_maps();
    var unit_1 = require_unit();
    var sets_1 = require_sets();
    __exportStar(require_aliases(), exports);
    __exportStar(require_collections(), exports);
    __exportStar(require_composites(), exports);
    __exportStar(require_enums(), exports);
    __exportStar(require_maps(), exports);
    __exportStar(require_numbers(), exports);
    __exportStar(require_sets(), exports);
    __exportStar(require_string(), exports);
    __exportStar(require_tuples(), exports);
    __exportStar(require_unit(), exports);
    __exportStar(require_beet_fixable(), exports);
    __exportStar(require_read_write(), exports);
    __exportStar(require_struct(), exports);
    __exportStar(require_struct_fixable(), exports);
    __exportStar(require_types2(), exports);
    exports.supportedTypeMap = {
      ...collections_1.collectionsTypeMap,
      ...string_1.stringTypeMap,
      ...composites_1.compositesTypeMap,
      ...enums_1.enumsTypeMap,
      ...numbers_1.numbersTypeMap,
      ...aliases_1.aliasesTypeMap,
      ...tuples_1.tuplesTypeMap,
      ...maps_1.mapsTypeMap,
      ...sets_1.setsTypeMap,
      ...unit_1.unitTypeMap
    };
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/keys.js
var require_keys = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keysTypeMap = exports.publicKey = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var beet_1 = require_beet();
    var BEET_SOLANA_PACKAGE = "@metaplex-foundation/beet-solana";
    var SOLANA_WEB3_PACKAGE = "@solana/web3.js";
    var uint8Array32 = (0, beet_1.fixedSizeUint8Array)(32);
    exports.publicKey = {
      write: function(buf, offset, value) {
        const arr = value.toBytes();
        uint8Array32.write(buf, offset, arr);
      },
      read: function(buf, offset) {
        const bytes = uint8Array32.read(buf, offset);
        return new web3_js_1.PublicKey(bytes);
      },
      byteSize: uint8Array32.byteSize,
      description: "PublicKey"
    };
    exports.keysTypeMap = {
      publicKey: {
        beet: "publicKey",
        isFixable: false,
        sourcePack: BEET_SOLANA_PACKAGE,
        ts: "PublicKey",
        pack: SOLANA_WEB3_PACKAGE
      }
    };
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.logTrace = exports.logDebug = exports.logInfo = exports.logError = void 0;
    var debug_1 = __importDefault(require_browser2());
    exports.logError = (0, debug_1.default)("beet:error");
    exports.logInfo = (0, debug_1.default)("beet:info");
    exports.logDebug = (0, debug_1.default)("beet:debug");
    exports.logTrace = (0, debug_1.default)("beet:trace");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/gpa/util.js
var require_util = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/gpa/util.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFixedBeet = void 0;
    var bs58_1 = __importDefault(require_bs58());
    function encodeFixedBeet(beet, val) {
      const buf = Buffer.alloc(beet.byteSize);
      beet.write(buf, 0, val);
      return bs58_1.default.encode(buf);
    }
    exports.encodeFixedBeet = encodeFixedBeet;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/gpa/index.js
var require_gpa = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/gpa/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GpaBuilder = void 0;
    var beet_1 = require_beet();
    var assert_1 = require_assert();
    var utils_1 = require_utils2();
    var util_1 = require_util();
    var GpaBuilder = class _GpaBuilder {
      constructor(programId, beets, accountSize) {
        this.programId = programId;
        this.beets = beets;
        this.accountSize = accountSize;
        this.config = {};
      }
      _addFilter(filter) {
        if (this.config.filters == null) {
          this.config.filters = [];
        }
        this.config.filters.push(filter);
        return this;
      }
      _addInnerFilter(key, innerKey, val) {
        (0, utils_1.logTrace)(`gpa.addInnerFilter: ${key}.${innerKey}`);
        const outerBeetInfo = this.beets.get(key);
        (0, assert_1.strict)(outerBeetInfo != null, "Outer filter key needs to be an existing field name");
        const beetInfo = outerBeetInfo.beet;
        let offset = outerBeetInfo.offset;
        const outerBeet = (0, beet_1.isFixedSizeBeet)(beetInfo) ? beetInfo : beetInfo.toFixedFromValue(val);
        let beet;
        for (const [k, v] of outerBeet.fields) {
          if (k === innerKey) {
            beet = v;
            break;
          }
          offset += v.byteSize;
        }
        (0, assert_1.strict)(beet != null, `${innerKey} is not a field of the ${key} struct`);
        const bytes = (0, util_1.encodeFixedBeet)(beet, val);
        this._addFilter({ memcmp: { offset, bytes } });
        return this;
      }
      /**
       * Adds a _memcmp_ filter for a field inside a field which is a struct value.
       * The provided keys need to be separated by a `.` and only one level of
       * nesting is supported at this point.
       *
       * The filter is applied to the inner value.
       *
       * ## Example
       *
       * ### Given:
       *
       * ```typescript
       * type Inner = {
       *   a: number
       * }
       * type Outer = {
       *   idx: number
       *   inner: Inner
       * }
       * ```
       * ### Apply a filter on `a` of the `Inner` type:
       *
       * ```typescript
       * gpaBuilder.addInnerFilter('inner.a', 2)
       * ```
       *
       * @param keys - the names of the fields by which to filter, i.e. `'outer.inner'`
       * @param val - the field value that the filter should match
       */
      addInnerFilter(keys, val) {
        const parts = keys.split(".");
        assert_1.strict.equal(parts.length, 2, `inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not`);
        const [ka, kb] = parts;
        return this._addInnerFilter(ka, kb, val);
      }
      /**
       * Adds a _memcmp_ filter for the provided {@link key} of the struct.
       *
       * @param key - the name of the field by which to filter
       * @param val - the field value that the filter should match
       */
      addFilter(key, val) {
        const beetInfo = this.beets.get(key);
        (0, assert_1.strict)(beetInfo != null, "Filter key needs to be an existing field name");
        const beet = (0, beet_1.isFixedSizeBeet)(beetInfo.beet) ? beetInfo.beet : beetInfo.beet.toFixedFromValue(val);
        const bytes = (0, util_1.encodeFixedBeet)(beet, val);
        this._addFilter({ memcmp: { offset: beetInfo.offset, bytes } });
        return this;
      }
      /**
       * Adds a `dataSize` filter which will match on account's sizes.
       * You have to provide that {@link size} for accounts that don't have a fixed size.
       * For _fixed_ size accounts that size is determined for you.
       *
       * @param size - the account size to match for
       */
      dataSize(size) {
        size = size !== null && size !== void 0 ? size : this.accountSize;
        (0, assert_1.strict)(size != null, "for accounts of dynamic size the dataSize arg needs to be provided");
        return this._addFilter({ dataSize: size });
      }
      /**
       * Attempts to find the accounts matching the configured filters.
       *
       * @param connection used to query the program accounts on the cluster
       */
      run(connection) {
        return connection.getProgramAccounts(this.programId, this.config);
      }
      /**
       * Creates a GPA builder that supports adding up to four filters for
       * fixed size fields.
       *
       * Once a non-fixed field is encountered, the remaining fields following it
       * will not be included as a filter option since their position in the
       * bytes array will change depending on the content of the non-fixed field.
       *
       * @param programId - the id of the program that owns the accounts we are querying
       * @param beetFields - the beet fields that make up the structure of the account data
       */
      static fromBeetFields(programId, beetFields) {
        const map = /* @__PURE__ */ new Map();
        let offset = 0;
        let encounteredNonFixed = false;
        for (const [k, v] of beetFields) {
          map.set(k, { beet: v, offset });
          if (!(0, beet_1.isFixedSizeBeet)(v)) {
            encounteredNonFixed = true;
            break;
          }
          offset += v.byteSize;
        }
        const accountSize = encounteredNonFixed ? void 0 : offset;
        return new _GpaBuilder(programId, map, accountSize);
      }
      /**
       * Convenience wrapper around {@link GpaBuilder.fromBeetFields} that allows
       * providing a struct which contains the beet fields.
       *
       * @param programId - the id of the program that owns the accounts we are querying
       * @param struct - containing the beet `fields` specifying the layout of the account
       */
      static fromStruct(programId, struct) {
        return _GpaBuilder.fromBeetFields(programId, struct.fields);
      }
    };
    exports.GpaBuilder = GpaBuilder;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/beet-solana.js
var require_beet_solana = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@metaplex-foundation/beet-solana/dist/cjs/src/beet-solana.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedTypeMap = void 0;
    var keys_1 = require_keys();
    __exportStar(require_keys(), exports);
    __exportStar(require_gpa(), exports);
    exports.supportedTypeMap = keys_1.keysTypeMap;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Key.js
var require_Key = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Key.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keyBeet = exports.Key = void 0;
    var beet = __importStar(require_beet());
    var Key;
    (function(Key2) {
      Key2[Key2["Uninitialized"] = 0] = "Uninitialized";
      Key2[Key2["EditionV1"] = 1] = "EditionV1";
      Key2[Key2["MasterEditionV1"] = 2] = "MasterEditionV1";
      Key2[Key2["ReservationListV1"] = 3] = "ReservationListV1";
      Key2[Key2["MetadataV1"] = 4] = "MetadataV1";
      Key2[Key2["ReservationListV2"] = 5] = "ReservationListV2";
      Key2[Key2["MasterEditionV2"] = 6] = "MasterEditionV2";
      Key2[Key2["EditionMarker"] = 7] = "EditionMarker";
      Key2[Key2["UseAuthorityRecord"] = 8] = "UseAuthorityRecord";
      Key2[Key2["CollectionAuthorityRecord"] = 9] = "CollectionAuthorityRecord";
      Key2[Key2["TokenOwnedEscrow"] = 10] = "TokenOwnedEscrow";
      Key2[Key2["TokenRecord"] = 11] = "TokenRecord";
      Key2[Key2["MetadataDelegate"] = 12] = "MetadataDelegate";
      Key2[Key2["EditionMarkerV2"] = 13] = "EditionMarkerV2";
    })(Key = exports.Key || (exports.Key = {}));
    exports.keyBeet = beet.fixedScalarEnum(Key);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/CollectionAuthorityRecord.js
var require_CollectionAuthorityRecord = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/CollectionAuthorityRecord.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionAuthorityRecordBeet = exports.CollectionAuthorityRecord = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var CollectionAuthorityRecord = class _CollectionAuthorityRecord {
      constructor(key, bump, updateAuthority) {
        this.key = key;
        this.bump = bump;
        this.updateAuthority = updateAuthority;
      }
      static fromArgs(args) {
        return new _CollectionAuthorityRecord(args.key, args.bump, args.updateAuthority);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _CollectionAuthorityRecord.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find CollectionAuthorityRecord account at ${address}`);
        }
        return _CollectionAuthorityRecord.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.collectionAuthorityRecordBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.collectionAuthorityRecordBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.collectionAuthorityRecordBeet.serialize(this);
      }
      static byteSize(args) {
        const instance = _CollectionAuthorityRecord.fromArgs(args);
        return exports.collectionAuthorityRecordBeet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_CollectionAuthorityRecord.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          bump: this.bump,
          updateAuthority: this.updateAuthority
        };
      }
    };
    exports.CollectionAuthorityRecord = CollectionAuthorityRecord;
    exports.collectionAuthorityRecordBeet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["bump", beet.u8],
      ["updateAuthority", beet.coption(beetSolana.publicKey)]
    ], CollectionAuthorityRecord.fromArgs, "CollectionAuthorityRecord");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/Edition.js
var require_Edition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/Edition.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editionBeet = exports.Edition = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var Edition = class _Edition {
      constructor(key, parent, edition) {
        this.key = key;
        this.parent = parent;
        this.edition = edition;
      }
      static fromArgs(args) {
        return new _Edition(args.key, args.parent, args.edition);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _Edition.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find Edition account at ${address}`);
        }
        return _Edition.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.editionBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.editionBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.editionBeet.serialize(this);
      }
      static get byteSize() {
        return exports.editionBeet.byteSize;
      }
      static async getMinimumBalanceForRentExemption(connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_Edition.byteSize, commitment);
      }
      static hasCorrectByteSize(buf, offset = 0) {
        return buf.byteLength - offset === _Edition.byteSize;
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          parent: this.parent.toBase58(),
          edition: (() => {
            const x = this.edition;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })()
        };
      }
    };
    exports.Edition = Edition;
    exports.editionBeet = new beet.BeetStruct([
      ["key", Key_1.keyBeet],
      ["parent", beetSolana.publicKey],
      ["edition", beet.u64]
    ], Edition.fromArgs, "Edition");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/EditionMarker.js
var require_EditionMarker = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/EditionMarker.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editionMarkerBeet = exports.EditionMarker = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var EditionMarker = class _EditionMarker {
      constructor(key, ledger) {
        this.key = key;
        this.ledger = ledger;
      }
      static fromArgs(args) {
        return new _EditionMarker(args.key, args.ledger);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _EditionMarker.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find EditionMarker account at ${address}`);
        }
        return _EditionMarker.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.editionMarkerBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.editionMarkerBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.editionMarkerBeet.serialize(this);
      }
      static get byteSize() {
        return exports.editionMarkerBeet.byteSize;
      }
      static async getMinimumBalanceForRentExemption(connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_EditionMarker.byteSize, commitment);
      }
      static hasCorrectByteSize(buf, offset = 0) {
        return buf.byteLength - offset === _EditionMarker.byteSize;
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          ledger: this.ledger
        };
      }
    };
    exports.EditionMarker = EditionMarker;
    exports.editionMarkerBeet = new beet.BeetStruct([
      ["key", Key_1.keyBeet],
      ["ledger", beet.uniformFixedSizeArray(beet.u8, 31)]
    ], EditionMarker.fromArgs, "EditionMarker");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/EditionMarkerV2.js
var require_EditionMarkerV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/EditionMarkerV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.editionMarkerV2Beet = exports.EditionMarkerV2 = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var EditionMarkerV2 = class _EditionMarkerV2 {
      constructor(key, ledger) {
        this.key = key;
        this.ledger = ledger;
      }
      static fromArgs(args) {
        return new _EditionMarkerV2(args.key, args.ledger);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _EditionMarkerV2.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find EditionMarkerV2 account at ${address}`);
        }
        return _EditionMarkerV2.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.editionMarkerV2Beet);
      }
      static deserialize(buf, offset = 0) {
        return exports.editionMarkerV2Beet.deserialize(buf, offset);
      }
      serialize() {
        return exports.editionMarkerV2Beet.serialize(this);
      }
      static byteSize(args) {
        const instance = _EditionMarkerV2.fromArgs(args);
        return exports.editionMarkerV2Beet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_EditionMarkerV2.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          ledger: this.ledger
        };
      }
    };
    exports.EditionMarkerV2 = EditionMarkerV2;
    exports.editionMarkerV2Beet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["ledger", beet.bytes]
    ], EditionMarkerV2.fromArgs, "EditionMarkerV2");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MasterEditionV1.js
var require_MasterEditionV1 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MasterEditionV1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.masterEditionV1Beet = exports.MasterEditionV1 = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var MasterEditionV1 = class _MasterEditionV1 {
      constructor(key, supply, maxSupply, printingMint, oneTimePrintingAuthorizationMint) {
        this.key = key;
        this.supply = supply;
        this.maxSupply = maxSupply;
        this.printingMint = printingMint;
        this.oneTimePrintingAuthorizationMint = oneTimePrintingAuthorizationMint;
      }
      static fromArgs(args) {
        return new _MasterEditionV1(args.key, args.supply, args.maxSupply, args.printingMint, args.oneTimePrintingAuthorizationMint);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _MasterEditionV1.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find MasterEditionV1 account at ${address}`);
        }
        return _MasterEditionV1.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.masterEditionV1Beet);
      }
      static deserialize(buf, offset = 0) {
        return exports.masterEditionV1Beet.deserialize(buf, offset);
      }
      serialize() {
        return exports.masterEditionV1Beet.serialize(this);
      }
      static byteSize(args) {
        const instance = _MasterEditionV1.fromArgs(args);
        return exports.masterEditionV1Beet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_MasterEditionV1.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          supply: (() => {
            const x = this.supply;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })(),
          maxSupply: this.maxSupply,
          printingMint: this.printingMint.toBase58(),
          oneTimePrintingAuthorizationMint: this.oneTimePrintingAuthorizationMint.toBase58()
        };
      }
    };
    exports.MasterEditionV1 = MasterEditionV1;
    exports.masterEditionV1Beet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["supply", beet.u64],
      ["maxSupply", beet.coption(beet.u64)],
      ["printingMint", beetSolana.publicKey],
      ["oneTimePrintingAuthorizationMint", beetSolana.publicKey]
    ], MasterEditionV1.fromArgs, "MasterEditionV1");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MasterEditionV2.js
var require_MasterEditionV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MasterEditionV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.masterEditionV2Beet = exports.MasterEditionV2 = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var MasterEditionV2 = class _MasterEditionV2 {
      constructor(key, supply, maxSupply) {
        this.key = key;
        this.supply = supply;
        this.maxSupply = maxSupply;
      }
      static fromArgs(args) {
        return new _MasterEditionV2(args.key, args.supply, args.maxSupply);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _MasterEditionV2.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find MasterEditionV2 account at ${address}`);
        }
        return _MasterEditionV2.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.masterEditionV2Beet);
      }
      static deserialize(buf, offset = 0) {
        return exports.masterEditionV2Beet.deserialize(buf, offset);
      }
      serialize() {
        return exports.masterEditionV2Beet.serialize(this);
      }
      static byteSize(args) {
        const instance = _MasterEditionV2.fromArgs(args);
        return exports.masterEditionV2Beet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_MasterEditionV2.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          supply: (() => {
            const x = this.supply;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })(),
          maxSupply: this.maxSupply
        };
      }
    };
    exports.MasterEditionV2 = MasterEditionV2;
    exports.masterEditionV2Beet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["supply", beet.u64],
      ["maxSupply", beet.coption(beet.u64)]
    ], MasterEditionV2.fromArgs, "MasterEditionV2");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Creator.js
var require_Creator = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Creator.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.creatorBeet = void 0;
    var beetSolana = __importStar(require_beet_solana());
    var beet = __importStar(require_beet());
    exports.creatorBeet = new beet.BeetArgsStruct([
      ["address", beetSolana.publicKey],
      ["verified", beet.bool],
      ["share", beet.u8]
    ], "Creator");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Data.js
var require_Data = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Data.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataBeet = void 0;
    var beet = __importStar(require_beet());
    var Creator_1 = require_Creator();
    exports.dataBeet = new beet.FixableBeetArgsStruct([
      ["name", beet.utf8String],
      ["symbol", beet.utf8String],
      ["uri", beet.utf8String],
      ["sellerFeeBasisPoints", beet.u16],
      ["creators", beet.coption(beet.array(Creator_1.creatorBeet))]
    ], "Data");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenStandard.js
var require_TokenStandard = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenStandard.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenStandardBeet = exports.TokenStandard = void 0;
    var beet = __importStar(require_beet());
    var TokenStandard;
    (function(TokenStandard2) {
      TokenStandard2[TokenStandard2["NonFungible"] = 0] = "NonFungible";
      TokenStandard2[TokenStandard2["FungibleAsset"] = 1] = "FungibleAsset";
      TokenStandard2[TokenStandard2["Fungible"] = 2] = "Fungible";
      TokenStandard2[TokenStandard2["NonFungibleEdition"] = 3] = "NonFungibleEdition";
      TokenStandard2[TokenStandard2["ProgrammableNonFungible"] = 4] = "ProgrammableNonFungible";
      TokenStandard2[TokenStandard2["ProgrammableNonFungibleEdition"] = 5] = "ProgrammableNonFungibleEdition";
    })(TokenStandard = exports.TokenStandard || (exports.TokenStandard = {}));
    exports.tokenStandardBeet = beet.fixedScalarEnum(TokenStandard);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Collection.js
var require_Collection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Collection.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionBeet = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    exports.collectionBeet = new beet.BeetArgsStruct([
      ["verified", beet.bool],
      ["key", beetSolana.publicKey]
    ], "Collection");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UseMethod.js
var require_UseMethod = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UseMethod.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMethodBeet = exports.UseMethod = void 0;
    var beet = __importStar(require_beet());
    var UseMethod;
    (function(UseMethod2) {
      UseMethod2[UseMethod2["Burn"] = 0] = "Burn";
      UseMethod2[UseMethod2["Multiple"] = 1] = "Multiple";
      UseMethod2[UseMethod2["Single"] = 2] = "Single";
    })(UseMethod = exports.UseMethod || (exports.UseMethod = {}));
    exports.useMethodBeet = beet.fixedScalarEnum(UseMethod);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Uses.js
var require_Uses = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Uses.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usesBeet = void 0;
    var beet = __importStar(require_beet());
    var UseMethod_1 = require_UseMethod();
    exports.usesBeet = new beet.BeetArgsStruct([
      ["useMethod", UseMethod_1.useMethodBeet],
      ["remaining", beet.u64],
      ["total", beet.u64]
    ], "Uses");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionDetails.js
var require_CollectionDetails = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionDetails.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionDetailsBeet = exports.isCollectionDetailsV1 = void 0;
    var beet = __importStar(require_beet());
    var isCollectionDetailsV1 = (x) => x.__kind === "V1";
    exports.isCollectionDetailsV1 = isCollectionDetailsV1;
    exports.collectionDetailsBeet = beet.dataEnum([
      [
        "V1",
        new beet.BeetArgsStruct([["size", beet.u64]], 'CollectionDetailsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ProgrammableConfig.js
var require_ProgrammableConfig = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ProgrammableConfig.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.programmableConfigBeet = exports.isProgrammableConfigV1 = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var isProgrammableConfigV1 = (x) => x.__kind === "V1";
    exports.isProgrammableConfigV1 = isProgrammableConfigV1;
    exports.programmableConfigBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([["ruleSet", beet.coption(beetSolana.publicKey)]], 'ProgrammableConfigRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/metadata-deserializer.js
var require_metadata_deserializer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/metadata-deserializer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Metadata_1 = require_Metadata();
    var Collection_1 = require_Collection();
    var CollectionDetails_1 = require_CollectionDetails();
    var ProgrammableConfig_1 = require_ProgrammableConfig();
    var Data_1 = require_Data();
    var Key_1 = require_Key();
    var TokenStandard_1 = require_TokenStandard();
    var Uses_1 = require_Uses();
    var NONE_BYTE_SIZE = beet.coptionNone("").byteSize;
    function deserialize(buf, offset = 0) {
      let cursor = offset;
      const key = Key_1.keyBeet.read(buf, cursor);
      cursor += Key_1.keyBeet.byteSize;
      const updateAuthority = beetSolana.publicKey.read(buf, cursor);
      cursor += beetSolana.publicKey.byteSize;
      const mint = beetSolana.publicKey.read(buf, cursor);
      cursor += beetSolana.publicKey.byteSize;
      const [data, dataDelta] = Data_1.dataBeet.deserialize(buf, cursor);
      cursor = dataDelta;
      const primarySaleHappened = beet.bool.read(buf, cursor);
      cursor += beet.bool.byteSize;
      const isMutable = beet.bool.read(buf, cursor);
      cursor += beet.bool.byteSize;
      const editionNonceBeet = beet.coption(beet.u8).toFixedFromData(buf, cursor);
      const editionNonce = editionNonceBeet.read(buf, cursor);
      cursor += editionNonceBeet.byteSize;
      const [tokenStandard, tokenDelta, tokenCorrupted] = tryReadOption(beet.coption(TokenStandard_1.tokenStandardBeet), buf, cursor);
      cursor += tokenDelta;
      const [collection, collectionDelta, collectionCorrupted] = tokenCorrupted ? [null, NONE_BYTE_SIZE, true] : tryReadOption(beet.coption(Collection_1.collectionBeet), buf, cursor);
      cursor += collectionDelta;
      const [uses, usesDelta, usesCorrupted] = tokenCorrupted || collectionCorrupted ? [null, NONE_BYTE_SIZE, true] : tryReadOption(beet.coption(Uses_1.usesBeet), buf, cursor);
      cursor += usesDelta;
      const [collectionDetails, collectionDetailsDelta, collectionDetailsCorrupted] = tokenCorrupted || collectionCorrupted || usesCorrupted ? [null, NONE_BYTE_SIZE, true] : tryReadOption(beet.coption(CollectionDetails_1.collectionDetailsBeet), buf, cursor);
      cursor += collectionDetailsDelta;
      const [programmableConfig, programmableConfigDelta, programmableConfigCorrupted] = tokenCorrupted || collectionCorrupted || usesCorrupted ? [null, NONE_BYTE_SIZE, true] : tryReadOption(beet.coption(ProgrammableConfig_1.programmableConfigBeet), buf, cursor);
      cursor += programmableConfigDelta;
      const anyCorrupted = tokenCorrupted || collectionCorrupted || usesCorrupted || collectionDetailsCorrupted || programmableConfigCorrupted;
      const args = {
        key,
        updateAuthority,
        mint,
        data,
        primarySaleHappened,
        isMutable,
        editionNonce,
        tokenStandard: anyCorrupted ? null : tokenStandard,
        collection: anyCorrupted ? null : collection,
        uses: anyCorrupted ? null : uses,
        collectionDetails: anyCorrupted ? null : collectionDetails,
        programmableConfig: anyCorrupted ? null : programmableConfig
      };
      return [Metadata_1.Metadata.fromArgs(args), cursor];
    }
    exports.deserialize = deserialize;
    function tryReadOption(optionBeet, buf, offset) {
      try {
        const fixed = optionBeet.toFixedFromData(buf, offset);
        const value = fixed.read(buf, offset);
        return [value, fixed.byteSize, false];
      } catch (e) {
        return [null, NONE_BYTE_SIZE, true];
      }
    }
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/Metadata.js
var require_Metadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/Metadata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metadataBeet = exports.Metadata = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var Data_1 = require_Data();
    var TokenStandard_1 = require_TokenStandard();
    var Collection_1 = require_Collection();
    var Uses_1 = require_Uses();
    var CollectionDetails_1 = require_CollectionDetails();
    var ProgrammableConfig_1 = require_ProgrammableConfig();
    var customSerializer = __importStar(require_metadata_deserializer());
    var Metadata = class _Metadata {
      constructor(key, updateAuthority, mint, data, primarySaleHappened, isMutable, editionNonce, tokenStandard, collection, uses, collectionDetails, programmableConfig) {
        this.key = key;
        this.updateAuthority = updateAuthority;
        this.mint = mint;
        this.data = data;
        this.primarySaleHappened = primarySaleHappened;
        this.isMutable = isMutable;
        this.editionNonce = editionNonce;
        this.tokenStandard = tokenStandard;
        this.collection = collection;
        this.uses = uses;
        this.collectionDetails = collectionDetails;
        this.programmableConfig = programmableConfig;
      }
      static fromArgs(args) {
        return new _Metadata(args.key, args.updateAuthority, args.mint, args.data, args.primarySaleHappened, args.isMutable, args.editionNonce, args.tokenStandard, args.collection, args.uses, args.collectionDetails, args.programmableConfig);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _Metadata.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find Metadata account at ${address}`);
        }
        return _Metadata.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.metadataBeet);
      }
      static deserialize(buf, offset = 0) {
        return resolvedDeserialize(buf, offset);
      }
      serialize() {
        return resolvedSerialize(this);
      }
      static byteSize(args) {
        const instance = _Metadata.fromArgs(args);
        return exports.metadataBeet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_Metadata.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          updateAuthority: this.updateAuthority.toBase58(),
          mint: this.mint.toBase58(),
          data: this.data,
          primarySaleHappened: this.primarySaleHappened,
          isMutable: this.isMutable,
          editionNonce: this.editionNonce,
          tokenStandard: this.tokenStandard,
          collection: this.collection,
          uses: this.uses,
          collectionDetails: this.collectionDetails,
          programmableConfig: this.programmableConfig
        };
      }
    };
    exports.Metadata = Metadata;
    exports.metadataBeet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["updateAuthority", beetSolana.publicKey],
      ["mint", beetSolana.publicKey],
      ["data", Data_1.dataBeet],
      ["primarySaleHappened", beet.bool],
      ["isMutable", beet.bool],
      ["editionNonce", beet.coption(beet.u8)],
      ["tokenStandard", beet.coption(TokenStandard_1.tokenStandardBeet)],
      ["collection", beet.coption(Collection_1.collectionBeet)],
      ["uses", beet.coption(Uses_1.usesBeet)],
      ["collectionDetails", beet.coption(CollectionDetails_1.collectionDetailsBeet)],
      ["programmableConfig", beet.coption(ProgrammableConfig_1.programmableConfigBeet)]
    ], Metadata.fromArgs, "Metadata");
    var serializer = customSerializer;
    var resolvedSerialize = typeof serializer.serialize === "function" ? serializer.serialize.bind(serializer) : exports.metadataBeet.serialize.bind(exports.metadataBeet);
    var resolvedDeserialize = typeof serializer.deserialize === "function" ? serializer.deserialize.bind(serializer) : exports.metadataBeet.deserialize.bind(exports.metadataBeet);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MetadataDelegateRecord.js
var require_MetadataDelegateRecord = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/MetadataDelegateRecord.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metadataDelegateRecordBeet = exports.MetadataDelegateRecord = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var MetadataDelegateRecord = class _MetadataDelegateRecord {
      constructor(key, bump, mint, delegate, updateAuthority) {
        this.key = key;
        this.bump = bump;
        this.mint = mint;
        this.delegate = delegate;
        this.updateAuthority = updateAuthority;
      }
      static fromArgs(args) {
        return new _MetadataDelegateRecord(args.key, args.bump, args.mint, args.delegate, args.updateAuthority);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _MetadataDelegateRecord.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find MetadataDelegateRecord account at ${address}`);
        }
        return _MetadataDelegateRecord.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.metadataDelegateRecordBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.metadataDelegateRecordBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.metadataDelegateRecordBeet.serialize(this);
      }
      static get byteSize() {
        return exports.metadataDelegateRecordBeet.byteSize;
      }
      static async getMinimumBalanceForRentExemption(connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_MetadataDelegateRecord.byteSize, commitment);
      }
      static hasCorrectByteSize(buf, offset = 0) {
        return buf.byteLength - offset === _MetadataDelegateRecord.byteSize;
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          bump: this.bump,
          mint: this.mint.toBase58(),
          delegate: this.delegate.toBase58(),
          updateAuthority: this.updateAuthority.toBase58()
        };
      }
    };
    exports.MetadataDelegateRecord = MetadataDelegateRecord;
    exports.metadataDelegateRecordBeet = new beet.BeetStruct([
      ["key", Key_1.keyBeet],
      ["bump", beet.u8],
      ["mint", beetSolana.publicKey],
      ["delegate", beetSolana.publicKey],
      ["updateAuthority", beetSolana.publicKey]
    ], MetadataDelegateRecord.fromArgs, "MetadataDelegateRecord");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ReservationV1.js
var require_ReservationV1 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ReservationV1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reservationV1Beet = void 0;
    var beetSolana = __importStar(require_beet_solana());
    var beet = __importStar(require_beet());
    exports.reservationV1Beet = new beet.BeetArgsStruct([
      ["address", beetSolana.publicKey],
      ["spotsRemaining", beet.u8],
      ["totalSpots", beet.u8]
    ], "ReservationV1");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/ReservationListV1.js
var require_ReservationListV1 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/ReservationListV1.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reservationListV1Beet = exports.ReservationListV1 = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var ReservationV1_1 = require_ReservationV1();
    var ReservationListV1 = class _ReservationListV1 {
      constructor(key, masterEdition, supplySnapshot, reservations) {
        this.key = key;
        this.masterEdition = masterEdition;
        this.supplySnapshot = supplySnapshot;
        this.reservations = reservations;
      }
      static fromArgs(args) {
        return new _ReservationListV1(args.key, args.masterEdition, args.supplySnapshot, args.reservations);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _ReservationListV1.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find ReservationListV1 account at ${address}`);
        }
        return _ReservationListV1.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.reservationListV1Beet);
      }
      static deserialize(buf, offset = 0) {
        return exports.reservationListV1Beet.deserialize(buf, offset);
      }
      serialize() {
        return exports.reservationListV1Beet.serialize(this);
      }
      static byteSize(args) {
        const instance = _ReservationListV1.fromArgs(args);
        return exports.reservationListV1Beet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_ReservationListV1.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          masterEdition: this.masterEdition.toBase58(),
          supplySnapshot: this.supplySnapshot,
          reservations: this.reservations
        };
      }
    };
    exports.ReservationListV1 = ReservationListV1;
    exports.reservationListV1Beet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["masterEdition", beetSolana.publicKey],
      ["supplySnapshot", beet.coption(beet.u64)],
      ["reservations", beet.array(ReservationV1_1.reservationV1Beet)]
    ], ReservationListV1.fromArgs, "ReservationListV1");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Reservation.js
var require_Reservation = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Reservation.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reservationBeet = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    exports.reservationBeet = new beet.BeetArgsStruct([
      ["address", beetSolana.publicKey],
      ["spotsRemaining", beet.u64],
      ["totalSpots", beet.u64]
    ], "Reservation");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/ReservationListV2.js
var require_ReservationListV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/ReservationListV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reservationListV2Beet = exports.ReservationListV2 = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var Reservation_1 = require_Reservation();
    var ReservationListV2 = class _ReservationListV2 {
      constructor(key, masterEdition, supplySnapshot, reservations, totalReservationSpots, currentReservationSpots) {
        this.key = key;
        this.masterEdition = masterEdition;
        this.supplySnapshot = supplySnapshot;
        this.reservations = reservations;
        this.totalReservationSpots = totalReservationSpots;
        this.currentReservationSpots = currentReservationSpots;
      }
      static fromArgs(args) {
        return new _ReservationListV2(args.key, args.masterEdition, args.supplySnapshot, args.reservations, args.totalReservationSpots, args.currentReservationSpots);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _ReservationListV2.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find ReservationListV2 account at ${address}`);
        }
        return _ReservationListV2.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.reservationListV2Beet);
      }
      static deserialize(buf, offset = 0) {
        return exports.reservationListV2Beet.deserialize(buf, offset);
      }
      serialize() {
        return exports.reservationListV2Beet.serialize(this);
      }
      static byteSize(args) {
        const instance = _ReservationListV2.fromArgs(args);
        return exports.reservationListV2Beet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_ReservationListV2.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          masterEdition: this.masterEdition.toBase58(),
          supplySnapshot: this.supplySnapshot,
          reservations: this.reservations,
          totalReservationSpots: (() => {
            const x = this.totalReservationSpots;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })(),
          currentReservationSpots: (() => {
            const x = this.currentReservationSpots;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })()
        };
      }
    };
    exports.ReservationListV2 = ReservationListV2;
    exports.reservationListV2Beet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["masterEdition", beetSolana.publicKey],
      ["supplySnapshot", beet.coption(beet.u64)],
      ["reservations", beet.array(Reservation_1.reservationBeet)],
      ["totalReservationSpots", beet.u64],
      ["currentReservationSpots", beet.u64]
    ], ReservationListV2.fromArgs, "ReservationListV2");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/EscrowAuthority.js
var require_EscrowAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/EscrowAuthority.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escrowAuthorityBeet = exports.isEscrowAuthorityCreator = exports.isEscrowAuthorityTokenOwner = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var isEscrowAuthorityTokenOwner = (x) => x.__kind === "TokenOwner";
    exports.isEscrowAuthorityTokenOwner = isEscrowAuthorityTokenOwner;
    var isEscrowAuthorityCreator = (x) => x.__kind === "Creator";
    exports.isEscrowAuthorityCreator = isEscrowAuthorityCreator;
    exports.escrowAuthorityBeet = beet.dataEnum([
      ["TokenOwner", beet.unit],
      [
        "Creator",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([beetSolana.publicKey])]], 'EscrowAuthorityRecord["Creator"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/TokenOwnedEscrow.js
var require_TokenOwnedEscrow = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/TokenOwnedEscrow.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenOwnedEscrowBeet = exports.TokenOwnedEscrow = void 0;
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var beet = __importStar(require_beet());
    var Key_1 = require_Key();
    var EscrowAuthority_1 = require_EscrowAuthority();
    var TokenOwnedEscrow = class _TokenOwnedEscrow {
      constructor(key, baseToken, authority, bump) {
        this.key = key;
        this.baseToken = baseToken;
        this.authority = authority;
        this.bump = bump;
      }
      static fromArgs(args) {
        return new _TokenOwnedEscrow(args.key, args.baseToken, args.authority, args.bump);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _TokenOwnedEscrow.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find TokenOwnedEscrow account at ${address}`);
        }
        return _TokenOwnedEscrow.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.tokenOwnedEscrowBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.tokenOwnedEscrowBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.tokenOwnedEscrowBeet.serialize(this);
      }
      static byteSize(args) {
        const instance = _TokenOwnedEscrow.fromArgs(args);
        return exports.tokenOwnedEscrowBeet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_TokenOwnedEscrow.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          baseToken: this.baseToken.toBase58(),
          authority: this.authority.__kind,
          bump: this.bump
        };
      }
    };
    exports.TokenOwnedEscrow = TokenOwnedEscrow;
    exports.tokenOwnedEscrowBeet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["baseToken", beetSolana.publicKey],
      ["authority", EscrowAuthority_1.escrowAuthorityBeet],
      ["bump", beet.u8]
    ], TokenOwnedEscrow.fromArgs, "TokenOwnedEscrow");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenState.js
var require_TokenState = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenState.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenStateBeet = exports.TokenState = void 0;
    var beet = __importStar(require_beet());
    var TokenState;
    (function(TokenState2) {
      TokenState2[TokenState2["Unlocked"] = 0] = "Unlocked";
      TokenState2[TokenState2["Locked"] = 1] = "Locked";
      TokenState2[TokenState2["Listed"] = 2] = "Listed";
    })(TokenState = exports.TokenState || (exports.TokenState = {}));
    exports.tokenStateBeet = beet.fixedScalarEnum(TokenState);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenDelegateRole.js
var require_TokenDelegateRole = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TokenDelegateRole.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenDelegateRoleBeet = exports.TokenDelegateRole = void 0;
    var beet = __importStar(require_beet());
    var TokenDelegateRole;
    (function(TokenDelegateRole2) {
      TokenDelegateRole2[TokenDelegateRole2["Sale"] = 0] = "Sale";
      TokenDelegateRole2[TokenDelegateRole2["Transfer"] = 1] = "Transfer";
      TokenDelegateRole2[TokenDelegateRole2["Utility"] = 2] = "Utility";
      TokenDelegateRole2[TokenDelegateRole2["Staking"] = 3] = "Staking";
      TokenDelegateRole2[TokenDelegateRole2["Standard"] = 4] = "Standard";
      TokenDelegateRole2[TokenDelegateRole2["LockedTransfer"] = 5] = "LockedTransfer";
      TokenDelegateRole2[TokenDelegateRole2["Migration"] = 6] = "Migration";
    })(TokenDelegateRole = exports.TokenDelegateRole || (exports.TokenDelegateRole = {}));
    exports.tokenDelegateRoleBeet = beet.fixedScalarEnum(TokenDelegateRole);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/index.js
var require_custom = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tryReadOption = void 0;
    var beet = __importStar(require_beet());
    var NONE_BYTE_SIZE = beet.coptionNone("").byteSize;
    function tryReadOption(optionBeet, buf, offset) {
      if (buf.subarray(offset).length == 0) {
        return [null, NONE_BYTE_SIZE, true];
      }
      const fixed = optionBeet.toFixedFromData(buf, offset);
      const value = fixed.read(buf, offset);
      return [value, fixed.byteSize, false];
    }
    exports.tryReadOption = tryReadOption;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/token-record-deserializer.js
var require_token_record_deserializer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/custom/token-record-deserializer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var TokenRecord_1 = require_TokenRecord();
    var generated_1 = require_generated();
    var _1 = require_custom();
    function deserialize(buf, offset = 0) {
      let cursor = offset;
      const key = Key_1.keyBeet.read(buf, cursor);
      cursor += Key_1.keyBeet.byteSize;
      const bump = beet.u8.read(buf, cursor);
      cursor += beet.u8.byteSize;
      const state = generated_1.tokenStateBeet.read(buf, cursor);
      cursor += generated_1.tokenStateBeet.byteSize;
      const [ruleSetRevision, ruleSetRevisionDelta] = (0, _1.tryReadOption)(beet.coption(beet.u64), buf, cursor);
      cursor += ruleSetRevisionDelta;
      const [delegate, delegateDelta] = (0, _1.tryReadOption)(beet.coption(beetSolana.publicKey), buf, cursor);
      cursor += delegateDelta;
      const [delegateRole, delegateRoleDelta] = (0, _1.tryReadOption)(beet.coption(generated_1.tokenDelegateRoleBeet), buf, cursor);
      cursor += delegateRoleDelta;
      const [lockedTransfer, lockedTransferDelta, lockedTransferCorrupted] = (0, _1.tryReadOption)(beet.coption(beetSolana.publicKey), buf, cursor);
      cursor += lockedTransferDelta;
      const args = {
        key,
        bump,
        state,
        ruleSetRevision,
        delegate,
        delegateRole,
        lockedTransfer: lockedTransferCorrupted ? null : lockedTransfer
      };
      return [TokenRecord_1.TokenRecord.fromArgs(args), cursor];
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/TokenRecord.js
var require_TokenRecord = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/TokenRecord.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenRecordBeet = exports.TokenRecord = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var TokenState_1 = require_TokenState();
    var TokenDelegateRole_1 = require_TokenDelegateRole();
    var customSerializer = __importStar(require_token_record_deserializer());
    var TokenRecord = class _TokenRecord {
      constructor(key, bump, state, ruleSetRevision, delegate, delegateRole, lockedTransfer) {
        this.key = key;
        this.bump = bump;
        this.state = state;
        this.ruleSetRevision = ruleSetRevision;
        this.delegate = delegate;
        this.delegateRole = delegateRole;
        this.lockedTransfer = lockedTransfer;
      }
      static fromArgs(args) {
        return new _TokenRecord(args.key, args.bump, args.state, args.ruleSetRevision, args.delegate, args.delegateRole, args.lockedTransfer);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _TokenRecord.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find TokenRecord account at ${address}`);
        }
        return _TokenRecord.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.tokenRecordBeet);
      }
      static deserialize(buf, offset = 0) {
        return resolvedDeserialize(buf, offset);
      }
      serialize() {
        return resolvedSerialize(this);
      }
      static byteSize(args) {
        const instance = _TokenRecord.fromArgs(args);
        return exports.tokenRecordBeet.toFixedFromValue(instance).byteSize;
      }
      static async getMinimumBalanceForRentExemption(args, connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_TokenRecord.byteSize(args), commitment);
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          bump: this.bump,
          state: "TokenState." + TokenState_1.TokenState[this.state],
          ruleSetRevision: this.ruleSetRevision,
          delegate: this.delegate,
          delegateRole: this.delegateRole,
          lockedTransfer: this.lockedTransfer
        };
      }
    };
    exports.TokenRecord = TokenRecord;
    exports.tokenRecordBeet = new beet.FixableBeetStruct([
      ["key", Key_1.keyBeet],
      ["bump", beet.u8],
      ["state", TokenState_1.tokenStateBeet],
      ["ruleSetRevision", beet.coption(beet.u64)],
      ["delegate", beet.coption(beetSolana.publicKey)],
      ["delegateRole", beet.coption(TokenDelegateRole_1.tokenDelegateRoleBeet)],
      ["lockedTransfer", beet.coption(beetSolana.publicKey)]
    ], TokenRecord.fromArgs, "TokenRecord");
    var serializer = customSerializer;
    var resolvedSerialize = typeof serializer.serialize === "function" ? serializer.serialize.bind(serializer) : exports.tokenRecordBeet.serialize.bind(exports.tokenRecordBeet);
    var resolvedDeserialize = typeof serializer.deserialize === "function" ? serializer.deserialize.bind(serializer) : exports.tokenRecordBeet.deserialize.bind(exports.tokenRecordBeet);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/UseAuthorityRecord.js
var require_UseAuthorityRecord = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/UseAuthorityRecord.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAuthorityRecordBeet = exports.UseAuthorityRecord = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var beetSolana = __importStar(require_beet_solana());
    var Key_1 = require_Key();
    var UseAuthorityRecord = class _UseAuthorityRecord {
      constructor(key, allowedUses, bump) {
        this.key = key;
        this.allowedUses = allowedUses;
        this.bump = bump;
      }
      static fromArgs(args) {
        return new _UseAuthorityRecord(args.key, args.allowedUses, args.bump);
      }
      static fromAccountInfo(accountInfo, offset = 0) {
        return _UseAuthorityRecord.deserialize(accountInfo.data, offset);
      }
      static async fromAccountAddress(connection, address, commitmentOrConfig) {
        const accountInfo = await connection.getAccountInfo(address, commitmentOrConfig);
        if (accountInfo == null) {
          throw new Error(`Unable to find UseAuthorityRecord account at ${address}`);
        }
        return _UseAuthorityRecord.fromAccountInfo(accountInfo, 0)[0];
      }
      static gpaBuilder(programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
        return beetSolana.GpaBuilder.fromStruct(programId, exports.useAuthorityRecordBeet);
      }
      static deserialize(buf, offset = 0) {
        return exports.useAuthorityRecordBeet.deserialize(buf, offset);
      }
      serialize() {
        return exports.useAuthorityRecordBeet.serialize(this);
      }
      static get byteSize() {
        return exports.useAuthorityRecordBeet.byteSize;
      }
      static async getMinimumBalanceForRentExemption(connection, commitment) {
        return connection.getMinimumBalanceForRentExemption(_UseAuthorityRecord.byteSize, commitment);
      }
      static hasCorrectByteSize(buf, offset = 0) {
        return buf.byteLength - offset === _UseAuthorityRecord.byteSize;
      }
      pretty() {
        return {
          key: "Key." + Key_1.Key[this.key],
          allowedUses: (() => {
            const x = this.allowedUses;
            if (typeof x.toNumber === "function") {
              try {
                return x.toNumber();
              } catch (_) {
                return x;
              }
            }
            return x;
          })(),
          bump: this.bump
        };
      }
    };
    exports.UseAuthorityRecord = UseAuthorityRecord;
    exports.useAuthorityRecordBeet = new beet.BeetStruct([
      ["key", Key_1.keyBeet],
      ["allowedUses", beet.u64],
      ["bump", beet.u8]
    ], UseAuthorityRecord.fromArgs, "UseAuthorityRecord");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/index.js
var require_accounts = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/accounts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountProviders = void 0;
    __exportStar(require_CollectionAuthorityRecord(), exports);
    __exportStar(require_Edition(), exports);
    __exportStar(require_EditionMarker(), exports);
    __exportStar(require_EditionMarkerV2(), exports);
    __exportStar(require_MasterEditionV1(), exports);
    __exportStar(require_MasterEditionV2(), exports);
    __exportStar(require_Metadata(), exports);
    __exportStar(require_MetadataDelegateRecord(), exports);
    __exportStar(require_ReservationListV1(), exports);
    __exportStar(require_ReservationListV2(), exports);
    __exportStar(require_TokenOwnedEscrow(), exports);
    __exportStar(require_TokenRecord(), exports);
    __exportStar(require_UseAuthorityRecord(), exports);
    var CollectionAuthorityRecord_1 = require_CollectionAuthorityRecord();
    var MetadataDelegateRecord_1 = require_MetadataDelegateRecord();
    var Edition_1 = require_Edition();
    var EditionMarker_1 = require_EditionMarker();
    var EditionMarkerV2_1 = require_EditionMarkerV2();
    var TokenOwnedEscrow_1 = require_TokenOwnedEscrow();
    var MasterEditionV2_1 = require_MasterEditionV2();
    var MasterEditionV1_1 = require_MasterEditionV1();
    var Metadata_1 = require_Metadata();
    var TokenRecord_1 = require_TokenRecord();
    var ReservationListV2_1 = require_ReservationListV2();
    var ReservationListV1_1 = require_ReservationListV1();
    var UseAuthorityRecord_1 = require_UseAuthorityRecord();
    exports.accountProviders = {
      CollectionAuthorityRecord: CollectionAuthorityRecord_1.CollectionAuthorityRecord,
      MetadataDelegateRecord: MetadataDelegateRecord_1.MetadataDelegateRecord,
      Edition: Edition_1.Edition,
      EditionMarker: EditionMarker_1.EditionMarker,
      EditionMarkerV2: EditionMarkerV2_1.EditionMarkerV2,
      TokenOwnedEscrow: TokenOwnedEscrow_1.TokenOwnedEscrow,
      MasterEditionV2: MasterEditionV2_1.MasterEditionV2,
      MasterEditionV1: MasterEditionV1_1.MasterEditionV1,
      Metadata: Metadata_1.Metadata,
      TokenRecord: TokenRecord_1.TokenRecord,
      ReservationListV2: ReservationListV2_1.ReservationListV2,
      ReservationListV1: ReservationListV1_1.ReservationListV1,
      UseAuthorityRecord: UseAuthorityRecord_1.UseAuthorityRecord
    };
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/errors/index.js
var require_errors = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/errors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReservationAlreadyMadeError = exports.ReservationNotSetError = exports.ReservationDoesNotExistError = exports.ReservationExistsError = exports.ShareTotalMustBe100Error = exports.NoBalanceInAccountForAuthorizationError = exports.OwnerMismatchError = exports.PrimarySaleCanOnlyBeFlippedToTrueError = exports.InvalidBasisPointsError = exports.CreatorNotFoundError = exports.NoCreatorsPresentOnMetadataError = exports.MustBeOneOfCreatorsError = exports.CreatorsMustBeAtleastOneError = exports.CreatorsTooLongError = exports.DisabledError = exports.AuthorizationTokenAccountOwnerMismatchError = exports.PrintingMintAuthorizationAccountMismatchError = exports.NotEnoughTokensError = exports.TokenAccountMintMismatchV2Error = exports.TokenAccountMintMismatchError = exports.OneTimePrintingAuthMintMismatchError = exports.PrintingMintMismatchError = exports.DerivedKeyInvalidError = exports.TokenAccountOneTimeAuthMintMismatchError = exports.TokenBurnFailedError = exports.EditionMintDecimalsShouldBeZeroError = exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = exports.PrintingMintDecimalsShouldBeZeroError = exports.EditionAlreadyMintedError = exports.DestinationMintMismatchError = exports.MasterRecordMismatchError = exports.TokenMintToFailedError = exports.MaxEditionsMintedAlreadyError = exports.EditionsMustHaveExactlyOneTokenError = exports.MintMismatchError = exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = exports.UriTooLongError = exports.SymbolTooLongError = exports.NameTooLongError = exports.InvalidMintAuthorityError = exports.NotMintAuthorityError = exports.UpdateAuthorityIsNotSignerError = exports.UpdateAuthorityIncorrectError = exports.InvalidEditionKeyError = exports.InvalidMetadataKeyError = exports.UninitializedError = exports.AlreadyInitializedError = exports.NotRentExemptError = exports.InstructionPackErrorError = exports.InstructionUnpackErrorError = void 0;
    exports.RevokeCollectionAuthoritySignerIncorrectError = exports.InvalidUserError = exports.EditionOverrideCannotBeZeroError = exports.NotAllowedToChangeSellerFeeBasisPointsError = exports.CannotWipeVerifiedCreatorsError = exports.CannotRemoveVerifiedCreatorError = exports.CannotAdjustVerifiedCreatorError = exports.InvalidDelegateError = exports.InvalidFreezeAuthorityError = exports.InvalidCollectionAuthorityRecordError = exports.InvalidUseAuthorityRecordError = exports.CollectionAuthorityDoesNotExistError = exports.CollectionAuthorityRecordAlreadyExistsError = exports.NotEnoughUsesError = exports.UnusableError = exports.UseAuthorityRecordAlreadyRevokedError = exports.UseAuthorityRecordAlreadyExistsError = exports.CollectionMustBeAUniqueMasterEditionError = exports.InvalidCollectionUpdateAuthorityError = exports.CollectionNotFoundError = exports.CannotChangeUsesAfterFirstUseError = exports.CannotChangeUseMethodAfterFirstUseError = exports.InvalidUseMethodError = exports.MustBeBurnedError = exports.RemovedError = exports.CollectionCannotBeVerifiedInThisInstructionError = exports.IsMutableCanOnlyBeFlippedToFalseError = exports.ReservationArrayShouldBeSizeOneError = exports.InvalidEditionIndexError = exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = exports.PrintingMintSupplyMustBeZeroForConversionError = exports.InvalidOwnerError = exports.InvalidOperationError = exports.TriedToReplaceAnExistingReservationError = exports.ReservationNotCompleteError = exports.BeyondAlottedAddressSizeError = exports.DataTypeMismatchError = exports.InvalidTokenProgramError = exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = exports.DuplicateCreatorAddressError = exports.DataIsImmutableError = exports.PrintingWouldBreachMaximumSupplyError = exports.IncorrectOwnerError = exports.SpotMismatchError = exports.CannotUnverifyAnotherCreatorError = exports.CannotVerifyAnotherCreatorError = exports.AddressNotInReservationError = exports.ReservationBreachesMaximumSupplyError = exports.NumericalOverflowErrorError = exports.BeyondMaxAddressSizeError = void 0;
    exports.MissingSplTokenProgramError = exports.MissingTokenAccountError = exports.OnlySaleDelegateCanTransferError = exports.InvalidSystemWalletError = exports.FeatureNotSupportedError = exports.MissingArgumentInBuilderError = exports.MissingAccountInBuilderError = exports.DelegateNotFoundError = exports.DelegateAlreadyExistsError = exports.InvalidProgrammableConfigError = exports.MissingProgrammableConfigError = exports.MissingAuthorizationRulesError = exports.InvalidAuthorizationRulesError = exports.InvalidMintForTokenStandardError = exports.InvalidTokenStandardError = exports.MintIsNotSignerError = exports.EscrowParentHasDelegateError = exports.InvalidBubblegumSignerError = exports.InvalidCollectionSizeChangeError = exports.NoFreezeAuthoritySetError = exports.BorshSerializationErrorError = exports.InsufficientTokensError = exports.MustBeNonFungibleError = exports.InvalidSystemProgramError = exports.MustBeEscrowAuthorityError = exports.InvalidEscrowBumpSeedError = exports.MustUnverifyError = exports.EditionNumberGreaterThanMaxSupplyError = exports.PrintEditionDoesNotMatchMasterEditionError = exports.ReservationListDeprecatedError = exports.InvalidEditionMarkerError = exports.InvalidPrintEditionError = exports.InvalidMasterEditionError = exports.NotAPrintEditionError = exports.AlreadyUnverifiedError = exports.AlreadyVerifiedError = exports.CollectionMasterEditionAccountInvalidError = exports.CannotUpdateVerifiedCollectionError = exports.BorshDeserializationErrorError = exports.MasterEditionHasPrintsError = exports.NotAMasterEditionError = exports.MissingEditionAccountError = exports.CouldNotDetermineTokenStandardError = exports.NotACollectionParentError = exports.NotVerifiedMemberOfCollectionError = exports.NotAMemberOfCollectionError = exports.MissingCollectionMetadataError = exports.SizedCollectionError = exports.UnsizedCollectionError = exports.TokenCloseFailedError = void 0;
    exports.errorFromName = exports.errorFromCode = exports.InvalidMetadataFlagsError = exports.InvalidFeeAccountError = exports.MissingDelegateRecordError = exports.InvalidInstructionError = exports.InvalidCloseAuthorityError = exports.InvalidTokenRecordError = exports.MissingCollectionMasterEditionError = exports.MissingCollectionMintError = exports.InsufficientTokenBalanceError = exports.InvalidUpdateArgsError = exports.InvalidParentAccountsError = exports.InvalidInstructionsSysvarError = exports.InvalidAssociatedTokenAccountProgramError = exports.MissingEditionError = exports.CannotBurnWithDelegateError = exports.MissingEditionMarkerAccountError = exports.MissingMasterEditionTokenAccountError = exports.MissingMasterEditionMintAccountError = exports.InvalidAmountError = exports.CannotUpdateAssetWithDelegateError = exports.DataIncrementLimitExceededError = exports.InvalidLockedTransferAddressError = exports.MissingLockedTransferAddressError = exports.InvalidDelegateArgsError = exports.AmountMustBeGreaterThanZeroError = exports.MissingMasterEditionAccountError = exports.MissingPrintSupplyError = exports.InvalidDelegateRoleError = exports.IncorrectTokenStateError = exports.InvalidMasterEditionAccountLengthError = exports.MissingTokenOwnerAccountError = exports.DataIsEmptyOrZeroedError = exports.MintSupplyMustBeZeroError = exports.MissingTokenRecordError = exports.InvalidAuthorityTypeError = exports.MissingDelegateRoleError = exports.UnlockedTokenError = exports.LockedTokenError = exports.KeyMismatchError = exports.InstructionNotSupportedError = exports.InvalidTransferAuthorityError = exports.InvalidDelegateRoleForTransferError = exports.MissingAuthorizationRulesProgramError = void 0;
    var createErrorFromCodeLookup = /* @__PURE__ */ new Map();
    var createErrorFromNameLookup = /* @__PURE__ */ new Map();
    var InstructionUnpackErrorError = class _InstructionUnpackErrorError extends Error {
      constructor() {
        super("");
        this.code = 0;
        this.name = "InstructionUnpackError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InstructionUnpackErrorError);
        }
      }
    };
    exports.InstructionUnpackErrorError = InstructionUnpackErrorError;
    createErrorFromCodeLookup.set(0, () => new InstructionUnpackErrorError());
    createErrorFromNameLookup.set("InstructionUnpackError", () => new InstructionUnpackErrorError());
    var InstructionPackErrorError = class _InstructionPackErrorError extends Error {
      constructor() {
        super("");
        this.code = 1;
        this.name = "InstructionPackError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InstructionPackErrorError);
        }
      }
    };
    exports.InstructionPackErrorError = InstructionPackErrorError;
    createErrorFromCodeLookup.set(1, () => new InstructionPackErrorError());
    createErrorFromNameLookup.set("InstructionPackError", () => new InstructionPackErrorError());
    var NotRentExemptError = class _NotRentExemptError extends Error {
      constructor() {
        super("Lamport balance below rent-exempt threshold");
        this.code = 2;
        this.name = "NotRentExempt";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotRentExemptError);
        }
      }
    };
    exports.NotRentExemptError = NotRentExemptError;
    createErrorFromCodeLookup.set(2, () => new NotRentExemptError());
    createErrorFromNameLookup.set("NotRentExempt", () => new NotRentExemptError());
    var AlreadyInitializedError = class _AlreadyInitializedError extends Error {
      constructor() {
        super("Already initialized");
        this.code = 3;
        this.name = "AlreadyInitialized";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AlreadyInitializedError);
        }
      }
    };
    exports.AlreadyInitializedError = AlreadyInitializedError;
    createErrorFromCodeLookup.set(3, () => new AlreadyInitializedError());
    createErrorFromNameLookup.set("AlreadyInitialized", () => new AlreadyInitializedError());
    var UninitializedError = class _UninitializedError extends Error {
      constructor() {
        super("Uninitialized");
        this.code = 4;
        this.name = "Uninitialized";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UninitializedError);
        }
      }
    };
    exports.UninitializedError = UninitializedError;
    createErrorFromCodeLookup.set(4, () => new UninitializedError());
    createErrorFromNameLookup.set("Uninitialized", () => new UninitializedError());
    var InvalidMetadataKeyError = class _InvalidMetadataKeyError extends Error {
      constructor() {
        super(" Metadata's key must match seed of ['metadata', program id, mint] provided");
        this.code = 5;
        this.name = "InvalidMetadataKey";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMetadataKeyError);
        }
      }
    };
    exports.InvalidMetadataKeyError = InvalidMetadataKeyError;
    createErrorFromCodeLookup.set(5, () => new InvalidMetadataKeyError());
    createErrorFromNameLookup.set("InvalidMetadataKey", () => new InvalidMetadataKeyError());
    var InvalidEditionKeyError = class _InvalidEditionKeyError extends Error {
      constructor() {
        super("Edition's key must match seed of ['metadata', program id, name, 'edition'] provided");
        this.code = 6;
        this.name = "InvalidEditionKey";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidEditionKeyError);
        }
      }
    };
    exports.InvalidEditionKeyError = InvalidEditionKeyError;
    createErrorFromCodeLookup.set(6, () => new InvalidEditionKeyError());
    createErrorFromNameLookup.set("InvalidEditionKey", () => new InvalidEditionKeyError());
    var UpdateAuthorityIncorrectError = class _UpdateAuthorityIncorrectError extends Error {
      constructor() {
        super("Update Authority given does not match");
        this.code = 7;
        this.name = "UpdateAuthorityIncorrect";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UpdateAuthorityIncorrectError);
        }
      }
    };
    exports.UpdateAuthorityIncorrectError = UpdateAuthorityIncorrectError;
    createErrorFromCodeLookup.set(7, () => new UpdateAuthorityIncorrectError());
    createErrorFromNameLookup.set("UpdateAuthorityIncorrect", () => new UpdateAuthorityIncorrectError());
    var UpdateAuthorityIsNotSignerError = class _UpdateAuthorityIsNotSignerError extends Error {
      constructor() {
        super("Update Authority needs to be signer to update metadata");
        this.code = 8;
        this.name = "UpdateAuthorityIsNotSigner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UpdateAuthorityIsNotSignerError);
        }
      }
    };
    exports.UpdateAuthorityIsNotSignerError = UpdateAuthorityIsNotSignerError;
    createErrorFromCodeLookup.set(8, () => new UpdateAuthorityIsNotSignerError());
    createErrorFromNameLookup.set("UpdateAuthorityIsNotSigner", () => new UpdateAuthorityIsNotSignerError());
    var NotMintAuthorityError = class _NotMintAuthorityError extends Error {
      constructor() {
        super("You must be the mint authority and signer on this transaction");
        this.code = 9;
        this.name = "NotMintAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotMintAuthorityError);
        }
      }
    };
    exports.NotMintAuthorityError = NotMintAuthorityError;
    createErrorFromCodeLookup.set(9, () => new NotMintAuthorityError());
    createErrorFromNameLookup.set("NotMintAuthority", () => new NotMintAuthorityError());
    var InvalidMintAuthorityError = class _InvalidMintAuthorityError extends Error {
      constructor() {
        super("Mint authority provided does not match the authority on the mint");
        this.code = 10;
        this.name = "InvalidMintAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMintAuthorityError);
        }
      }
    };
    exports.InvalidMintAuthorityError = InvalidMintAuthorityError;
    createErrorFromCodeLookup.set(10, () => new InvalidMintAuthorityError());
    createErrorFromNameLookup.set("InvalidMintAuthority", () => new InvalidMintAuthorityError());
    var NameTooLongError = class _NameTooLongError extends Error {
      constructor() {
        super("Name too long");
        this.code = 11;
        this.name = "NameTooLong";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NameTooLongError);
        }
      }
    };
    exports.NameTooLongError = NameTooLongError;
    createErrorFromCodeLookup.set(11, () => new NameTooLongError());
    createErrorFromNameLookup.set("NameTooLong", () => new NameTooLongError());
    var SymbolTooLongError = class _SymbolTooLongError extends Error {
      constructor() {
        super("Symbol too long");
        this.code = 12;
        this.name = "SymbolTooLong";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _SymbolTooLongError);
        }
      }
    };
    exports.SymbolTooLongError = SymbolTooLongError;
    createErrorFromCodeLookup.set(12, () => new SymbolTooLongError());
    createErrorFromNameLookup.set("SymbolTooLong", () => new SymbolTooLongError());
    var UriTooLongError = class _UriTooLongError extends Error {
      constructor() {
        super("URI too long");
        this.code = 13;
        this.name = "UriTooLong";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UriTooLongError);
        }
      }
    };
    exports.UriTooLongError = UriTooLongError;
    createErrorFromCodeLookup.set(13, () => new UriTooLongError());
    createErrorFromNameLookup.set("UriTooLong", () => new UriTooLongError());
    var UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = class _UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError extends Error {
      constructor() {
        super("");
        this.code = 14;
        this.name = "UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError);
        }
      }
    };
    exports.UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError = UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError;
    createErrorFromCodeLookup.set(14, () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError());
    createErrorFromNameLookup.set("UpdateAuthorityMustBeEqualToMetadataAuthorityAndSigner", () => new UpdateAuthorityMustBeEqualToMetadataAuthorityAndSignerError());
    var MintMismatchError = class _MintMismatchError extends Error {
      constructor() {
        super("Mint given does not match mint on Metadata");
        this.code = 15;
        this.name = "MintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MintMismatchError);
        }
      }
    };
    exports.MintMismatchError = MintMismatchError;
    createErrorFromCodeLookup.set(15, () => new MintMismatchError());
    createErrorFromNameLookup.set("MintMismatch", () => new MintMismatchError());
    var EditionsMustHaveExactlyOneTokenError = class _EditionsMustHaveExactlyOneTokenError extends Error {
      constructor() {
        super("Editions must have exactly one token");
        this.code = 16;
        this.name = "EditionsMustHaveExactlyOneToken";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EditionsMustHaveExactlyOneTokenError);
        }
      }
    };
    exports.EditionsMustHaveExactlyOneTokenError = EditionsMustHaveExactlyOneTokenError;
    createErrorFromCodeLookup.set(16, () => new EditionsMustHaveExactlyOneTokenError());
    createErrorFromNameLookup.set("EditionsMustHaveExactlyOneToken", () => new EditionsMustHaveExactlyOneTokenError());
    var MaxEditionsMintedAlreadyError = class _MaxEditionsMintedAlreadyError extends Error {
      constructor() {
        super("");
        this.code = 17;
        this.name = "MaxEditionsMintedAlready";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MaxEditionsMintedAlreadyError);
        }
      }
    };
    exports.MaxEditionsMintedAlreadyError = MaxEditionsMintedAlreadyError;
    createErrorFromCodeLookup.set(17, () => new MaxEditionsMintedAlreadyError());
    createErrorFromNameLookup.set("MaxEditionsMintedAlready", () => new MaxEditionsMintedAlreadyError());
    var TokenMintToFailedError = class _TokenMintToFailedError extends Error {
      constructor() {
        super("");
        this.code = 18;
        this.name = "TokenMintToFailed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenMintToFailedError);
        }
      }
    };
    exports.TokenMintToFailedError = TokenMintToFailedError;
    createErrorFromCodeLookup.set(18, () => new TokenMintToFailedError());
    createErrorFromNameLookup.set("TokenMintToFailed", () => new TokenMintToFailedError());
    var MasterRecordMismatchError = class _MasterRecordMismatchError extends Error {
      constructor() {
        super("");
        this.code = 19;
        this.name = "MasterRecordMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MasterRecordMismatchError);
        }
      }
    };
    exports.MasterRecordMismatchError = MasterRecordMismatchError;
    createErrorFromCodeLookup.set(19, () => new MasterRecordMismatchError());
    createErrorFromNameLookup.set("MasterRecordMismatch", () => new MasterRecordMismatchError());
    var DestinationMintMismatchError = class _DestinationMintMismatchError extends Error {
      constructor() {
        super("");
        this.code = 20;
        this.name = "DestinationMintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DestinationMintMismatchError);
        }
      }
    };
    exports.DestinationMintMismatchError = DestinationMintMismatchError;
    createErrorFromCodeLookup.set(20, () => new DestinationMintMismatchError());
    createErrorFromNameLookup.set("DestinationMintMismatch", () => new DestinationMintMismatchError());
    var EditionAlreadyMintedError = class _EditionAlreadyMintedError extends Error {
      constructor() {
        super("");
        this.code = 21;
        this.name = "EditionAlreadyMinted";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EditionAlreadyMintedError);
        }
      }
    };
    exports.EditionAlreadyMintedError = EditionAlreadyMintedError;
    createErrorFromCodeLookup.set(21, () => new EditionAlreadyMintedError());
    createErrorFromNameLookup.set("EditionAlreadyMinted", () => new EditionAlreadyMintedError());
    var PrintingMintDecimalsShouldBeZeroError = class _PrintingMintDecimalsShouldBeZeroError extends Error {
      constructor() {
        super("");
        this.code = 22;
        this.name = "PrintingMintDecimalsShouldBeZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintingMintDecimalsShouldBeZeroError);
        }
      }
    };
    exports.PrintingMintDecimalsShouldBeZeroError = PrintingMintDecimalsShouldBeZeroError;
    createErrorFromCodeLookup.set(22, () => new PrintingMintDecimalsShouldBeZeroError());
    createErrorFromNameLookup.set("PrintingMintDecimalsShouldBeZero", () => new PrintingMintDecimalsShouldBeZeroError());
    var OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = class _OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError extends Error {
      constructor() {
        super("");
        this.code = 23;
        this.name = "OneTimePrintingAuthorizationMintDecimalsShouldBeZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError);
        }
      }
    };
    exports.OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError = OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError;
    createErrorFromCodeLookup.set(23, () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError());
    createErrorFromNameLookup.set("OneTimePrintingAuthorizationMintDecimalsShouldBeZero", () => new OneTimePrintingAuthorizationMintDecimalsShouldBeZeroError());
    var EditionMintDecimalsShouldBeZeroError = class _EditionMintDecimalsShouldBeZeroError extends Error {
      constructor() {
        super("EditionMintDecimalsShouldBeZero");
        this.code = 24;
        this.name = "EditionMintDecimalsShouldBeZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EditionMintDecimalsShouldBeZeroError);
        }
      }
    };
    exports.EditionMintDecimalsShouldBeZeroError = EditionMintDecimalsShouldBeZeroError;
    createErrorFromCodeLookup.set(24, () => new EditionMintDecimalsShouldBeZeroError());
    createErrorFromNameLookup.set("EditionMintDecimalsShouldBeZero", () => new EditionMintDecimalsShouldBeZeroError());
    var TokenBurnFailedError = class _TokenBurnFailedError extends Error {
      constructor() {
        super("");
        this.code = 25;
        this.name = "TokenBurnFailed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenBurnFailedError);
        }
      }
    };
    exports.TokenBurnFailedError = TokenBurnFailedError;
    createErrorFromCodeLookup.set(25, () => new TokenBurnFailedError());
    createErrorFromNameLookup.set("TokenBurnFailed", () => new TokenBurnFailedError());
    var TokenAccountOneTimeAuthMintMismatchError = class _TokenAccountOneTimeAuthMintMismatchError extends Error {
      constructor() {
        super("");
        this.code = 26;
        this.name = "TokenAccountOneTimeAuthMintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenAccountOneTimeAuthMintMismatchError);
        }
      }
    };
    exports.TokenAccountOneTimeAuthMintMismatchError = TokenAccountOneTimeAuthMintMismatchError;
    createErrorFromCodeLookup.set(26, () => new TokenAccountOneTimeAuthMintMismatchError());
    createErrorFromNameLookup.set("TokenAccountOneTimeAuthMintMismatch", () => new TokenAccountOneTimeAuthMintMismatchError());
    var DerivedKeyInvalidError = class _DerivedKeyInvalidError extends Error {
      constructor() {
        super("Derived key invalid");
        this.code = 27;
        this.name = "DerivedKeyInvalid";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DerivedKeyInvalidError);
        }
      }
    };
    exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
    createErrorFromCodeLookup.set(27, () => new DerivedKeyInvalidError());
    createErrorFromNameLookup.set("DerivedKeyInvalid", () => new DerivedKeyInvalidError());
    var PrintingMintMismatchError = class _PrintingMintMismatchError extends Error {
      constructor() {
        super("The Printing mint does not match that on the master edition!");
        this.code = 28;
        this.name = "PrintingMintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintingMintMismatchError);
        }
      }
    };
    exports.PrintingMintMismatchError = PrintingMintMismatchError;
    createErrorFromCodeLookup.set(28, () => new PrintingMintMismatchError());
    createErrorFromNameLookup.set("PrintingMintMismatch", () => new PrintingMintMismatchError());
    var OneTimePrintingAuthMintMismatchError = class _OneTimePrintingAuthMintMismatchError extends Error {
      constructor() {
        super("The One Time Printing Auth mint does not match that on the master edition!");
        this.code = 29;
        this.name = "OneTimePrintingAuthMintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _OneTimePrintingAuthMintMismatchError);
        }
      }
    };
    exports.OneTimePrintingAuthMintMismatchError = OneTimePrintingAuthMintMismatchError;
    createErrorFromCodeLookup.set(29, () => new OneTimePrintingAuthMintMismatchError());
    createErrorFromNameLookup.set("OneTimePrintingAuthMintMismatch", () => new OneTimePrintingAuthMintMismatchError());
    var TokenAccountMintMismatchError = class _TokenAccountMintMismatchError extends Error {
      constructor() {
        super("The mint of the token account does not match the Printing mint!");
        this.code = 30;
        this.name = "TokenAccountMintMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenAccountMintMismatchError);
        }
      }
    };
    exports.TokenAccountMintMismatchError = TokenAccountMintMismatchError;
    createErrorFromCodeLookup.set(30, () => new TokenAccountMintMismatchError());
    createErrorFromNameLookup.set("TokenAccountMintMismatch", () => new TokenAccountMintMismatchError());
    var TokenAccountMintMismatchV2Error = class _TokenAccountMintMismatchV2Error extends Error {
      constructor() {
        super("The mint of the token account does not match the master metadata mint!");
        this.code = 31;
        this.name = "TokenAccountMintMismatchV2";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenAccountMintMismatchV2Error);
        }
      }
    };
    exports.TokenAccountMintMismatchV2Error = TokenAccountMintMismatchV2Error;
    createErrorFromCodeLookup.set(31, () => new TokenAccountMintMismatchV2Error());
    createErrorFromNameLookup.set("TokenAccountMintMismatchV2", () => new TokenAccountMintMismatchV2Error());
    var NotEnoughTokensError = class _NotEnoughTokensError extends Error {
      constructor() {
        super("Not enough tokens to mint a limited edition");
        this.code = 32;
        this.name = "NotEnoughTokens";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotEnoughTokensError);
        }
      }
    };
    exports.NotEnoughTokensError = NotEnoughTokensError;
    createErrorFromCodeLookup.set(32, () => new NotEnoughTokensError());
    createErrorFromNameLookup.set("NotEnoughTokens", () => new NotEnoughTokensError());
    var PrintingMintAuthorizationAccountMismatchError = class _PrintingMintAuthorizationAccountMismatchError extends Error {
      constructor() {
        super("");
        this.code = 33;
        this.name = "PrintingMintAuthorizationAccountMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintingMintAuthorizationAccountMismatchError);
        }
      }
    };
    exports.PrintingMintAuthorizationAccountMismatchError = PrintingMintAuthorizationAccountMismatchError;
    createErrorFromCodeLookup.set(33, () => new PrintingMintAuthorizationAccountMismatchError());
    createErrorFromNameLookup.set("PrintingMintAuthorizationAccountMismatch", () => new PrintingMintAuthorizationAccountMismatchError());
    var AuthorizationTokenAccountOwnerMismatchError = class _AuthorizationTokenAccountOwnerMismatchError extends Error {
      constructor() {
        super("");
        this.code = 34;
        this.name = "AuthorizationTokenAccountOwnerMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AuthorizationTokenAccountOwnerMismatchError);
        }
      }
    };
    exports.AuthorizationTokenAccountOwnerMismatchError = AuthorizationTokenAccountOwnerMismatchError;
    createErrorFromCodeLookup.set(34, () => new AuthorizationTokenAccountOwnerMismatchError());
    createErrorFromNameLookup.set("AuthorizationTokenAccountOwnerMismatch", () => new AuthorizationTokenAccountOwnerMismatchError());
    var DisabledError = class _DisabledError extends Error {
      constructor() {
        super("");
        this.code = 35;
        this.name = "Disabled";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DisabledError);
        }
      }
    };
    exports.DisabledError = DisabledError;
    createErrorFromCodeLookup.set(35, () => new DisabledError());
    createErrorFromNameLookup.set("Disabled", () => new DisabledError());
    var CreatorsTooLongError = class _CreatorsTooLongError extends Error {
      constructor() {
        super("Creators list too long");
        this.code = 36;
        this.name = "CreatorsTooLong";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CreatorsTooLongError);
        }
      }
    };
    exports.CreatorsTooLongError = CreatorsTooLongError;
    createErrorFromCodeLookup.set(36, () => new CreatorsTooLongError());
    createErrorFromNameLookup.set("CreatorsTooLong", () => new CreatorsTooLongError());
    var CreatorsMustBeAtleastOneError = class _CreatorsMustBeAtleastOneError extends Error {
      constructor() {
        super("Creators must be at least one if set");
        this.code = 37;
        this.name = "CreatorsMustBeAtleastOne";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CreatorsMustBeAtleastOneError);
        }
      }
    };
    exports.CreatorsMustBeAtleastOneError = CreatorsMustBeAtleastOneError;
    createErrorFromCodeLookup.set(37, () => new CreatorsMustBeAtleastOneError());
    createErrorFromNameLookup.set("CreatorsMustBeAtleastOne", () => new CreatorsMustBeAtleastOneError());
    var MustBeOneOfCreatorsError = class _MustBeOneOfCreatorsError extends Error {
      constructor() {
        super("");
        this.code = 38;
        this.name = "MustBeOneOfCreators";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MustBeOneOfCreatorsError);
        }
      }
    };
    exports.MustBeOneOfCreatorsError = MustBeOneOfCreatorsError;
    createErrorFromCodeLookup.set(38, () => new MustBeOneOfCreatorsError());
    createErrorFromNameLookup.set("MustBeOneOfCreators", () => new MustBeOneOfCreatorsError());
    var NoCreatorsPresentOnMetadataError = class _NoCreatorsPresentOnMetadataError extends Error {
      constructor() {
        super("This metadata does not have creators");
        this.code = 39;
        this.name = "NoCreatorsPresentOnMetadata";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NoCreatorsPresentOnMetadataError);
        }
      }
    };
    exports.NoCreatorsPresentOnMetadataError = NoCreatorsPresentOnMetadataError;
    createErrorFromCodeLookup.set(39, () => new NoCreatorsPresentOnMetadataError());
    createErrorFromNameLookup.set("NoCreatorsPresentOnMetadata", () => new NoCreatorsPresentOnMetadataError());
    var CreatorNotFoundError = class _CreatorNotFoundError extends Error {
      constructor() {
        super("This creator address was not found");
        this.code = 40;
        this.name = "CreatorNotFound";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CreatorNotFoundError);
        }
      }
    };
    exports.CreatorNotFoundError = CreatorNotFoundError;
    createErrorFromCodeLookup.set(40, () => new CreatorNotFoundError());
    createErrorFromNameLookup.set("CreatorNotFound", () => new CreatorNotFoundError());
    var InvalidBasisPointsError = class _InvalidBasisPointsError extends Error {
      constructor() {
        super("Basis points cannot be more than 10000");
        this.code = 41;
        this.name = "InvalidBasisPoints";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidBasisPointsError);
        }
      }
    };
    exports.InvalidBasisPointsError = InvalidBasisPointsError;
    createErrorFromCodeLookup.set(41, () => new InvalidBasisPointsError());
    createErrorFromNameLookup.set("InvalidBasisPoints", () => new InvalidBasisPointsError());
    var PrimarySaleCanOnlyBeFlippedToTrueError = class _PrimarySaleCanOnlyBeFlippedToTrueError extends Error {
      constructor() {
        super("Primary sale can only be flipped to true and is immutable");
        this.code = 42;
        this.name = "PrimarySaleCanOnlyBeFlippedToTrue";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrimarySaleCanOnlyBeFlippedToTrueError);
        }
      }
    };
    exports.PrimarySaleCanOnlyBeFlippedToTrueError = PrimarySaleCanOnlyBeFlippedToTrueError;
    createErrorFromCodeLookup.set(42, () => new PrimarySaleCanOnlyBeFlippedToTrueError());
    createErrorFromNameLookup.set("PrimarySaleCanOnlyBeFlippedToTrue", () => new PrimarySaleCanOnlyBeFlippedToTrueError());
    var OwnerMismatchError = class _OwnerMismatchError extends Error {
      constructor() {
        super("Owner does not match that on the account given");
        this.code = 43;
        this.name = "OwnerMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _OwnerMismatchError);
        }
      }
    };
    exports.OwnerMismatchError = OwnerMismatchError;
    createErrorFromCodeLookup.set(43, () => new OwnerMismatchError());
    createErrorFromNameLookup.set("OwnerMismatch", () => new OwnerMismatchError());
    var NoBalanceInAccountForAuthorizationError = class _NoBalanceInAccountForAuthorizationError extends Error {
      constructor() {
        super("This account has no tokens to be used for authorization");
        this.code = 44;
        this.name = "NoBalanceInAccountForAuthorization";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NoBalanceInAccountForAuthorizationError);
        }
      }
    };
    exports.NoBalanceInAccountForAuthorizationError = NoBalanceInAccountForAuthorizationError;
    createErrorFromCodeLookup.set(44, () => new NoBalanceInAccountForAuthorizationError());
    createErrorFromNameLookup.set("NoBalanceInAccountForAuthorization", () => new NoBalanceInAccountForAuthorizationError());
    var ShareTotalMustBe100Error = class _ShareTotalMustBe100Error extends Error {
      constructor() {
        super("Share total must equal 100 for creator array");
        this.code = 45;
        this.name = "ShareTotalMustBe100";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ShareTotalMustBe100Error);
        }
      }
    };
    exports.ShareTotalMustBe100Error = ShareTotalMustBe100Error;
    createErrorFromCodeLookup.set(45, () => new ShareTotalMustBe100Error());
    createErrorFromNameLookup.set("ShareTotalMustBe100", () => new ShareTotalMustBe100Error());
    var ReservationExistsError = class _ReservationExistsError extends Error {
      constructor() {
        super("");
        this.code = 46;
        this.name = "ReservationExists";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationExistsError);
        }
      }
    };
    exports.ReservationExistsError = ReservationExistsError;
    createErrorFromCodeLookup.set(46, () => new ReservationExistsError());
    createErrorFromNameLookup.set("ReservationExists", () => new ReservationExistsError());
    var ReservationDoesNotExistError = class _ReservationDoesNotExistError extends Error {
      constructor() {
        super("");
        this.code = 47;
        this.name = "ReservationDoesNotExist";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationDoesNotExistError);
        }
      }
    };
    exports.ReservationDoesNotExistError = ReservationDoesNotExistError;
    createErrorFromCodeLookup.set(47, () => new ReservationDoesNotExistError());
    createErrorFromNameLookup.set("ReservationDoesNotExist", () => new ReservationDoesNotExistError());
    var ReservationNotSetError = class _ReservationNotSetError extends Error {
      constructor() {
        super("");
        this.code = 48;
        this.name = "ReservationNotSet";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationNotSetError);
        }
      }
    };
    exports.ReservationNotSetError = ReservationNotSetError;
    createErrorFromCodeLookup.set(48, () => new ReservationNotSetError());
    createErrorFromNameLookup.set("ReservationNotSet", () => new ReservationNotSetError());
    var ReservationAlreadyMadeError = class _ReservationAlreadyMadeError extends Error {
      constructor() {
        super("");
        this.code = 49;
        this.name = "ReservationAlreadyMade";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationAlreadyMadeError);
        }
      }
    };
    exports.ReservationAlreadyMadeError = ReservationAlreadyMadeError;
    createErrorFromCodeLookup.set(49, () => new ReservationAlreadyMadeError());
    createErrorFromNameLookup.set("ReservationAlreadyMade", () => new ReservationAlreadyMadeError());
    var BeyondMaxAddressSizeError = class _BeyondMaxAddressSizeError extends Error {
      constructor() {
        super("");
        this.code = 50;
        this.name = "BeyondMaxAddressSize";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _BeyondMaxAddressSizeError);
        }
      }
    };
    exports.BeyondMaxAddressSizeError = BeyondMaxAddressSizeError;
    createErrorFromCodeLookup.set(50, () => new BeyondMaxAddressSizeError());
    createErrorFromNameLookup.set("BeyondMaxAddressSize", () => new BeyondMaxAddressSizeError());
    var NumericalOverflowErrorError = class _NumericalOverflowErrorError extends Error {
      constructor() {
        super("NumericalOverflowError");
        this.code = 51;
        this.name = "NumericalOverflowError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NumericalOverflowErrorError);
        }
      }
    };
    exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
    createErrorFromCodeLookup.set(51, () => new NumericalOverflowErrorError());
    createErrorFromNameLookup.set("NumericalOverflowError", () => new NumericalOverflowErrorError());
    var ReservationBreachesMaximumSupplyError = class _ReservationBreachesMaximumSupplyError extends Error {
      constructor() {
        super("");
        this.code = 52;
        this.name = "ReservationBreachesMaximumSupply";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationBreachesMaximumSupplyError);
        }
      }
    };
    exports.ReservationBreachesMaximumSupplyError = ReservationBreachesMaximumSupplyError;
    createErrorFromCodeLookup.set(52, () => new ReservationBreachesMaximumSupplyError());
    createErrorFromNameLookup.set("ReservationBreachesMaximumSupply", () => new ReservationBreachesMaximumSupplyError());
    var AddressNotInReservationError = class _AddressNotInReservationError extends Error {
      constructor() {
        super("");
        this.code = 53;
        this.name = "AddressNotInReservation";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AddressNotInReservationError);
        }
      }
    };
    exports.AddressNotInReservationError = AddressNotInReservationError;
    createErrorFromCodeLookup.set(53, () => new AddressNotInReservationError());
    createErrorFromNameLookup.set("AddressNotInReservation", () => new AddressNotInReservationError());
    var CannotVerifyAnotherCreatorError = class _CannotVerifyAnotherCreatorError extends Error {
      constructor() {
        super("You cannot unilaterally verify another creator, they must sign");
        this.code = 54;
        this.name = "CannotVerifyAnotherCreator";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotVerifyAnotherCreatorError);
        }
      }
    };
    exports.CannotVerifyAnotherCreatorError = CannotVerifyAnotherCreatorError;
    createErrorFromCodeLookup.set(54, () => new CannotVerifyAnotherCreatorError());
    createErrorFromNameLookup.set("CannotVerifyAnotherCreator", () => new CannotVerifyAnotherCreatorError());
    var CannotUnverifyAnotherCreatorError = class _CannotUnverifyAnotherCreatorError extends Error {
      constructor() {
        super("You cannot unilaterally unverify another creator");
        this.code = 55;
        this.name = "CannotUnverifyAnotherCreator";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotUnverifyAnotherCreatorError);
        }
      }
    };
    exports.CannotUnverifyAnotherCreatorError = CannotUnverifyAnotherCreatorError;
    createErrorFromCodeLookup.set(55, () => new CannotUnverifyAnotherCreatorError());
    createErrorFromNameLookup.set("CannotUnverifyAnotherCreator", () => new CannotUnverifyAnotherCreatorError());
    var SpotMismatchError = class _SpotMismatchError extends Error {
      constructor() {
        super("");
        this.code = 56;
        this.name = "SpotMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _SpotMismatchError);
        }
      }
    };
    exports.SpotMismatchError = SpotMismatchError;
    createErrorFromCodeLookup.set(56, () => new SpotMismatchError());
    createErrorFromNameLookup.set("SpotMismatch", () => new SpotMismatchError());
    var IncorrectOwnerError = class _IncorrectOwnerError extends Error {
      constructor() {
        super("Incorrect account owner");
        this.code = 57;
        this.name = "IncorrectOwner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _IncorrectOwnerError);
        }
      }
    };
    exports.IncorrectOwnerError = IncorrectOwnerError;
    createErrorFromCodeLookup.set(57, () => new IncorrectOwnerError());
    createErrorFromNameLookup.set("IncorrectOwner", () => new IncorrectOwnerError());
    var PrintingWouldBreachMaximumSupplyError = class _PrintingWouldBreachMaximumSupplyError extends Error {
      constructor() {
        super("");
        this.code = 58;
        this.name = "PrintingWouldBreachMaximumSupply";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintingWouldBreachMaximumSupplyError);
        }
      }
    };
    exports.PrintingWouldBreachMaximumSupplyError = PrintingWouldBreachMaximumSupplyError;
    createErrorFromCodeLookup.set(58, () => new PrintingWouldBreachMaximumSupplyError());
    createErrorFromNameLookup.set("PrintingWouldBreachMaximumSupply", () => new PrintingWouldBreachMaximumSupplyError());
    var DataIsImmutableError = class _DataIsImmutableError extends Error {
      constructor() {
        super("Data is immutable");
        this.code = 59;
        this.name = "DataIsImmutable";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DataIsImmutableError);
        }
      }
    };
    exports.DataIsImmutableError = DataIsImmutableError;
    createErrorFromCodeLookup.set(59, () => new DataIsImmutableError());
    createErrorFromNameLookup.set("DataIsImmutable", () => new DataIsImmutableError());
    var DuplicateCreatorAddressError = class _DuplicateCreatorAddressError extends Error {
      constructor() {
        super("No duplicate creator addresses");
        this.code = 60;
        this.name = "DuplicateCreatorAddress";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DuplicateCreatorAddressError);
        }
      }
    };
    exports.DuplicateCreatorAddressError = DuplicateCreatorAddressError;
    createErrorFromCodeLookup.set(60, () => new DuplicateCreatorAddressError());
    createErrorFromNameLookup.set("DuplicateCreatorAddress", () => new DuplicateCreatorAddressError());
    var ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = class _ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError extends Error {
      constructor() {
        super("");
        this.code = 61;
        this.name = "ReservationSpotsRemainingShouldMatchTotalSpotsAtStart";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError);
        }
      }
    };
    exports.ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError = ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError;
    createErrorFromCodeLookup.set(61, () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError());
    createErrorFromNameLookup.set("ReservationSpotsRemainingShouldMatchTotalSpotsAtStart", () => new ReservationSpotsRemainingShouldMatchTotalSpotsAtStartError());
    var InvalidTokenProgramError = class _InvalidTokenProgramError extends Error {
      constructor() {
        super("Invalid token program");
        this.code = 62;
        this.name = "InvalidTokenProgram";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidTokenProgramError);
        }
      }
    };
    exports.InvalidTokenProgramError = InvalidTokenProgramError;
    createErrorFromCodeLookup.set(62, () => new InvalidTokenProgramError());
    createErrorFromNameLookup.set("InvalidTokenProgram", () => new InvalidTokenProgramError());
    var DataTypeMismatchError = class _DataTypeMismatchError extends Error {
      constructor() {
        super("Data type mismatch");
        this.code = 63;
        this.name = "DataTypeMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DataTypeMismatchError);
        }
      }
    };
    exports.DataTypeMismatchError = DataTypeMismatchError;
    createErrorFromCodeLookup.set(63, () => new DataTypeMismatchError());
    createErrorFromNameLookup.set("DataTypeMismatch", () => new DataTypeMismatchError());
    var BeyondAlottedAddressSizeError = class _BeyondAlottedAddressSizeError extends Error {
      constructor() {
        super("");
        this.code = 64;
        this.name = "BeyondAlottedAddressSize";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _BeyondAlottedAddressSizeError);
        }
      }
    };
    exports.BeyondAlottedAddressSizeError = BeyondAlottedAddressSizeError;
    createErrorFromCodeLookup.set(64, () => new BeyondAlottedAddressSizeError());
    createErrorFromNameLookup.set("BeyondAlottedAddressSize", () => new BeyondAlottedAddressSizeError());
    var ReservationNotCompleteError = class _ReservationNotCompleteError extends Error {
      constructor() {
        super("");
        this.code = 65;
        this.name = "ReservationNotComplete";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationNotCompleteError);
        }
      }
    };
    exports.ReservationNotCompleteError = ReservationNotCompleteError;
    createErrorFromCodeLookup.set(65, () => new ReservationNotCompleteError());
    createErrorFromNameLookup.set("ReservationNotComplete", () => new ReservationNotCompleteError());
    var TriedToReplaceAnExistingReservationError = class _TriedToReplaceAnExistingReservationError extends Error {
      constructor() {
        super("");
        this.code = 66;
        this.name = "TriedToReplaceAnExistingReservation";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TriedToReplaceAnExistingReservationError);
        }
      }
    };
    exports.TriedToReplaceAnExistingReservationError = TriedToReplaceAnExistingReservationError;
    createErrorFromCodeLookup.set(66, () => new TriedToReplaceAnExistingReservationError());
    createErrorFromNameLookup.set("TriedToReplaceAnExistingReservation", () => new TriedToReplaceAnExistingReservationError());
    var InvalidOperationError = class _InvalidOperationError extends Error {
      constructor() {
        super("Invalid operation");
        this.code = 67;
        this.name = "InvalidOperation";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidOperationError);
        }
      }
    };
    exports.InvalidOperationError = InvalidOperationError;
    createErrorFromCodeLookup.set(67, () => new InvalidOperationError());
    createErrorFromNameLookup.set("InvalidOperation", () => new InvalidOperationError());
    var InvalidOwnerError = class _InvalidOwnerError extends Error {
      constructor() {
        super("Invalid Owner");
        this.code = 68;
        this.name = "InvalidOwner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidOwnerError);
        }
      }
    };
    exports.InvalidOwnerError = InvalidOwnerError;
    createErrorFromCodeLookup.set(68, () => new InvalidOwnerError());
    createErrorFromNameLookup.set("InvalidOwner", () => new InvalidOwnerError());
    var PrintingMintSupplyMustBeZeroForConversionError = class _PrintingMintSupplyMustBeZeroForConversionError extends Error {
      constructor() {
        super("Printing mint supply must be zero for conversion");
        this.code = 69;
        this.name = "PrintingMintSupplyMustBeZeroForConversion";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintingMintSupplyMustBeZeroForConversionError);
        }
      }
    };
    exports.PrintingMintSupplyMustBeZeroForConversionError = PrintingMintSupplyMustBeZeroForConversionError;
    createErrorFromCodeLookup.set(69, () => new PrintingMintSupplyMustBeZeroForConversionError());
    createErrorFromNameLookup.set("PrintingMintSupplyMustBeZeroForConversion", () => new PrintingMintSupplyMustBeZeroForConversionError());
    var OneTimeAuthMintSupplyMustBeZeroForConversionError = class _OneTimeAuthMintSupplyMustBeZeroForConversionError extends Error {
      constructor() {
        super("One Time Auth mint supply must be zero for conversion");
        this.code = 70;
        this.name = "OneTimeAuthMintSupplyMustBeZeroForConversion";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _OneTimeAuthMintSupplyMustBeZeroForConversionError);
        }
      }
    };
    exports.OneTimeAuthMintSupplyMustBeZeroForConversionError = OneTimeAuthMintSupplyMustBeZeroForConversionError;
    createErrorFromCodeLookup.set(70, () => new OneTimeAuthMintSupplyMustBeZeroForConversionError());
    createErrorFromNameLookup.set("OneTimeAuthMintSupplyMustBeZeroForConversion", () => new OneTimeAuthMintSupplyMustBeZeroForConversionError());
    var InvalidEditionIndexError = class _InvalidEditionIndexError extends Error {
      constructor() {
        super("You tried to insert one edition too many into an edition mark pda");
        this.code = 71;
        this.name = "InvalidEditionIndex";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidEditionIndexError);
        }
      }
    };
    exports.InvalidEditionIndexError = InvalidEditionIndexError;
    createErrorFromCodeLookup.set(71, () => new InvalidEditionIndexError());
    createErrorFromNameLookup.set("InvalidEditionIndex", () => new InvalidEditionIndexError());
    var ReservationArrayShouldBeSizeOneError = class _ReservationArrayShouldBeSizeOneError extends Error {
      constructor() {
        super("");
        this.code = 72;
        this.name = "ReservationArrayShouldBeSizeOne";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationArrayShouldBeSizeOneError);
        }
      }
    };
    exports.ReservationArrayShouldBeSizeOneError = ReservationArrayShouldBeSizeOneError;
    createErrorFromCodeLookup.set(72, () => new ReservationArrayShouldBeSizeOneError());
    createErrorFromNameLookup.set("ReservationArrayShouldBeSizeOne", () => new ReservationArrayShouldBeSizeOneError());
    var IsMutableCanOnlyBeFlippedToFalseError = class _IsMutableCanOnlyBeFlippedToFalseError extends Error {
      constructor() {
        super("Is Mutable can only be flipped to false");
        this.code = 73;
        this.name = "IsMutableCanOnlyBeFlippedToFalse";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _IsMutableCanOnlyBeFlippedToFalseError);
        }
      }
    };
    exports.IsMutableCanOnlyBeFlippedToFalseError = IsMutableCanOnlyBeFlippedToFalseError;
    createErrorFromCodeLookup.set(73, () => new IsMutableCanOnlyBeFlippedToFalseError());
    createErrorFromNameLookup.set("IsMutableCanOnlyBeFlippedToFalse", () => new IsMutableCanOnlyBeFlippedToFalseError());
    var CollectionCannotBeVerifiedInThisInstructionError = class _CollectionCannotBeVerifiedInThisInstructionError extends Error {
      constructor() {
        super("Collection cannot be verified in this instruction");
        this.code = 74;
        this.name = "CollectionCannotBeVerifiedInThisInstruction";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionCannotBeVerifiedInThisInstructionError);
        }
      }
    };
    exports.CollectionCannotBeVerifiedInThisInstructionError = CollectionCannotBeVerifiedInThisInstructionError;
    createErrorFromCodeLookup.set(74, () => new CollectionCannotBeVerifiedInThisInstructionError());
    createErrorFromNameLookup.set("CollectionCannotBeVerifiedInThisInstruction", () => new CollectionCannotBeVerifiedInThisInstructionError());
    var RemovedError = class _RemovedError extends Error {
      constructor() {
        super("This instruction was deprecated in a previous release and is now removed");
        this.code = 75;
        this.name = "Removed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _RemovedError);
        }
      }
    };
    exports.RemovedError = RemovedError;
    createErrorFromCodeLookup.set(75, () => new RemovedError());
    createErrorFromNameLookup.set("Removed", () => new RemovedError());
    var MustBeBurnedError = class _MustBeBurnedError extends Error {
      constructor() {
        super("");
        this.code = 76;
        this.name = "MustBeBurned";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MustBeBurnedError);
        }
      }
    };
    exports.MustBeBurnedError = MustBeBurnedError;
    createErrorFromCodeLookup.set(76, () => new MustBeBurnedError());
    createErrorFromNameLookup.set("MustBeBurned", () => new MustBeBurnedError());
    var InvalidUseMethodError = class _InvalidUseMethodError extends Error {
      constructor() {
        super("This use method is invalid");
        this.code = 77;
        this.name = "InvalidUseMethod";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidUseMethodError);
        }
      }
    };
    exports.InvalidUseMethodError = InvalidUseMethodError;
    createErrorFromCodeLookup.set(77, () => new InvalidUseMethodError());
    createErrorFromNameLookup.set("InvalidUseMethod", () => new InvalidUseMethodError());
    var CannotChangeUseMethodAfterFirstUseError = class _CannotChangeUseMethodAfterFirstUseError extends Error {
      constructor() {
        super("Cannot Change Use Method after the first use");
        this.code = 78;
        this.name = "CannotChangeUseMethodAfterFirstUse";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotChangeUseMethodAfterFirstUseError);
        }
      }
    };
    exports.CannotChangeUseMethodAfterFirstUseError = CannotChangeUseMethodAfterFirstUseError;
    createErrorFromCodeLookup.set(78, () => new CannotChangeUseMethodAfterFirstUseError());
    createErrorFromNameLookup.set("CannotChangeUseMethodAfterFirstUse", () => new CannotChangeUseMethodAfterFirstUseError());
    var CannotChangeUsesAfterFirstUseError = class _CannotChangeUsesAfterFirstUseError extends Error {
      constructor() {
        super("Cannot Change Remaining or Available uses after the first use");
        this.code = 79;
        this.name = "CannotChangeUsesAfterFirstUse";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotChangeUsesAfterFirstUseError);
        }
      }
    };
    exports.CannotChangeUsesAfterFirstUseError = CannotChangeUsesAfterFirstUseError;
    createErrorFromCodeLookup.set(79, () => new CannotChangeUsesAfterFirstUseError());
    createErrorFromNameLookup.set("CannotChangeUsesAfterFirstUse", () => new CannotChangeUsesAfterFirstUseError());
    var CollectionNotFoundError = class _CollectionNotFoundError extends Error {
      constructor() {
        super("Collection Not Found on Metadata");
        this.code = 80;
        this.name = "CollectionNotFound";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionNotFoundError);
        }
      }
    };
    exports.CollectionNotFoundError = CollectionNotFoundError;
    createErrorFromCodeLookup.set(80, () => new CollectionNotFoundError());
    createErrorFromNameLookup.set("CollectionNotFound", () => new CollectionNotFoundError());
    var InvalidCollectionUpdateAuthorityError = class _InvalidCollectionUpdateAuthorityError extends Error {
      constructor() {
        super("Collection Update Authority is invalid");
        this.code = 81;
        this.name = "InvalidCollectionUpdateAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidCollectionUpdateAuthorityError);
        }
      }
    };
    exports.InvalidCollectionUpdateAuthorityError = InvalidCollectionUpdateAuthorityError;
    createErrorFromCodeLookup.set(81, () => new InvalidCollectionUpdateAuthorityError());
    createErrorFromNameLookup.set("InvalidCollectionUpdateAuthority", () => new InvalidCollectionUpdateAuthorityError());
    var CollectionMustBeAUniqueMasterEditionError = class _CollectionMustBeAUniqueMasterEditionError extends Error {
      constructor() {
        super("Collection Must Be a Unique Master Edition v2");
        this.code = 82;
        this.name = "CollectionMustBeAUniqueMasterEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionMustBeAUniqueMasterEditionError);
        }
      }
    };
    exports.CollectionMustBeAUniqueMasterEditionError = CollectionMustBeAUniqueMasterEditionError;
    createErrorFromCodeLookup.set(82, () => new CollectionMustBeAUniqueMasterEditionError());
    createErrorFromNameLookup.set("CollectionMustBeAUniqueMasterEdition", () => new CollectionMustBeAUniqueMasterEditionError());
    var UseAuthorityRecordAlreadyExistsError = class _UseAuthorityRecordAlreadyExistsError extends Error {
      constructor() {
        super("The Use Authority Record Already Exists, to modify it Revoke, then Approve");
        this.code = 83;
        this.name = "UseAuthorityRecordAlreadyExists";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UseAuthorityRecordAlreadyExistsError);
        }
      }
    };
    exports.UseAuthorityRecordAlreadyExistsError = UseAuthorityRecordAlreadyExistsError;
    createErrorFromCodeLookup.set(83, () => new UseAuthorityRecordAlreadyExistsError());
    createErrorFromNameLookup.set("UseAuthorityRecordAlreadyExists", () => new UseAuthorityRecordAlreadyExistsError());
    var UseAuthorityRecordAlreadyRevokedError = class _UseAuthorityRecordAlreadyRevokedError extends Error {
      constructor() {
        super("The Use Authority Record is empty or already revoked");
        this.code = 84;
        this.name = "UseAuthorityRecordAlreadyRevoked";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UseAuthorityRecordAlreadyRevokedError);
        }
      }
    };
    exports.UseAuthorityRecordAlreadyRevokedError = UseAuthorityRecordAlreadyRevokedError;
    createErrorFromCodeLookup.set(84, () => new UseAuthorityRecordAlreadyRevokedError());
    createErrorFromNameLookup.set("UseAuthorityRecordAlreadyRevoked", () => new UseAuthorityRecordAlreadyRevokedError());
    var UnusableError = class _UnusableError extends Error {
      constructor() {
        super("This token has no uses");
        this.code = 85;
        this.name = "Unusable";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UnusableError);
        }
      }
    };
    exports.UnusableError = UnusableError;
    createErrorFromCodeLookup.set(85, () => new UnusableError());
    createErrorFromNameLookup.set("Unusable", () => new UnusableError());
    var NotEnoughUsesError = class _NotEnoughUsesError extends Error {
      constructor() {
        super("There are not enough Uses left on this token.");
        this.code = 86;
        this.name = "NotEnoughUses";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotEnoughUsesError);
        }
      }
    };
    exports.NotEnoughUsesError = NotEnoughUsesError;
    createErrorFromCodeLookup.set(86, () => new NotEnoughUsesError());
    createErrorFromNameLookup.set("NotEnoughUses", () => new NotEnoughUsesError());
    var CollectionAuthorityRecordAlreadyExistsError = class _CollectionAuthorityRecordAlreadyExistsError extends Error {
      constructor() {
        super("This Collection Authority Record Already Exists.");
        this.code = 87;
        this.name = "CollectionAuthorityRecordAlreadyExists";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionAuthorityRecordAlreadyExistsError);
        }
      }
    };
    exports.CollectionAuthorityRecordAlreadyExistsError = CollectionAuthorityRecordAlreadyExistsError;
    createErrorFromCodeLookup.set(87, () => new CollectionAuthorityRecordAlreadyExistsError());
    createErrorFromNameLookup.set("CollectionAuthorityRecordAlreadyExists", () => new CollectionAuthorityRecordAlreadyExistsError());
    var CollectionAuthorityDoesNotExistError = class _CollectionAuthorityDoesNotExistError extends Error {
      constructor() {
        super("This Collection Authority Record Does Not Exist.");
        this.code = 88;
        this.name = "CollectionAuthorityDoesNotExist";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionAuthorityDoesNotExistError);
        }
      }
    };
    exports.CollectionAuthorityDoesNotExistError = CollectionAuthorityDoesNotExistError;
    createErrorFromCodeLookup.set(88, () => new CollectionAuthorityDoesNotExistError());
    createErrorFromNameLookup.set("CollectionAuthorityDoesNotExist", () => new CollectionAuthorityDoesNotExistError());
    var InvalidUseAuthorityRecordError = class _InvalidUseAuthorityRecordError extends Error {
      constructor() {
        super("This Use Authority Record is invalid.");
        this.code = 89;
        this.name = "InvalidUseAuthorityRecord";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidUseAuthorityRecordError);
        }
      }
    };
    exports.InvalidUseAuthorityRecordError = InvalidUseAuthorityRecordError;
    createErrorFromCodeLookup.set(89, () => new InvalidUseAuthorityRecordError());
    createErrorFromNameLookup.set("InvalidUseAuthorityRecord", () => new InvalidUseAuthorityRecordError());
    var InvalidCollectionAuthorityRecordError = class _InvalidCollectionAuthorityRecordError extends Error {
      constructor() {
        super("");
        this.code = 90;
        this.name = "InvalidCollectionAuthorityRecord";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidCollectionAuthorityRecordError);
        }
      }
    };
    exports.InvalidCollectionAuthorityRecordError = InvalidCollectionAuthorityRecordError;
    createErrorFromCodeLookup.set(90, () => new InvalidCollectionAuthorityRecordError());
    createErrorFromNameLookup.set("InvalidCollectionAuthorityRecord", () => new InvalidCollectionAuthorityRecordError());
    var InvalidFreezeAuthorityError = class _InvalidFreezeAuthorityError extends Error {
      constructor() {
        super("Metadata does not match the freeze authority on the mint");
        this.code = 91;
        this.name = "InvalidFreezeAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidFreezeAuthorityError);
        }
      }
    };
    exports.InvalidFreezeAuthorityError = InvalidFreezeAuthorityError;
    createErrorFromCodeLookup.set(91, () => new InvalidFreezeAuthorityError());
    createErrorFromNameLookup.set("InvalidFreezeAuthority", () => new InvalidFreezeAuthorityError());
    var InvalidDelegateError = class _InvalidDelegateError extends Error {
      constructor() {
        super("All tokens in this account have not been delegated to this user.");
        this.code = 92;
        this.name = "InvalidDelegate";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidDelegateError);
        }
      }
    };
    exports.InvalidDelegateError = InvalidDelegateError;
    createErrorFromCodeLookup.set(92, () => new InvalidDelegateError());
    createErrorFromNameLookup.set("InvalidDelegate", () => new InvalidDelegateError());
    var CannotAdjustVerifiedCreatorError = class _CannotAdjustVerifiedCreatorError extends Error {
      constructor() {
        super("");
        this.code = 93;
        this.name = "CannotAdjustVerifiedCreator";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotAdjustVerifiedCreatorError);
        }
      }
    };
    exports.CannotAdjustVerifiedCreatorError = CannotAdjustVerifiedCreatorError;
    createErrorFromCodeLookup.set(93, () => new CannotAdjustVerifiedCreatorError());
    createErrorFromNameLookup.set("CannotAdjustVerifiedCreator", () => new CannotAdjustVerifiedCreatorError());
    var CannotRemoveVerifiedCreatorError = class _CannotRemoveVerifiedCreatorError extends Error {
      constructor() {
        super("Verified creators cannot be removed.");
        this.code = 94;
        this.name = "CannotRemoveVerifiedCreator";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotRemoveVerifiedCreatorError);
        }
      }
    };
    exports.CannotRemoveVerifiedCreatorError = CannotRemoveVerifiedCreatorError;
    createErrorFromCodeLookup.set(94, () => new CannotRemoveVerifiedCreatorError());
    createErrorFromNameLookup.set("CannotRemoveVerifiedCreator", () => new CannotRemoveVerifiedCreatorError());
    var CannotWipeVerifiedCreatorsError = class _CannotWipeVerifiedCreatorsError extends Error {
      constructor() {
        super("");
        this.code = 95;
        this.name = "CannotWipeVerifiedCreators";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotWipeVerifiedCreatorsError);
        }
      }
    };
    exports.CannotWipeVerifiedCreatorsError = CannotWipeVerifiedCreatorsError;
    createErrorFromCodeLookup.set(95, () => new CannotWipeVerifiedCreatorsError());
    createErrorFromNameLookup.set("CannotWipeVerifiedCreators", () => new CannotWipeVerifiedCreatorsError());
    var NotAllowedToChangeSellerFeeBasisPointsError = class _NotAllowedToChangeSellerFeeBasisPointsError extends Error {
      constructor() {
        super("");
        this.code = 96;
        this.name = "NotAllowedToChangeSellerFeeBasisPoints";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotAllowedToChangeSellerFeeBasisPointsError);
        }
      }
    };
    exports.NotAllowedToChangeSellerFeeBasisPointsError = NotAllowedToChangeSellerFeeBasisPointsError;
    createErrorFromCodeLookup.set(96, () => new NotAllowedToChangeSellerFeeBasisPointsError());
    createErrorFromNameLookup.set("NotAllowedToChangeSellerFeeBasisPoints", () => new NotAllowedToChangeSellerFeeBasisPointsError());
    var EditionOverrideCannotBeZeroError = class _EditionOverrideCannotBeZeroError extends Error {
      constructor() {
        super("Edition override cannot be zero");
        this.code = 97;
        this.name = "EditionOverrideCannotBeZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EditionOverrideCannotBeZeroError);
        }
      }
    };
    exports.EditionOverrideCannotBeZeroError = EditionOverrideCannotBeZeroError;
    createErrorFromCodeLookup.set(97, () => new EditionOverrideCannotBeZeroError());
    createErrorFromNameLookup.set("EditionOverrideCannotBeZero", () => new EditionOverrideCannotBeZeroError());
    var InvalidUserError = class _InvalidUserError extends Error {
      constructor() {
        super("Invalid User");
        this.code = 98;
        this.name = "InvalidUser";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidUserError);
        }
      }
    };
    exports.InvalidUserError = InvalidUserError;
    createErrorFromCodeLookup.set(98, () => new InvalidUserError());
    createErrorFromNameLookup.set("InvalidUser", () => new InvalidUserError());
    var RevokeCollectionAuthoritySignerIncorrectError = class _RevokeCollectionAuthoritySignerIncorrectError extends Error {
      constructor() {
        super("Revoke Collection Authority signer is incorrect");
        this.code = 99;
        this.name = "RevokeCollectionAuthoritySignerIncorrect";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _RevokeCollectionAuthoritySignerIncorrectError);
        }
      }
    };
    exports.RevokeCollectionAuthoritySignerIncorrectError = RevokeCollectionAuthoritySignerIncorrectError;
    createErrorFromCodeLookup.set(99, () => new RevokeCollectionAuthoritySignerIncorrectError());
    createErrorFromNameLookup.set("RevokeCollectionAuthoritySignerIncorrect", () => new RevokeCollectionAuthoritySignerIncorrectError());
    var TokenCloseFailedError = class _TokenCloseFailedError extends Error {
      constructor() {
        super("");
        this.code = 100;
        this.name = "TokenCloseFailed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _TokenCloseFailedError);
        }
      }
    };
    exports.TokenCloseFailedError = TokenCloseFailedError;
    createErrorFromCodeLookup.set(100, () => new TokenCloseFailedError());
    createErrorFromNameLookup.set("TokenCloseFailed", () => new TokenCloseFailedError());
    var UnsizedCollectionError = class _UnsizedCollectionError extends Error {
      constructor() {
        super("Can't use this function on unsized collection");
        this.code = 101;
        this.name = "UnsizedCollection";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UnsizedCollectionError);
        }
      }
    };
    exports.UnsizedCollectionError = UnsizedCollectionError;
    createErrorFromCodeLookup.set(101, () => new UnsizedCollectionError());
    createErrorFromNameLookup.set("UnsizedCollection", () => new UnsizedCollectionError());
    var SizedCollectionError = class _SizedCollectionError extends Error {
      constructor() {
        super("Can't use this function on a sized collection");
        this.code = 102;
        this.name = "SizedCollection";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _SizedCollectionError);
        }
      }
    };
    exports.SizedCollectionError = SizedCollectionError;
    createErrorFromCodeLookup.set(102, () => new SizedCollectionError());
    createErrorFromNameLookup.set("SizedCollection", () => new SizedCollectionError());
    var MissingCollectionMetadataError = class _MissingCollectionMetadataError extends Error {
      constructor() {
        super("Missing collection metadata account");
        this.code = 103;
        this.name = "MissingCollectionMetadata";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingCollectionMetadataError);
        }
      }
    };
    exports.MissingCollectionMetadataError = MissingCollectionMetadataError;
    createErrorFromCodeLookup.set(103, () => new MissingCollectionMetadataError());
    createErrorFromNameLookup.set("MissingCollectionMetadata", () => new MissingCollectionMetadataError());
    var NotAMemberOfCollectionError = class _NotAMemberOfCollectionError extends Error {
      constructor() {
        super("This NFT is not a member of the specified collection.");
        this.code = 104;
        this.name = "NotAMemberOfCollection";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotAMemberOfCollectionError);
        }
      }
    };
    exports.NotAMemberOfCollectionError = NotAMemberOfCollectionError;
    createErrorFromCodeLookup.set(104, () => new NotAMemberOfCollectionError());
    createErrorFromNameLookup.set("NotAMemberOfCollection", () => new NotAMemberOfCollectionError());
    var NotVerifiedMemberOfCollectionError = class _NotVerifiedMemberOfCollectionError extends Error {
      constructor() {
        super("This NFT is not a verified member of the specified collection.");
        this.code = 105;
        this.name = "NotVerifiedMemberOfCollection";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotVerifiedMemberOfCollectionError);
        }
      }
    };
    exports.NotVerifiedMemberOfCollectionError = NotVerifiedMemberOfCollectionError;
    createErrorFromCodeLookup.set(105, () => new NotVerifiedMemberOfCollectionError());
    createErrorFromNameLookup.set("NotVerifiedMemberOfCollection", () => new NotVerifiedMemberOfCollectionError());
    var NotACollectionParentError = class _NotACollectionParentError extends Error {
      constructor() {
        super("This NFT is not a collection parent NFT.");
        this.code = 106;
        this.name = "NotACollectionParent";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotACollectionParentError);
        }
      }
    };
    exports.NotACollectionParentError = NotACollectionParentError;
    createErrorFromCodeLookup.set(106, () => new NotACollectionParentError());
    createErrorFromNameLookup.set("NotACollectionParent", () => new NotACollectionParentError());
    var CouldNotDetermineTokenStandardError = class _CouldNotDetermineTokenStandardError extends Error {
      constructor() {
        super("Could not determine a TokenStandard type.");
        this.code = 107;
        this.name = "CouldNotDetermineTokenStandard";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CouldNotDetermineTokenStandardError);
        }
      }
    };
    exports.CouldNotDetermineTokenStandardError = CouldNotDetermineTokenStandardError;
    createErrorFromCodeLookup.set(107, () => new CouldNotDetermineTokenStandardError());
    createErrorFromNameLookup.set("CouldNotDetermineTokenStandard", () => new CouldNotDetermineTokenStandardError());
    var MissingEditionAccountError = class _MissingEditionAccountError extends Error {
      constructor() {
        super("This mint account has an edition but none was provided.");
        this.code = 108;
        this.name = "MissingEditionAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingEditionAccountError);
        }
      }
    };
    exports.MissingEditionAccountError = MissingEditionAccountError;
    createErrorFromCodeLookup.set(108, () => new MissingEditionAccountError());
    createErrorFromNameLookup.set("MissingEditionAccount", () => new MissingEditionAccountError());
    var NotAMasterEditionError = class _NotAMasterEditionError extends Error {
      constructor() {
        super("This edition is not a Master Edition");
        this.code = 109;
        this.name = "NotAMasterEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotAMasterEditionError);
        }
      }
    };
    exports.NotAMasterEditionError = NotAMasterEditionError;
    createErrorFromCodeLookup.set(109, () => new NotAMasterEditionError());
    createErrorFromNameLookup.set("NotAMasterEdition", () => new NotAMasterEditionError());
    var MasterEditionHasPrintsError = class _MasterEditionHasPrintsError extends Error {
      constructor() {
        super("This Master Edition has existing prints");
        this.code = 110;
        this.name = "MasterEditionHasPrints";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MasterEditionHasPrintsError);
        }
      }
    };
    exports.MasterEditionHasPrintsError = MasterEditionHasPrintsError;
    createErrorFromCodeLookup.set(110, () => new MasterEditionHasPrintsError());
    createErrorFromNameLookup.set("MasterEditionHasPrints", () => new MasterEditionHasPrintsError());
    var BorshDeserializationErrorError = class _BorshDeserializationErrorError extends Error {
      constructor() {
        super("");
        this.code = 111;
        this.name = "BorshDeserializationError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _BorshDeserializationErrorError);
        }
      }
    };
    exports.BorshDeserializationErrorError = BorshDeserializationErrorError;
    createErrorFromCodeLookup.set(111, () => new BorshDeserializationErrorError());
    createErrorFromNameLookup.set("BorshDeserializationError", () => new BorshDeserializationErrorError());
    var CannotUpdateVerifiedCollectionError = class _CannotUpdateVerifiedCollectionError extends Error {
      constructor() {
        super("Cannot update a verified collection in this command");
        this.code = 112;
        this.name = "CannotUpdateVerifiedCollection";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotUpdateVerifiedCollectionError);
        }
      }
    };
    exports.CannotUpdateVerifiedCollectionError = CannotUpdateVerifiedCollectionError;
    createErrorFromCodeLookup.set(112, () => new CannotUpdateVerifiedCollectionError());
    createErrorFromNameLookup.set("CannotUpdateVerifiedCollection", () => new CannotUpdateVerifiedCollectionError());
    var CollectionMasterEditionAccountInvalidError = class _CollectionMasterEditionAccountInvalidError extends Error {
      constructor() {
        super("Edition account doesnt match collection ");
        this.code = 113;
        this.name = "CollectionMasterEditionAccountInvalid";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CollectionMasterEditionAccountInvalidError);
        }
      }
    };
    exports.CollectionMasterEditionAccountInvalidError = CollectionMasterEditionAccountInvalidError;
    createErrorFromCodeLookup.set(113, () => new CollectionMasterEditionAccountInvalidError());
    createErrorFromNameLookup.set("CollectionMasterEditionAccountInvalid", () => new CollectionMasterEditionAccountInvalidError());
    var AlreadyVerifiedError = class _AlreadyVerifiedError extends Error {
      constructor() {
        super("Item is already verified.");
        this.code = 114;
        this.name = "AlreadyVerified";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AlreadyVerifiedError);
        }
      }
    };
    exports.AlreadyVerifiedError = AlreadyVerifiedError;
    createErrorFromCodeLookup.set(114, () => new AlreadyVerifiedError());
    createErrorFromNameLookup.set("AlreadyVerified", () => new AlreadyVerifiedError());
    var AlreadyUnverifiedError = class _AlreadyUnverifiedError extends Error {
      constructor() {
        super("");
        this.code = 115;
        this.name = "AlreadyUnverified";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AlreadyUnverifiedError);
        }
      }
    };
    exports.AlreadyUnverifiedError = AlreadyUnverifiedError;
    createErrorFromCodeLookup.set(115, () => new AlreadyUnverifiedError());
    createErrorFromNameLookup.set("AlreadyUnverified", () => new AlreadyUnverifiedError());
    var NotAPrintEditionError = class _NotAPrintEditionError extends Error {
      constructor() {
        super("This edition is not a Print Edition");
        this.code = 116;
        this.name = "NotAPrintEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NotAPrintEditionError);
        }
      }
    };
    exports.NotAPrintEditionError = NotAPrintEditionError;
    createErrorFromCodeLookup.set(116, () => new NotAPrintEditionError());
    createErrorFromNameLookup.set("NotAPrintEdition", () => new NotAPrintEditionError());
    var InvalidMasterEditionError = class _InvalidMasterEditionError extends Error {
      constructor() {
        super("Invalid Master Edition");
        this.code = 117;
        this.name = "InvalidMasterEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMasterEditionError);
        }
      }
    };
    exports.InvalidMasterEditionError = InvalidMasterEditionError;
    createErrorFromCodeLookup.set(117, () => new InvalidMasterEditionError());
    createErrorFromNameLookup.set("InvalidMasterEdition", () => new InvalidMasterEditionError());
    var InvalidPrintEditionError = class _InvalidPrintEditionError extends Error {
      constructor() {
        super("Invalid Print Edition");
        this.code = 118;
        this.name = "InvalidPrintEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidPrintEditionError);
        }
      }
    };
    exports.InvalidPrintEditionError = InvalidPrintEditionError;
    createErrorFromCodeLookup.set(118, () => new InvalidPrintEditionError());
    createErrorFromNameLookup.set("InvalidPrintEdition", () => new InvalidPrintEditionError());
    var InvalidEditionMarkerError = class _InvalidEditionMarkerError extends Error {
      constructor() {
        super("Invalid Edition Marker");
        this.code = 119;
        this.name = "InvalidEditionMarker";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidEditionMarkerError);
        }
      }
    };
    exports.InvalidEditionMarkerError = InvalidEditionMarkerError;
    createErrorFromCodeLookup.set(119, () => new InvalidEditionMarkerError());
    createErrorFromNameLookup.set("InvalidEditionMarker", () => new InvalidEditionMarkerError());
    var ReservationListDeprecatedError = class _ReservationListDeprecatedError extends Error {
      constructor() {
        super("Reservation List is Deprecated");
        this.code = 120;
        this.name = "ReservationListDeprecated";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ReservationListDeprecatedError);
        }
      }
    };
    exports.ReservationListDeprecatedError = ReservationListDeprecatedError;
    createErrorFromCodeLookup.set(120, () => new ReservationListDeprecatedError());
    createErrorFromNameLookup.set("ReservationListDeprecated", () => new ReservationListDeprecatedError());
    var PrintEditionDoesNotMatchMasterEditionError = class _PrintEditionDoesNotMatchMasterEditionError extends Error {
      constructor() {
        super("Print Edition does not match Master Edition");
        this.code = 121;
        this.name = "PrintEditionDoesNotMatchMasterEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PrintEditionDoesNotMatchMasterEditionError);
        }
      }
    };
    exports.PrintEditionDoesNotMatchMasterEditionError = PrintEditionDoesNotMatchMasterEditionError;
    createErrorFromCodeLookup.set(121, () => new PrintEditionDoesNotMatchMasterEditionError());
    createErrorFromNameLookup.set("PrintEditionDoesNotMatchMasterEdition", () => new PrintEditionDoesNotMatchMasterEditionError());
    var EditionNumberGreaterThanMaxSupplyError = class _EditionNumberGreaterThanMaxSupplyError extends Error {
      constructor() {
        super("Edition Number greater than max supply");
        this.code = 122;
        this.name = "EditionNumberGreaterThanMaxSupply";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EditionNumberGreaterThanMaxSupplyError);
        }
      }
    };
    exports.EditionNumberGreaterThanMaxSupplyError = EditionNumberGreaterThanMaxSupplyError;
    createErrorFromCodeLookup.set(122, () => new EditionNumberGreaterThanMaxSupplyError());
    createErrorFromNameLookup.set("EditionNumberGreaterThanMaxSupply", () => new EditionNumberGreaterThanMaxSupplyError());
    var MustUnverifyError = class _MustUnverifyError extends Error {
      constructor() {
        super("Must unverify before migrating collections.");
        this.code = 123;
        this.name = "MustUnverify";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MustUnverifyError);
        }
      }
    };
    exports.MustUnverifyError = MustUnverifyError;
    createErrorFromCodeLookup.set(123, () => new MustUnverifyError());
    createErrorFromNameLookup.set("MustUnverify", () => new MustUnverifyError());
    var InvalidEscrowBumpSeedError = class _InvalidEscrowBumpSeedError extends Error {
      constructor() {
        super("Invalid Escrow Account Bump Seed");
        this.code = 124;
        this.name = "InvalidEscrowBumpSeed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidEscrowBumpSeedError);
        }
      }
    };
    exports.InvalidEscrowBumpSeedError = InvalidEscrowBumpSeedError;
    createErrorFromCodeLookup.set(124, () => new InvalidEscrowBumpSeedError());
    createErrorFromNameLookup.set("InvalidEscrowBumpSeed", () => new InvalidEscrowBumpSeedError());
    var MustBeEscrowAuthorityError = class _MustBeEscrowAuthorityError extends Error {
      constructor() {
        super("Must Escrow Authority");
        this.code = 125;
        this.name = "MustBeEscrowAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MustBeEscrowAuthorityError);
        }
      }
    };
    exports.MustBeEscrowAuthorityError = MustBeEscrowAuthorityError;
    createErrorFromCodeLookup.set(125, () => new MustBeEscrowAuthorityError());
    createErrorFromNameLookup.set("MustBeEscrowAuthority", () => new MustBeEscrowAuthorityError());
    var InvalidSystemProgramError = class _InvalidSystemProgramError extends Error {
      constructor() {
        super("Invalid System Program");
        this.code = 126;
        this.name = "InvalidSystemProgram";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidSystemProgramError);
        }
      }
    };
    exports.InvalidSystemProgramError = InvalidSystemProgramError;
    createErrorFromCodeLookup.set(126, () => new InvalidSystemProgramError());
    createErrorFromNameLookup.set("InvalidSystemProgram", () => new InvalidSystemProgramError());
    var MustBeNonFungibleError = class _MustBeNonFungibleError extends Error {
      constructor() {
        super("Must be a Non Fungible Token");
        this.code = 127;
        this.name = "MustBeNonFungible";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MustBeNonFungibleError);
        }
      }
    };
    exports.MustBeNonFungibleError = MustBeNonFungibleError;
    createErrorFromCodeLookup.set(127, () => new MustBeNonFungibleError());
    createErrorFromNameLookup.set("MustBeNonFungible", () => new MustBeNonFungibleError());
    var InsufficientTokensError = class _InsufficientTokensError extends Error {
      constructor() {
        super("Insufficient tokens for transfer");
        this.code = 128;
        this.name = "InsufficientTokens";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InsufficientTokensError);
        }
      }
    };
    exports.InsufficientTokensError = InsufficientTokensError;
    createErrorFromCodeLookup.set(128, () => new InsufficientTokensError());
    createErrorFromNameLookup.set("InsufficientTokens", () => new InsufficientTokensError());
    var BorshSerializationErrorError = class _BorshSerializationErrorError extends Error {
      constructor() {
        super("Borsh Serialization Error");
        this.code = 129;
        this.name = "BorshSerializationError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _BorshSerializationErrorError);
        }
      }
    };
    exports.BorshSerializationErrorError = BorshSerializationErrorError;
    createErrorFromCodeLookup.set(129, () => new BorshSerializationErrorError());
    createErrorFromNameLookup.set("BorshSerializationError", () => new BorshSerializationErrorError());
    var NoFreezeAuthoritySetError = class _NoFreezeAuthoritySetError extends Error {
      constructor() {
        super("Cannot create NFT with no Freeze Authority.");
        this.code = 130;
        this.name = "NoFreezeAuthoritySet";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _NoFreezeAuthoritySetError);
        }
      }
    };
    exports.NoFreezeAuthoritySetError = NoFreezeAuthoritySetError;
    createErrorFromCodeLookup.set(130, () => new NoFreezeAuthoritySetError());
    createErrorFromNameLookup.set("NoFreezeAuthoritySet", () => new NoFreezeAuthoritySetError());
    var InvalidCollectionSizeChangeError = class _InvalidCollectionSizeChangeError extends Error {
      constructor() {
        super("Invalid collection size change");
        this.code = 131;
        this.name = "InvalidCollectionSizeChange";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidCollectionSizeChangeError);
        }
      }
    };
    exports.InvalidCollectionSizeChangeError = InvalidCollectionSizeChangeError;
    createErrorFromCodeLookup.set(131, () => new InvalidCollectionSizeChangeError());
    createErrorFromNameLookup.set("InvalidCollectionSizeChange", () => new InvalidCollectionSizeChangeError());
    var InvalidBubblegumSignerError = class _InvalidBubblegumSignerError extends Error {
      constructor() {
        super("Invalid bubblegum signer");
        this.code = 132;
        this.name = "InvalidBubblegumSigner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidBubblegumSignerError);
        }
      }
    };
    exports.InvalidBubblegumSignerError = InvalidBubblegumSignerError;
    createErrorFromCodeLookup.set(132, () => new InvalidBubblegumSignerError());
    createErrorFromNameLookup.set("InvalidBubblegumSigner", () => new InvalidBubblegumSignerError());
    var EscrowParentHasDelegateError = class _EscrowParentHasDelegateError extends Error {
      constructor() {
        super("Escrow parent cannot have a delegate");
        this.code = 133;
        this.name = "EscrowParentHasDelegate";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _EscrowParentHasDelegateError);
        }
      }
    };
    exports.EscrowParentHasDelegateError = EscrowParentHasDelegateError;
    createErrorFromCodeLookup.set(133, () => new EscrowParentHasDelegateError());
    createErrorFromNameLookup.set("EscrowParentHasDelegate", () => new EscrowParentHasDelegateError());
    var MintIsNotSignerError = class _MintIsNotSignerError extends Error {
      constructor() {
        super("Mint needs to be signer to initialize the account");
        this.code = 134;
        this.name = "MintIsNotSigner";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MintIsNotSignerError);
        }
      }
    };
    exports.MintIsNotSignerError = MintIsNotSignerError;
    createErrorFromCodeLookup.set(134, () => new MintIsNotSignerError());
    createErrorFromNameLookup.set("MintIsNotSigner", () => new MintIsNotSignerError());
    var InvalidTokenStandardError = class _InvalidTokenStandardError extends Error {
      constructor() {
        super("Invalid token standard");
        this.code = 135;
        this.name = "InvalidTokenStandard";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidTokenStandardError);
        }
      }
    };
    exports.InvalidTokenStandardError = InvalidTokenStandardError;
    createErrorFromCodeLookup.set(135, () => new InvalidTokenStandardError());
    createErrorFromNameLookup.set("InvalidTokenStandard", () => new InvalidTokenStandardError());
    var InvalidMintForTokenStandardError = class _InvalidMintForTokenStandardError extends Error {
      constructor() {
        super("Invalid mint account for specified token standard");
        this.code = 136;
        this.name = "InvalidMintForTokenStandard";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMintForTokenStandardError);
        }
      }
    };
    exports.InvalidMintForTokenStandardError = InvalidMintForTokenStandardError;
    createErrorFromCodeLookup.set(136, () => new InvalidMintForTokenStandardError());
    createErrorFromNameLookup.set("InvalidMintForTokenStandard", () => new InvalidMintForTokenStandardError());
    var InvalidAuthorizationRulesError = class _InvalidAuthorizationRulesError extends Error {
      constructor() {
        super("Invalid authorization rules account");
        this.code = 137;
        this.name = "InvalidAuthorizationRules";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidAuthorizationRulesError);
        }
      }
    };
    exports.InvalidAuthorizationRulesError = InvalidAuthorizationRulesError;
    createErrorFromCodeLookup.set(137, () => new InvalidAuthorizationRulesError());
    createErrorFromNameLookup.set("InvalidAuthorizationRules", () => new InvalidAuthorizationRulesError());
    var MissingAuthorizationRulesError = class _MissingAuthorizationRulesError extends Error {
      constructor() {
        super("Missing authorization rules account");
        this.code = 138;
        this.name = "MissingAuthorizationRules";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingAuthorizationRulesError);
        }
      }
    };
    exports.MissingAuthorizationRulesError = MissingAuthorizationRulesError;
    createErrorFromCodeLookup.set(138, () => new MissingAuthorizationRulesError());
    createErrorFromNameLookup.set("MissingAuthorizationRules", () => new MissingAuthorizationRulesError());
    var MissingProgrammableConfigError = class _MissingProgrammableConfigError extends Error {
      constructor() {
        super("Missing programmable configuration");
        this.code = 139;
        this.name = "MissingProgrammableConfig";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingProgrammableConfigError);
        }
      }
    };
    exports.MissingProgrammableConfigError = MissingProgrammableConfigError;
    createErrorFromCodeLookup.set(139, () => new MissingProgrammableConfigError());
    createErrorFromNameLookup.set("MissingProgrammableConfig", () => new MissingProgrammableConfigError());
    var InvalidProgrammableConfigError = class _InvalidProgrammableConfigError extends Error {
      constructor() {
        super("Invalid programmable configuration");
        this.code = 140;
        this.name = "InvalidProgrammableConfig";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidProgrammableConfigError);
        }
      }
    };
    exports.InvalidProgrammableConfigError = InvalidProgrammableConfigError;
    createErrorFromCodeLookup.set(140, () => new InvalidProgrammableConfigError());
    createErrorFromNameLookup.set("InvalidProgrammableConfig", () => new InvalidProgrammableConfigError());
    var DelegateAlreadyExistsError = class _DelegateAlreadyExistsError extends Error {
      constructor() {
        super("Delegate already exists");
        this.code = 141;
        this.name = "DelegateAlreadyExists";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DelegateAlreadyExistsError);
        }
      }
    };
    exports.DelegateAlreadyExistsError = DelegateAlreadyExistsError;
    createErrorFromCodeLookup.set(141, () => new DelegateAlreadyExistsError());
    createErrorFromNameLookup.set("DelegateAlreadyExists", () => new DelegateAlreadyExistsError());
    var DelegateNotFoundError = class _DelegateNotFoundError extends Error {
      constructor() {
        super("Delegate not found");
        this.code = 142;
        this.name = "DelegateNotFound";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DelegateNotFoundError);
        }
      }
    };
    exports.DelegateNotFoundError = DelegateNotFoundError;
    createErrorFromCodeLookup.set(142, () => new DelegateNotFoundError());
    createErrorFromNameLookup.set("DelegateNotFound", () => new DelegateNotFoundError());
    var MissingAccountInBuilderError = class _MissingAccountInBuilderError extends Error {
      constructor() {
        super("Required account not set in instruction builder");
        this.code = 143;
        this.name = "MissingAccountInBuilder";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingAccountInBuilderError);
        }
      }
    };
    exports.MissingAccountInBuilderError = MissingAccountInBuilderError;
    createErrorFromCodeLookup.set(143, () => new MissingAccountInBuilderError());
    createErrorFromNameLookup.set("MissingAccountInBuilder", () => new MissingAccountInBuilderError());
    var MissingArgumentInBuilderError = class _MissingArgumentInBuilderError extends Error {
      constructor() {
        super("Required argument not set in instruction builder");
        this.code = 144;
        this.name = "MissingArgumentInBuilder";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingArgumentInBuilderError);
        }
      }
    };
    exports.MissingArgumentInBuilderError = MissingArgumentInBuilderError;
    createErrorFromCodeLookup.set(144, () => new MissingArgumentInBuilderError());
    createErrorFromNameLookup.set("MissingArgumentInBuilder", () => new MissingArgumentInBuilderError());
    var FeatureNotSupportedError = class _FeatureNotSupportedError extends Error {
      constructor() {
        super("Feature not supported currently");
        this.code = 145;
        this.name = "FeatureNotSupported";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _FeatureNotSupportedError);
        }
      }
    };
    exports.FeatureNotSupportedError = FeatureNotSupportedError;
    createErrorFromCodeLookup.set(145, () => new FeatureNotSupportedError());
    createErrorFromNameLookup.set("FeatureNotSupported", () => new FeatureNotSupportedError());
    var InvalidSystemWalletError = class _InvalidSystemWalletError extends Error {
      constructor() {
        super("Invalid system wallet");
        this.code = 146;
        this.name = "InvalidSystemWallet";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidSystemWalletError);
        }
      }
    };
    exports.InvalidSystemWalletError = InvalidSystemWalletError;
    createErrorFromCodeLookup.set(146, () => new InvalidSystemWalletError());
    createErrorFromNameLookup.set("InvalidSystemWallet", () => new InvalidSystemWalletError());
    var OnlySaleDelegateCanTransferError = class _OnlySaleDelegateCanTransferError extends Error {
      constructor() {
        super("Only the sale delegate can transfer while its set");
        this.code = 147;
        this.name = "OnlySaleDelegateCanTransfer";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _OnlySaleDelegateCanTransferError);
        }
      }
    };
    exports.OnlySaleDelegateCanTransferError = OnlySaleDelegateCanTransferError;
    createErrorFromCodeLookup.set(147, () => new OnlySaleDelegateCanTransferError());
    createErrorFromNameLookup.set("OnlySaleDelegateCanTransfer", () => new OnlySaleDelegateCanTransferError());
    var MissingTokenAccountError = class _MissingTokenAccountError extends Error {
      constructor() {
        super("Missing token account");
        this.code = 148;
        this.name = "MissingTokenAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingTokenAccountError);
        }
      }
    };
    exports.MissingTokenAccountError = MissingTokenAccountError;
    createErrorFromCodeLookup.set(148, () => new MissingTokenAccountError());
    createErrorFromNameLookup.set("MissingTokenAccount", () => new MissingTokenAccountError());
    var MissingSplTokenProgramError = class _MissingSplTokenProgramError extends Error {
      constructor() {
        super("Missing SPL token program");
        this.code = 149;
        this.name = "MissingSplTokenProgram";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingSplTokenProgramError);
        }
      }
    };
    exports.MissingSplTokenProgramError = MissingSplTokenProgramError;
    createErrorFromCodeLookup.set(149, () => new MissingSplTokenProgramError());
    createErrorFromNameLookup.set("MissingSplTokenProgram", () => new MissingSplTokenProgramError());
    var MissingAuthorizationRulesProgramError = class _MissingAuthorizationRulesProgramError extends Error {
      constructor() {
        super("Missing authorization rules program");
        this.code = 150;
        this.name = "MissingAuthorizationRulesProgram";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingAuthorizationRulesProgramError);
        }
      }
    };
    exports.MissingAuthorizationRulesProgramError = MissingAuthorizationRulesProgramError;
    createErrorFromCodeLookup.set(150, () => new MissingAuthorizationRulesProgramError());
    createErrorFromNameLookup.set("MissingAuthorizationRulesProgram", () => new MissingAuthorizationRulesProgramError());
    var InvalidDelegateRoleForTransferError = class _InvalidDelegateRoleForTransferError extends Error {
      constructor() {
        super("Invalid delegate role for transfer");
        this.code = 151;
        this.name = "InvalidDelegateRoleForTransfer";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidDelegateRoleForTransferError);
        }
      }
    };
    exports.InvalidDelegateRoleForTransferError = InvalidDelegateRoleForTransferError;
    createErrorFromCodeLookup.set(151, () => new InvalidDelegateRoleForTransferError());
    createErrorFromNameLookup.set("InvalidDelegateRoleForTransfer", () => new InvalidDelegateRoleForTransferError());
    var InvalidTransferAuthorityError = class _InvalidTransferAuthorityError extends Error {
      constructor() {
        super("Invalid transfer authority");
        this.code = 152;
        this.name = "InvalidTransferAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidTransferAuthorityError);
        }
      }
    };
    exports.InvalidTransferAuthorityError = InvalidTransferAuthorityError;
    createErrorFromCodeLookup.set(152, () => new InvalidTransferAuthorityError());
    createErrorFromNameLookup.set("InvalidTransferAuthority", () => new InvalidTransferAuthorityError());
    var InstructionNotSupportedError = class _InstructionNotSupportedError extends Error {
      constructor() {
        super("Instruction not supported for ProgrammableNonFungible assets");
        this.code = 153;
        this.name = "InstructionNotSupported";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InstructionNotSupportedError);
        }
      }
    };
    exports.InstructionNotSupportedError = InstructionNotSupportedError;
    createErrorFromCodeLookup.set(153, () => new InstructionNotSupportedError());
    createErrorFromNameLookup.set("InstructionNotSupported", () => new InstructionNotSupportedError());
    var KeyMismatchError = class _KeyMismatchError extends Error {
      constructor() {
        super("Public key does not match expected value");
        this.code = 154;
        this.name = "KeyMismatch";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _KeyMismatchError);
        }
      }
    };
    exports.KeyMismatchError = KeyMismatchError;
    createErrorFromCodeLookup.set(154, () => new KeyMismatchError());
    createErrorFromNameLookup.set("KeyMismatch", () => new KeyMismatchError());
    var LockedTokenError = class _LockedTokenError extends Error {
      constructor() {
        super("Token is locked");
        this.code = 155;
        this.name = "LockedToken";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _LockedTokenError);
        }
      }
    };
    exports.LockedTokenError = LockedTokenError;
    createErrorFromCodeLookup.set(155, () => new LockedTokenError());
    createErrorFromNameLookup.set("LockedToken", () => new LockedTokenError());
    var UnlockedTokenError = class _UnlockedTokenError extends Error {
      constructor() {
        super("Token is unlocked");
        this.code = 156;
        this.name = "UnlockedToken";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UnlockedTokenError);
        }
      }
    };
    exports.UnlockedTokenError = UnlockedTokenError;
    createErrorFromCodeLookup.set(156, () => new UnlockedTokenError());
    createErrorFromNameLookup.set("UnlockedToken", () => new UnlockedTokenError());
    var MissingDelegateRoleError = class _MissingDelegateRoleError extends Error {
      constructor() {
        super("Missing delegate role");
        this.code = 157;
        this.name = "MissingDelegateRole";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingDelegateRoleError);
        }
      }
    };
    exports.MissingDelegateRoleError = MissingDelegateRoleError;
    createErrorFromCodeLookup.set(157, () => new MissingDelegateRoleError());
    createErrorFromNameLookup.set("MissingDelegateRole", () => new MissingDelegateRoleError());
    var InvalidAuthorityTypeError = class _InvalidAuthorityTypeError extends Error {
      constructor() {
        super("Invalid authority type");
        this.code = 158;
        this.name = "InvalidAuthorityType";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidAuthorityTypeError);
        }
      }
    };
    exports.InvalidAuthorityTypeError = InvalidAuthorityTypeError;
    createErrorFromCodeLookup.set(158, () => new InvalidAuthorityTypeError());
    createErrorFromNameLookup.set("InvalidAuthorityType", () => new InvalidAuthorityTypeError());
    var MissingTokenRecordError = class _MissingTokenRecordError extends Error {
      constructor() {
        super("Missing token record account");
        this.code = 159;
        this.name = "MissingTokenRecord";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingTokenRecordError);
        }
      }
    };
    exports.MissingTokenRecordError = MissingTokenRecordError;
    createErrorFromCodeLookup.set(159, () => new MissingTokenRecordError());
    createErrorFromNameLookup.set("MissingTokenRecord", () => new MissingTokenRecordError());
    var MintSupplyMustBeZeroError = class _MintSupplyMustBeZeroError extends Error {
      constructor() {
        super("Mint supply must be zero for programmable assets");
        this.code = 160;
        this.name = "MintSupplyMustBeZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MintSupplyMustBeZeroError);
        }
      }
    };
    exports.MintSupplyMustBeZeroError = MintSupplyMustBeZeroError;
    createErrorFromCodeLookup.set(160, () => new MintSupplyMustBeZeroError());
    createErrorFromNameLookup.set("MintSupplyMustBeZero", () => new MintSupplyMustBeZeroError());
    var DataIsEmptyOrZeroedError = class _DataIsEmptyOrZeroedError extends Error {
      constructor() {
        super("Data is empty or zeroed");
        this.code = 161;
        this.name = "DataIsEmptyOrZeroed";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DataIsEmptyOrZeroedError);
        }
      }
    };
    exports.DataIsEmptyOrZeroedError = DataIsEmptyOrZeroedError;
    createErrorFromCodeLookup.set(161, () => new DataIsEmptyOrZeroedError());
    createErrorFromNameLookup.set("DataIsEmptyOrZeroed", () => new DataIsEmptyOrZeroedError());
    var MissingTokenOwnerAccountError = class _MissingTokenOwnerAccountError extends Error {
      constructor() {
        super("Missing token owner");
        this.code = 162;
        this.name = "MissingTokenOwnerAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingTokenOwnerAccountError);
        }
      }
    };
    exports.MissingTokenOwnerAccountError = MissingTokenOwnerAccountError;
    createErrorFromCodeLookup.set(162, () => new MissingTokenOwnerAccountError());
    createErrorFromNameLookup.set("MissingTokenOwnerAccount", () => new MissingTokenOwnerAccountError());
    var InvalidMasterEditionAccountLengthError = class _InvalidMasterEditionAccountLengthError extends Error {
      constructor() {
        super("Master edition account has an invalid length");
        this.code = 163;
        this.name = "InvalidMasterEditionAccountLength";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMasterEditionAccountLengthError);
        }
      }
    };
    exports.InvalidMasterEditionAccountLengthError = InvalidMasterEditionAccountLengthError;
    createErrorFromCodeLookup.set(163, () => new InvalidMasterEditionAccountLengthError());
    createErrorFromNameLookup.set("InvalidMasterEditionAccountLength", () => new InvalidMasterEditionAccountLengthError());
    var IncorrectTokenStateError = class _IncorrectTokenStateError extends Error {
      constructor() {
        super("Incorrect token state");
        this.code = 164;
        this.name = "IncorrectTokenState";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _IncorrectTokenStateError);
        }
      }
    };
    exports.IncorrectTokenStateError = IncorrectTokenStateError;
    createErrorFromCodeLookup.set(164, () => new IncorrectTokenStateError());
    createErrorFromNameLookup.set("IncorrectTokenState", () => new IncorrectTokenStateError());
    var InvalidDelegateRoleError = class _InvalidDelegateRoleError extends Error {
      constructor() {
        super("Invalid delegate role");
        this.code = 165;
        this.name = "InvalidDelegateRole";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidDelegateRoleError);
        }
      }
    };
    exports.InvalidDelegateRoleError = InvalidDelegateRoleError;
    createErrorFromCodeLookup.set(165, () => new InvalidDelegateRoleError());
    createErrorFromNameLookup.set("InvalidDelegateRole", () => new InvalidDelegateRoleError());
    var MissingPrintSupplyError = class _MissingPrintSupplyError extends Error {
      constructor() {
        super("Print supply is required for non-fungibles");
        this.code = 166;
        this.name = "MissingPrintSupply";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingPrintSupplyError);
        }
      }
    };
    exports.MissingPrintSupplyError = MissingPrintSupplyError;
    createErrorFromCodeLookup.set(166, () => new MissingPrintSupplyError());
    createErrorFromNameLookup.set("MissingPrintSupply", () => new MissingPrintSupplyError());
    var MissingMasterEditionAccountError = class _MissingMasterEditionAccountError extends Error {
      constructor() {
        super("Missing master edition account");
        this.code = 167;
        this.name = "MissingMasterEditionAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingMasterEditionAccountError);
        }
      }
    };
    exports.MissingMasterEditionAccountError = MissingMasterEditionAccountError;
    createErrorFromCodeLookup.set(167, () => new MissingMasterEditionAccountError());
    createErrorFromNameLookup.set("MissingMasterEditionAccount", () => new MissingMasterEditionAccountError());
    var AmountMustBeGreaterThanZeroError = class _AmountMustBeGreaterThanZeroError extends Error {
      constructor() {
        super("Amount must be greater than zero");
        this.code = 168;
        this.name = "AmountMustBeGreaterThanZero";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AmountMustBeGreaterThanZeroError);
        }
      }
    };
    exports.AmountMustBeGreaterThanZeroError = AmountMustBeGreaterThanZeroError;
    createErrorFromCodeLookup.set(168, () => new AmountMustBeGreaterThanZeroError());
    createErrorFromNameLookup.set("AmountMustBeGreaterThanZero", () => new AmountMustBeGreaterThanZeroError());
    var InvalidDelegateArgsError = class _InvalidDelegateArgsError extends Error {
      constructor() {
        super("Invalid delegate args");
        this.code = 169;
        this.name = "InvalidDelegateArgs";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidDelegateArgsError);
        }
      }
    };
    exports.InvalidDelegateArgsError = InvalidDelegateArgsError;
    createErrorFromCodeLookup.set(169, () => new InvalidDelegateArgsError());
    createErrorFromNameLookup.set("InvalidDelegateArgs", () => new InvalidDelegateArgsError());
    var MissingLockedTransferAddressError = class _MissingLockedTransferAddressError extends Error {
      constructor() {
        super("Missing address for locked transfer");
        this.code = 170;
        this.name = "MissingLockedTransferAddress";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingLockedTransferAddressError);
        }
      }
    };
    exports.MissingLockedTransferAddressError = MissingLockedTransferAddressError;
    createErrorFromCodeLookup.set(170, () => new MissingLockedTransferAddressError());
    createErrorFromNameLookup.set("MissingLockedTransferAddress", () => new MissingLockedTransferAddressError());
    var InvalidLockedTransferAddressError = class _InvalidLockedTransferAddressError extends Error {
      constructor() {
        super("Invalid destination address for locked transfer");
        this.code = 171;
        this.name = "InvalidLockedTransferAddress";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidLockedTransferAddressError);
        }
      }
    };
    exports.InvalidLockedTransferAddressError = InvalidLockedTransferAddressError;
    createErrorFromCodeLookup.set(171, () => new InvalidLockedTransferAddressError());
    createErrorFromNameLookup.set("InvalidLockedTransferAddress", () => new InvalidLockedTransferAddressError());
    var DataIncrementLimitExceededError = class _DataIncrementLimitExceededError extends Error {
      constructor() {
        super("Exceeded account realloc increase limit");
        this.code = 172;
        this.name = "DataIncrementLimitExceeded";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _DataIncrementLimitExceededError);
        }
      }
    };
    exports.DataIncrementLimitExceededError = DataIncrementLimitExceededError;
    createErrorFromCodeLookup.set(172, () => new DataIncrementLimitExceededError());
    createErrorFromNameLookup.set("DataIncrementLimitExceeded", () => new DataIncrementLimitExceededError());
    var CannotUpdateAssetWithDelegateError = class _CannotUpdateAssetWithDelegateError extends Error {
      constructor() {
        super("Cannot update the rule set of a programmable asset that has a delegate");
        this.code = 173;
        this.name = "CannotUpdateAssetWithDelegate";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotUpdateAssetWithDelegateError);
        }
      }
    };
    exports.CannotUpdateAssetWithDelegateError = CannotUpdateAssetWithDelegateError;
    createErrorFromCodeLookup.set(173, () => new CannotUpdateAssetWithDelegateError());
    createErrorFromNameLookup.set("CannotUpdateAssetWithDelegate", () => new CannotUpdateAssetWithDelegateError());
    var InvalidAmountError = class _InvalidAmountError extends Error {
      constructor() {
        super("Invalid token amount for this operation or token standard");
        this.code = 174;
        this.name = "InvalidAmount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidAmountError);
        }
      }
    };
    exports.InvalidAmountError = InvalidAmountError;
    createErrorFromCodeLookup.set(174, () => new InvalidAmountError());
    createErrorFromNameLookup.set("InvalidAmount", () => new InvalidAmountError());
    var MissingMasterEditionMintAccountError = class _MissingMasterEditionMintAccountError extends Error {
      constructor() {
        super("Missing master edition mint account");
        this.code = 175;
        this.name = "MissingMasterEditionMintAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingMasterEditionMintAccountError);
        }
      }
    };
    exports.MissingMasterEditionMintAccountError = MissingMasterEditionMintAccountError;
    createErrorFromCodeLookup.set(175, () => new MissingMasterEditionMintAccountError());
    createErrorFromNameLookup.set("MissingMasterEditionMintAccount", () => new MissingMasterEditionMintAccountError());
    var MissingMasterEditionTokenAccountError = class _MissingMasterEditionTokenAccountError extends Error {
      constructor() {
        super("Missing master edition token account");
        this.code = 176;
        this.name = "MissingMasterEditionTokenAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingMasterEditionTokenAccountError);
        }
      }
    };
    exports.MissingMasterEditionTokenAccountError = MissingMasterEditionTokenAccountError;
    createErrorFromCodeLookup.set(176, () => new MissingMasterEditionTokenAccountError());
    createErrorFromNameLookup.set("MissingMasterEditionTokenAccount", () => new MissingMasterEditionTokenAccountError());
    var MissingEditionMarkerAccountError = class _MissingEditionMarkerAccountError extends Error {
      constructor() {
        super("Missing edition marker account");
        this.code = 177;
        this.name = "MissingEditionMarkerAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingEditionMarkerAccountError);
        }
      }
    };
    exports.MissingEditionMarkerAccountError = MissingEditionMarkerAccountError;
    createErrorFromCodeLookup.set(177, () => new MissingEditionMarkerAccountError());
    createErrorFromNameLookup.set("MissingEditionMarkerAccount", () => new MissingEditionMarkerAccountError());
    var CannotBurnWithDelegateError = class _CannotBurnWithDelegateError extends Error {
      constructor() {
        super("Cannot burn while persistent delegate is set");
        this.code = 178;
        this.name = "CannotBurnWithDelegate";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _CannotBurnWithDelegateError);
        }
      }
    };
    exports.CannotBurnWithDelegateError = CannotBurnWithDelegateError;
    createErrorFromCodeLookup.set(178, () => new CannotBurnWithDelegateError());
    createErrorFromNameLookup.set("CannotBurnWithDelegate", () => new CannotBurnWithDelegateError());
    var MissingEditionError = class _MissingEditionError extends Error {
      constructor() {
        super("Missing edition account");
        this.code = 179;
        this.name = "MissingEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingEditionError);
        }
      }
    };
    exports.MissingEditionError = MissingEditionError;
    createErrorFromCodeLookup.set(179, () => new MissingEditionError());
    createErrorFromNameLookup.set("MissingEdition", () => new MissingEditionError());
    var InvalidAssociatedTokenAccountProgramError = class _InvalidAssociatedTokenAccountProgramError extends Error {
      constructor() {
        super("Invalid Associated Token Account Program");
        this.code = 180;
        this.name = "InvalidAssociatedTokenAccountProgram";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidAssociatedTokenAccountProgramError);
        }
      }
    };
    exports.InvalidAssociatedTokenAccountProgramError = InvalidAssociatedTokenAccountProgramError;
    createErrorFromCodeLookup.set(180, () => new InvalidAssociatedTokenAccountProgramError());
    createErrorFromNameLookup.set("InvalidAssociatedTokenAccountProgram", () => new InvalidAssociatedTokenAccountProgramError());
    var InvalidInstructionsSysvarError = class _InvalidInstructionsSysvarError extends Error {
      constructor() {
        super("Invalid InstructionsSysvar");
        this.code = 181;
        this.name = "InvalidInstructionsSysvar";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidInstructionsSysvarError);
        }
      }
    };
    exports.InvalidInstructionsSysvarError = InvalidInstructionsSysvarError;
    createErrorFromCodeLookup.set(181, () => new InvalidInstructionsSysvarError());
    createErrorFromNameLookup.set("InvalidInstructionsSysvar", () => new InvalidInstructionsSysvarError());
    var InvalidParentAccountsError = class _InvalidParentAccountsError extends Error {
      constructor() {
        super("Invalid or Unneeded parent accounts");
        this.code = 182;
        this.name = "InvalidParentAccounts";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidParentAccountsError);
        }
      }
    };
    exports.InvalidParentAccountsError = InvalidParentAccountsError;
    createErrorFromCodeLookup.set(182, () => new InvalidParentAccountsError());
    createErrorFromNameLookup.set("InvalidParentAccounts", () => new InvalidParentAccountsError());
    var InvalidUpdateArgsError = class _InvalidUpdateArgsError extends Error {
      constructor() {
        super("Authority cannot apply all update args");
        this.code = 183;
        this.name = "InvalidUpdateArgs";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidUpdateArgsError);
        }
      }
    };
    exports.InvalidUpdateArgsError = InvalidUpdateArgsError;
    createErrorFromCodeLookup.set(183, () => new InvalidUpdateArgsError());
    createErrorFromNameLookup.set("InvalidUpdateArgs", () => new InvalidUpdateArgsError());
    var InsufficientTokenBalanceError = class _InsufficientTokenBalanceError extends Error {
      constructor() {
        super("Token account does not have enough tokens");
        this.code = 184;
        this.name = "InsufficientTokenBalance";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InsufficientTokenBalanceError);
        }
      }
    };
    exports.InsufficientTokenBalanceError = InsufficientTokenBalanceError;
    createErrorFromCodeLookup.set(184, () => new InsufficientTokenBalanceError());
    createErrorFromNameLookup.set("InsufficientTokenBalance", () => new InsufficientTokenBalanceError());
    var MissingCollectionMintError = class _MissingCollectionMintError extends Error {
      constructor() {
        super("Missing collection account");
        this.code = 185;
        this.name = "MissingCollectionMint";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingCollectionMintError);
        }
      }
    };
    exports.MissingCollectionMintError = MissingCollectionMintError;
    createErrorFromCodeLookup.set(185, () => new MissingCollectionMintError());
    createErrorFromNameLookup.set("MissingCollectionMint", () => new MissingCollectionMintError());
    var MissingCollectionMasterEditionError = class _MissingCollectionMasterEditionError extends Error {
      constructor() {
        super("Missing collection master edition account");
        this.code = 186;
        this.name = "MissingCollectionMasterEdition";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingCollectionMasterEditionError);
        }
      }
    };
    exports.MissingCollectionMasterEditionError = MissingCollectionMasterEditionError;
    createErrorFromCodeLookup.set(186, () => new MissingCollectionMasterEditionError());
    createErrorFromNameLookup.set("MissingCollectionMasterEdition", () => new MissingCollectionMasterEditionError());
    var InvalidTokenRecordError = class _InvalidTokenRecordError extends Error {
      constructor() {
        super("Invalid token record account");
        this.code = 187;
        this.name = "InvalidTokenRecord";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidTokenRecordError);
        }
      }
    };
    exports.InvalidTokenRecordError = InvalidTokenRecordError;
    createErrorFromCodeLookup.set(187, () => new InvalidTokenRecordError());
    createErrorFromNameLookup.set("InvalidTokenRecord", () => new InvalidTokenRecordError());
    var InvalidCloseAuthorityError = class _InvalidCloseAuthorityError extends Error {
      constructor() {
        super("The close authority needs to be revoked by the Utility Delegate");
        this.code = 188;
        this.name = "InvalidCloseAuthority";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidCloseAuthorityError);
        }
      }
    };
    exports.InvalidCloseAuthorityError = InvalidCloseAuthorityError;
    createErrorFromCodeLookup.set(188, () => new InvalidCloseAuthorityError());
    createErrorFromNameLookup.set("InvalidCloseAuthority", () => new InvalidCloseAuthorityError());
    var InvalidInstructionError = class _InvalidInstructionError extends Error {
      constructor() {
        super("Invalid or removed instruction");
        this.code = 189;
        this.name = "InvalidInstruction";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidInstructionError);
        }
      }
    };
    exports.InvalidInstructionError = InvalidInstructionError;
    createErrorFromCodeLookup.set(189, () => new InvalidInstructionError());
    createErrorFromNameLookup.set("InvalidInstruction", () => new InvalidInstructionError());
    var MissingDelegateRecordError = class _MissingDelegateRecordError extends Error {
      constructor() {
        super("Missing delegate record");
        this.code = 190;
        this.name = "MissingDelegateRecord";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _MissingDelegateRecordError);
        }
      }
    };
    exports.MissingDelegateRecordError = MissingDelegateRecordError;
    createErrorFromCodeLookup.set(190, () => new MissingDelegateRecordError());
    createErrorFromNameLookup.set("MissingDelegateRecord", () => new MissingDelegateRecordError());
    var InvalidFeeAccountError = class _InvalidFeeAccountError extends Error {
      constructor() {
        super("");
        this.code = 191;
        this.name = "InvalidFeeAccount";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidFeeAccountError);
        }
      }
    };
    exports.InvalidFeeAccountError = InvalidFeeAccountError;
    createErrorFromCodeLookup.set(191, () => new InvalidFeeAccountError());
    createErrorFromNameLookup.set("InvalidFeeAccount", () => new InvalidFeeAccountError());
    var InvalidMetadataFlagsError = class _InvalidMetadataFlagsError extends Error {
      constructor() {
        super("");
        this.code = 192;
        this.name = "InvalidMetadataFlags";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidMetadataFlagsError);
        }
      }
    };
    exports.InvalidMetadataFlagsError = InvalidMetadataFlagsError;
    createErrorFromCodeLookup.set(192, () => new InvalidMetadataFlagsError());
    createErrorFromNameLookup.set("InvalidMetadataFlags", () => new InvalidMetadataFlagsError());
    function errorFromCode(code) {
      const createError = createErrorFromCodeLookup.get(code);
      return createError != null ? createError() : null;
    }
    exports.errorFromCode = errorFromCode;
    function errorFromName(name) {
      const createError = createErrorFromNameLookup.get(name);
      return createError != null ? createError() : null;
    }
    exports.errorFromName = errorFromName;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ApproveCollectionAuthority.js
var require_ApproveCollectionAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ApproveCollectionAuthority.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createApproveCollectionAuthorityInstruction = exports.approveCollectionAuthorityInstructionDiscriminator = exports.ApproveCollectionAuthorityStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.ApproveCollectionAuthorityStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "ApproveCollectionAuthorityInstructionArgs");
    exports.approveCollectionAuthorityInstructionDiscriminator = 23;
    function createApproveCollectionAuthorityInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.ApproveCollectionAuthorityStruct.serialize({
        instructionDiscriminator: exports.approveCollectionAuthorityInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newCollectionAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createApproveCollectionAuthorityInstruction = createApproveCollectionAuthorityInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/constants.js
var require_constants = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.programSupportsExtensions = exports.NATIVE_MINT_2022 = exports.NATIVE_MINT = exports.ASSOCIATED_TOKEN_PROGRAM_ID = exports.TOKEN_2022_PROGRAM_ID = exports.TOKEN_PROGRAM_ID = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    exports.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    exports.TOKEN_2022_PROGRAM_ID = new web3_js_1.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
    exports.ASSOCIATED_TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
    exports.NATIVE_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
    exports.NATIVE_MINT_2022 = new web3_js_1.PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
    function programSupportsExtensions(programId) {
      if (programId === exports.TOKEN_PROGRAM_ID) {
        return false;
      } else {
        return true;
      }
    }
    exports.programSupportsExtensions = programSupportsExtensions;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/base.js
var require_base = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDecode = void 0;
    var encodeDecode = (layout) => {
      const decode = layout.decode.bind(layout);
      const encode = layout.encode.bind(layout);
      return { decode, encode };
    };
    exports.encodeDecode = encodeDecode;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js
var require_bigint = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.u256be = exports.u256 = exports.u192be = exports.u192 = exports.u128be = exports.u128 = exports.u64be = exports.u64 = exports.bigIntBE = exports.bigInt = void 0;
    var buffer_layout_1 = require_Layout();
    var bigint_buffer_1 = require_browser();
    var base_1 = require_base();
    var bigInt = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return (0, bigint_buffer_1.toBigIntLE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt2, buffer, offset) => {
        const src = (0, bigint_buffer_1.toBufferLE)(bigInt2, length);
        return encode(src, buffer, offset);
      };
      return bigIntLayout;
    };
    exports.bigInt = bigInt;
    var bigIntBE = (length) => (property) => {
      const layout = (0, buffer_layout_1.blob)(length, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const bigIntLayout = layout;
      bigIntLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return (0, bigint_buffer_1.toBigIntBE)(Buffer.from(src));
      };
      bigIntLayout.encode = (bigInt2, buffer, offset) => {
        const src = (0, bigint_buffer_1.toBufferBE)(bigInt2, length);
        return encode(src, buffer, offset);
      };
      return bigIntLayout;
    };
    exports.bigIntBE = bigIntBE;
    exports.u64 = (0, exports.bigInt)(8);
    exports.u64be = (0, exports.bigIntBE)(8);
    exports.u128 = (0, exports.bigInt)(16);
    exports.u128be = (0, exports.bigIntBE)(16);
    exports.u192 = (0, exports.bigInt)(24);
    exports.u192be = (0, exports.bigIntBE)(24);
    exports.u256 = (0, exports.bigInt)(32);
    exports.u256be = (0, exports.bigIntBE)(32);
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js
var require_decimal = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/decimal.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decimal = exports.WAD = void 0;
    var bignumber_js_1 = __importDefault(require_bignumber());
    var base_1 = require_base();
    var bigint_1 = require_bigint();
    exports.WAD = new bignumber_js_1.default("1e+18");
    var decimal = (property) => {
      const layout = (0, bigint_1.u128)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const decimalLayout = layout;
      decimalLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset).toString();
        return new bignumber_js_1.default(src).div(exports.WAD);
      };
      decimalLayout.encode = (decimal2, buffer, offset) => {
        const src = BigInt(decimal2.times(exports.WAD).integerValue().toString());
        return encode(src, buffer, offset);
      };
      return decimalLayout;
    };
    exports.decimal = decimal;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/native.js
var require_native = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/native.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bool = void 0;
    var buffer_layout_1 = require_Layout();
    var base_1 = require_base();
    var bool = (property) => {
      const layout = (0, buffer_layout_1.u8)(property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const boolLayout = layout;
      boolLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return !!src;
      };
      boolLayout.encode = (bool2, buffer, offset) => {
        const src = Number(bool2);
        return encode(src, buffer, offset);
      };
      return boolLayout;
    };
    exports.bool = bool;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js
var require_web3 = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/web3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKey = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var base_1 = require_base();
    var publicKey = (property) => {
      const layout = (0, buffer_layout_1.blob)(32, property);
      const { encode, decode } = (0, base_1.encodeDecode)(layout);
      const publicKeyLayout = layout;
      publicKeyLayout.decode = (buffer, offset) => {
        const src = decode(buffer, offset);
        return new web3_js_1.PublicKey(src);
      };
      publicKeyLayout.encode = (publicKey2, buffer, offset) => {
        const src = publicKey2.toBuffer();
        return encode(src, buffer, offset);
      };
      return publicKeyLayout;
    };
    exports.publicKey = publicKey;
  }
});

// node_modules/@solana/buffer-layout-utils/lib/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@solana/buffer-layout-utils/lib/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_base(), exports);
    __exportStar(require_bigint(), exports);
    __exportStar(require_decimal(), exports);
    __exportStar(require_native(), exports);
    __exportStar(require_web3(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/errors.js
var require_errors2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenTransferHookAccountDataNotFound = exports.TokenTransferHookInvalidSeed = exports.TokenTransferHookAccountNotFound = exports.TokenUnsupportedInstructionError = exports.TokenInvalidInstructionTypeError = exports.TokenInvalidInstructionDataError = exports.TokenInvalidInstructionKeysError = exports.TokenInvalidInstructionProgramError = exports.TokenOwnerOffCurveError = exports.TokenInvalidOwnerError = exports.TokenInvalidMintError = exports.TokenInvalidAccountSizeError = exports.TokenInvalidAccountOwnerError = exports.TokenInvalidAccountDataError = exports.TokenInvalidAccountError = exports.TokenAccountNotFoundError = exports.TokenError = void 0;
    var TokenError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TokenError = TokenError;
    var TokenAccountNotFoundError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenAccountNotFoundError";
      }
    };
    exports.TokenAccountNotFoundError = TokenAccountNotFoundError;
    var TokenInvalidAccountError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountError";
      }
    };
    exports.TokenInvalidAccountError = TokenInvalidAccountError;
    var TokenInvalidAccountDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountDataError";
      }
    };
    exports.TokenInvalidAccountDataError = TokenInvalidAccountDataError;
    var TokenInvalidAccountOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountOwnerError";
      }
    };
    exports.TokenInvalidAccountOwnerError = TokenInvalidAccountOwnerError;
    var TokenInvalidAccountSizeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidAccountSizeError";
      }
    };
    exports.TokenInvalidAccountSizeError = TokenInvalidAccountSizeError;
    var TokenInvalidMintError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidMintError";
      }
    };
    exports.TokenInvalidMintError = TokenInvalidMintError;
    var TokenInvalidOwnerError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidOwnerError";
      }
    };
    exports.TokenInvalidOwnerError = TokenInvalidOwnerError;
    var TokenOwnerOffCurveError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenOwnerOffCurveError";
      }
    };
    exports.TokenOwnerOffCurveError = TokenOwnerOffCurveError;
    var TokenInvalidInstructionProgramError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionProgramError";
      }
    };
    exports.TokenInvalidInstructionProgramError = TokenInvalidInstructionProgramError;
    var TokenInvalidInstructionKeysError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionKeysError";
      }
    };
    exports.TokenInvalidInstructionKeysError = TokenInvalidInstructionKeysError;
    var TokenInvalidInstructionDataError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionDataError";
      }
    };
    exports.TokenInvalidInstructionDataError = TokenInvalidInstructionDataError;
    var TokenInvalidInstructionTypeError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenInvalidInstructionTypeError";
      }
    };
    exports.TokenInvalidInstructionTypeError = TokenInvalidInstructionTypeError;
    var TokenUnsupportedInstructionError = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenUnsupportedInstructionError";
      }
    };
    exports.TokenUnsupportedInstructionError = TokenUnsupportedInstructionError;
    var TokenTransferHookAccountNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountNotFound";
      }
    };
    exports.TokenTransferHookAccountNotFound = TokenTransferHookAccountNotFound;
    var TokenTransferHookInvalidSeed = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookInvalidSeed";
      }
    };
    exports.TokenTransferHookInvalidSeed = TokenTransferHookInvalidSeed;
    var TokenTransferHookAccountDataNotFound = class extends TokenError {
      constructor() {
        super(...arguments);
        this.name = "TokenTransferHookAccountDataNotFound";
      }
    };
    exports.TokenTransferHookAccountDataNotFound = TokenTransferHookAccountDataNotFound;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/types.js
var require_types3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenInstruction = void 0;
    var TokenInstruction;
    (function(TokenInstruction2) {
      TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
      TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
      TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
      TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
      TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
      TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
      TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
      TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
      TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
      TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
      TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
      TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
      TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
      TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
      TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
      TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
      TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
      TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
      TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
      TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
      TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
      TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
      TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
      TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
      TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
      TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
      TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
      TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
      TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
      TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
      TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
      TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
      TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
      TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
      TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
      TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
      TokenInstruction2[TokenInstruction2["TransferHookExtension"] = 36] = "TransferHookExtension";
      TokenInstruction2[TokenInstruction2["MetadataPointerExtension"] = 39] = "MetadataPointerExtension";
    })(TokenInstruction || (exports.TokenInstruction = TokenInstruction = {}));
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js
var require_amountToUiAmount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/amountToUiAmount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeAmountToUiAmountInstructionUnchecked = exports.decodeAmountToUiAmountInstruction = exports.createAmountToUiAmountInstruction = exports.amountToUiAmountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.amountToUiAmountInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount")
    ]);
    function createAmountToUiAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const data = Buffer.alloc(exports.amountToUiAmountInstructionData.span);
      exports.amountToUiAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.AmountToUiAmount,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createAmountToUiAmountInstruction = createAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.amountToUiAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeAmountToUiAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.AmountToUiAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeAmountToUiAmountInstruction = decodeAmountToUiAmountInstruction;
    function decodeAmountToUiAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      return {
        programId,
        keys: {
          mint
        },
        data: exports.amountToUiAmountInstructionData.decode(data)
      };
    }
    exports.decodeAmountToUiAmountInstructionUnchecked = decodeAmountToUiAmountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js
var require_amountToUiAmount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/amountToUiAmount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.amountToUiAmount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    function amountToUiAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, amountToUiAmount_js_1.createAmountToUiAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData === null || returnData === void 0 ? void 0 : returnData.data) {
          return Buffer.from(returnData.data[0], returnData.data[1]).toString("utf-8");
        }
        return err;
      });
    }
    exports.amountToUiAmount = amountToUiAmount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/internal.js
var require_internal = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addSigners = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    function addSigners(keys, ownerOrAuthority, multiSigners) {
      if (multiSigners.length) {
        keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
        for (const signer of multiSigners) {
          keys.push({
            pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
            isSigner: true,
            isWritable: false
          });
        }
      } else {
        keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
      }
      return keys;
    }
    exports.addSigners = addSigners;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/approve.js
var require_approve = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/approve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeApproveInstructionUnchecked = exports.decodeApproveInstruction = exports.createApproveInstruction = exports.approveInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.approveInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createApproveInstruction(account, delegate, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.approveInstructionData.span);
      exports.approveInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Approve,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createApproveInstruction = createApproveInstruction;
    function decodeApproveInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.approveInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, delegate, owner, multiSigners }, data } = decodeApproveInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Approve)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeApproveInstruction = decodeApproveInstruction;
    function decodeApproveInstructionUnchecked({ programId, keys: [account, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          delegate,
          owner,
          multiSigners
        },
        data: exports.approveInstructionData.decode(data)
      };
    }
    exports.decodeApproveInstructionUnchecked = decodeApproveInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/internal.js
var require_internal2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/internal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSigners = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    function getSigners(signerOrMultisig, multiSigners) {
      return signerOrMultisig instanceof web3_js_1.PublicKey ? [signerOrMultisig, multiSigners] : [signerOrMultisig.publicKey, [signerOrMultisig]];
    }
    exports.getSigners = getSigners;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/approve.js
var require_approve2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/approve.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.approve = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var approve_js_1 = require_approve();
    var internal_js_1 = require_internal2();
    function approve(connection, payer, account, delegate, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approve_js_1.createApproveInstruction)(account, delegate, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.approve = approve;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js
var require_approveChecked = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/approveChecked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeApproveCheckedInstructionUnchecked = exports.decodeApproveCheckedInstruction = exports.createApproveCheckedInstruction = exports.approveCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.approveCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createApproveCheckedInstruction(account, mint, delegate, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: delegate, isSigner: false, isWritable: false }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.approveCheckedInstructionData.span);
      exports.approveCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.ApproveChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createApproveCheckedInstruction = createApproveCheckedInstruction;
    function decodeApproveCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.approveCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, delegate, owner, multiSigners }, data } = decodeApproveCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ApproveChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !delegate || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeApproveCheckedInstruction = decodeApproveCheckedInstruction;
    function decodeApproveCheckedInstructionUnchecked({ programId, keys: [account, mint, delegate, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          delegate,
          owner,
          multiSigners
        },
        data: exports.approveCheckedInstructionData.decode(data)
      };
    }
    exports.decodeApproveCheckedInstructionUnchecked = decodeApproveCheckedInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js
var require_approveChecked2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/approveChecked.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.approveChecked = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var approveChecked_js_1 = require_approveChecked();
    var internal_js_1 = require_internal2();
    function approveChecked(connection, payer, mint, account, delegate, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, approveChecked_js_1.createApproveCheckedInstruction)(account, mint, delegate, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.approveChecked = approveChecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/burn.js
var require_burn = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/burn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBurnInstructionUnchecked = exports.decodeBurnInstruction = exports.createBurnInstruction = exports.burnInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.burnInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createBurnInstruction(account, mint, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.burnInstructionData.span);
      exports.burnInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Burn,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createBurnInstruction = createBurnInstruction;
    function decodeBurnInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.burnInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Burn)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeBurnInstruction = decodeBurnInstruction;
    function decodeBurnInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports.burnInstructionData.decode(data)
      };
    }
    exports.decodeBurnInstructionUnchecked = decodeBurnInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/burn.js
var require_burn2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/burn.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.burn = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var burn_js_1 = require_burn();
    var internal_js_1 = require_internal2();
    function burn(connection, payer, account, mint, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burn_js_1.createBurnInstruction)(account, mint, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.burn = burn;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js
var require_burnChecked = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/burnChecked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBurnCheckedInstructionUnchecked = exports.decodeBurnCheckedInstruction = exports.createBurnCheckedInstruction = exports.burnCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.burnCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createBurnCheckedInstruction(account, mint, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.burnCheckedInstructionData.span);
      exports.burnCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.BurnChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createBurnCheckedInstruction = createBurnCheckedInstruction;
    function decodeBurnCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.burnCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, multiSigners }, data } = decodeBurnCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.BurnChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeBurnCheckedInstruction = decodeBurnCheckedInstruction;
    function decodeBurnCheckedInstructionUnchecked({ programId, keys: [account, mint, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          multiSigners
        },
        data: exports.burnCheckedInstructionData.decode(data)
      };
    }
    exports.decodeBurnCheckedInstructionUnchecked = decodeBurnCheckedInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js
var require_burnChecked2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/burnChecked.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.burnChecked = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var burnChecked_js_1 = require_burnChecked();
    var internal_js_1 = require_internal2();
    function burnChecked(connection, payer, account, mint, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, burnChecked_js_1.createBurnCheckedInstruction)(account, mint, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.burnChecked = burnChecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js
var require_closeAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/closeAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeCloseAccountInstructionUnchecked = exports.decodeCloseAccountInstruction = exports.createCloseAccountInstruction = exports.closeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.closeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCloseAccountInstruction(account, destination, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports.closeAccountInstructionData.span);
      exports.closeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.CloseAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createCloseAccountInstruction = createCloseAccountInstruction;
    function decodeCloseAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.closeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, destination, authority, multiSigners }, data } = decodeCloseAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.CloseAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports.decodeCloseAccountInstruction = decodeCloseAccountInstruction;
    function decodeCloseAccountInstructionUnchecked({ programId, keys: [account, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          destination,
          authority,
          multiSigners
        },
        data: exports.closeAccountInstructionData.decode(data)
      };
    }
    exports.decodeCloseAccountInstructionUnchecked = decodeCloseAccountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js
var require_closeAccount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/closeAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.closeAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var closeAccount_js_1 = require_closeAccount();
    var internal_js_1 = require_internal2();
    function closeAccount(connection, payer, account, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, closeAccount_js_1.createCloseAccountInstruction)(account, destination, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.closeAccount = closeAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js
var require_accountType = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/accountType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ACCOUNT_TYPE_SIZE = exports.AccountType = void 0;
    var AccountType;
    (function(AccountType2) {
      AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
      AccountType2[AccountType2["Mint"] = 1] = "Mint";
      AccountType2[AccountType2["Account"] = 2] = "Account";
    })(AccountType || (exports.AccountType = AccountType = {}));
    exports.ACCOUNT_TYPE_SIZE = 1;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/multisig.js
var require_multisig = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/multisig.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMinimumBalanceForRentExemptMultisig = exports.unpackMultisig = exports.getMultisig = exports.MULTISIG_SIZE = exports.MultisigLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    exports.MultisigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("m"),
      (0, buffer_layout_1.u8)("n"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_utils_1.publicKey)("signer1"),
      (0, buffer_layout_utils_1.publicKey)("signer2"),
      (0, buffer_layout_utils_1.publicKey)("signer3"),
      (0, buffer_layout_utils_1.publicKey)("signer4"),
      (0, buffer_layout_utils_1.publicKey)("signer5"),
      (0, buffer_layout_utils_1.publicKey)("signer6"),
      (0, buffer_layout_utils_1.publicKey)("signer7"),
      (0, buffer_layout_utils_1.publicKey)("signer8"),
      (0, buffer_layout_utils_1.publicKey)("signer9"),
      (0, buffer_layout_utils_1.publicKey)("signer10"),
      (0, buffer_layout_utils_1.publicKey)("signer11")
    ]);
    exports.MULTISIG_SIZE = exports.MultisigLayout.span;
    function getMultisig(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMultisig(address, info, programId);
      });
    }
    exports.getMultisig = getMultisig;
    function unpackMultisig(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length != exports.MULTISIG_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const multisig = exports.MultisigLayout.decode(info.data);
      return Object.assign({ address }, multisig);
    }
    exports.unpackMultisig = unpackMultisig;
    function getMinimumBalanceForRentExemptMultisig(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield connection.getMinimumBalanceForRentExemption(exports.MULTISIG_SIZE, commitment);
      });
    }
    exports.getMinimumBalanceForRentExemptMultisig = getMinimumBalanceForRentExemptMultisig;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/account.js
var require_account = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/account.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unpackAccount = exports.getMinimumBalanceForRentExemptAccountWithExtensions = exports.getMinimumBalanceForRentExemptAccount = exports.getMultipleAccounts = exports.getAccount = exports.ACCOUNT_SIZE = exports.AccountLayout = exports.AccountState = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var multisig_js_1 = require_multisig();
    var AccountState;
    (function(AccountState2) {
      AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
      AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
      AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
    })(AccountState || (exports.AccountState = AccountState = {}));
    exports.AccountLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("mint"),
      (0, buffer_layout_utils_1.publicKey)("owner"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u32)("delegateOption"),
      (0, buffer_layout_utils_1.publicKey)("delegate"),
      (0, buffer_layout_1.u8)("state"),
      (0, buffer_layout_1.u32)("isNativeOption"),
      (0, buffer_layout_utils_1.u64)("isNative"),
      (0, buffer_layout_utils_1.u64)("delegatedAmount"),
      (0, buffer_layout_1.u32)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    exports.ACCOUNT_SIZE = exports.AccountLayout.span;
    function getAccount(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackAccount(address, info, programId);
      });
    }
    exports.getAccount = getAccount;
    function getMultipleAccounts(connection, addresses, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const infos = yield connection.getMultipleAccountsInfo(addresses, commitment);
        return addresses.map((address, i) => unpackAccount(address, infos[i], programId));
      });
    }
    exports.getMultipleAccounts = getMultipleAccounts;
    function getMinimumBalanceForRentExemptAccount(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);
      });
    }
    exports.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;
    function getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const accountLen = (0, extensionType_js_1.getAccountLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(accountLen, commitment);
      });
    }
    exports.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;
    function unpackAccount(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports.ACCOUNT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawAccount = exports.AccountLayout.decode(info.data.slice(0, exports.ACCOUNT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports.ACCOUNT_SIZE) {
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[exports.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account)
          throw new errors_js_1.TokenInvalidAccountError();
        tlvData = info.data.slice(exports.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mint: rawAccount.mint,
        owner: rawAccount.owner,
        amount: rawAccount.amount,
        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
        delegatedAmount: rawAccount.delegatedAmount,
        isInitialized: rawAccount.state !== AccountState.Uninitialized,
        isFrozen: rawAccount.state === AccountState.Frozen,
        isNative: !!rawAccount.isNativeOption,
        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,
        tlvData
      };
    }
    exports.unpackAccount = unpackAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/mint.js
var require_mint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/mint.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAssociatedTokenAddressSync = exports.getAssociatedTokenAddress = exports.getMinimumBalanceForRentExemptMintWithExtensions = exports.getMinimumBalanceForRentExemptMint = exports.unpackMint = exports.getMint = exports.MINT_SIZE = exports.MintLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var accountType_js_1 = require_accountType();
    var extensionType_js_1 = require_extensionType();
    var account_js_1 = require_account();
    var multisig_js_1 = require_multisig();
    exports.MintLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("mintAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_utils_1.u64)("supply"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.bool)("isInitialized"),
      (0, buffer_layout_1.u32)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    exports.MINT_SIZE = exports.MintLayout.span;
    function getMint(connection, address, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address, commitment);
        return unpackMint(address, info, programId);
      });
    }
    exports.getMint = getMint;
    function unpackMint(address, info, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!info)
        throw new errors_js_1.TokenAccountNotFoundError();
      if (!info.owner.equals(programId))
        throw new errors_js_1.TokenInvalidAccountOwnerError();
      if (info.data.length < exports.MINT_SIZE)
        throw new errors_js_1.TokenInvalidAccountSizeError();
      const rawMint = exports.MintLayout.decode(info.data.slice(0, exports.MINT_SIZE));
      let tlvData = Buffer.alloc(0);
      if (info.data.length > exports.MINT_SIZE) {
        if (info.data.length <= account_js_1.ACCOUNT_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data.length === multisig_js_1.MULTISIG_SIZE)
          throw new errors_js_1.TokenInvalidAccountSizeError();
        if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint)
          throw new errors_js_1.TokenInvalidMintError();
        tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);
      }
      return {
        address,
        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
        supply: rawMint.supply,
        decimals: rawMint.decimals,
        isInitialized: rawMint.isInitialized,
        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
        tlvData
      };
    }
    exports.unpackMint = unpackMint;
    function getMinimumBalanceForRentExemptMint(connection, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);
      });
    }
    exports.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;
    function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)(extensions);
        return yield connection.getMinimumBalanceForRentExemption(mintLen, commitment);
      });
    }
    exports.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;
    function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
          throw new errors_js_1.TokenOwnerOffCurveError();
        const [address] = yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
        return address;
      });
    }
    exports.getAssociatedTokenAddress = getAssociatedTokenAddress;
    function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))
        throw new errors_js_1.TokenOwnerOffCurveError();
      const [address] = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
      return address;
    }
    exports.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js
var require_instructions = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDisableCpiGuardInstruction = exports.createEnableCpiGuardInstruction = exports.cpiGuardInstructionData = exports.CpiGuardInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var CpiGuardInstruction;
    (function(CpiGuardInstruction2) {
      CpiGuardInstruction2[CpiGuardInstruction2["Enable"] = 0] = "Enable";
      CpiGuardInstruction2[CpiGuardInstruction2["Disable"] = 1] = "Disable";
    })(CpiGuardInstruction || (exports.CpiGuardInstruction = CpiGuardInstruction = {}));
    exports.cpiGuardInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_1.u8)("cpiGuardInstruction")]);
    function createEnableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports.createEnableCpiGuardInstruction = createEnableCpiGuardInstruction;
    function createDisableCpiGuardInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createCpiGuardInstruction(CpiGuardInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports.createDisableCpiGuardInstruction = createDisableCpiGuardInstruction;
    function createCpiGuardInstruction(cpiGuardInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports.cpiGuardInstructionData.span);
      exports.cpiGuardInstructionData.encode({
        instruction: types_js_1.TokenInstruction.CpiGuardExtension,
        cpiGuardInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js
var require_actions = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.disableCpiGuard = exports.enableCpiGuard = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions();
    function enableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.enableCpiGuard = enableCpiGuard;
    function disableCpiGuard(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableCpiGuardInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.disableCpiGuard = disableCpiGuard;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js
var require_state = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCpiGuard = exports.CPI_GUARD_SIZE = exports.CpiGuardLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.CpiGuardLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("lockCpi")]);
    exports.CPI_GUARD_SIZE = exports.CpiGuardLayout.span;
    function getCpiGuard(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.CpiGuard, account.tlvData);
      if (extensionData !== null) {
        return exports.CpiGuardLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getCpiGuard = getCpiGuard;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js
var require_cpiGuard = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/cpiGuard/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions(), exports);
    __exportStar(require_instructions(), exports);
    __exportStar(require_state(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js
var require_instructions2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateDefaultAccountStateInstruction = exports.createInitializeDefaultAccountStateInstruction = exports.defaultAccountStateInstructionData = exports.DefaultAccountStateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var DefaultAccountStateInstruction;
    (function(DefaultAccountStateInstruction2) {
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Initialize"] = 0] = "Initialize";
      DefaultAccountStateInstruction2[DefaultAccountStateInstruction2["Update"] = 1] = "Update";
    })(DefaultAccountStateInstruction || (exports.DefaultAccountStateInstruction = DefaultAccountStateInstruction = {}));
    exports.defaultAccountStateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("defaultAccountStateInstruction"),
      (0, buffer_layout_1.u8)("accountState")
    ]);
    function createInitializeDefaultAccountStateInstruction(mint, accountState, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.defaultAccountStateInstructionData.span);
      exports.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Initialize,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeDefaultAccountStateInstruction = createInitializeDefaultAccountStateInstruction;
    function createUpdateDefaultAccountStateInstruction(mint, accountState, freezeAuthority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], freezeAuthority, multiSigners);
      const data = Buffer.alloc(exports.defaultAccountStateInstructionData.span);
      exports.defaultAccountStateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.DefaultAccountStateExtension,
        defaultAccountStateInstruction: DefaultAccountStateInstruction.Update,
        accountState
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createUpdateDefaultAccountStateInstruction = createUpdateDefaultAccountStateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js
var require_actions2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateDefaultAccountState = exports.initializeDefaultAccountState = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions2();
    function initializeDefaultAccountState(connection, payer, mint, state, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeDefaultAccountStateInstruction)(mint, state, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports.initializeDefaultAccountState = initializeDefaultAccountState;
    function updateDefaultAccountState(connection, payer, mint, state, freezeAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [freezeAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(freezeAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateDefaultAccountStateInstruction)(mint, state, freezeAuthorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.updateDefaultAccountState = updateDefaultAccountState;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js
var require_state2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultAccountState = exports.DEFAULT_ACCOUNT_STATE_SIZE = exports.DefaultAccountStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports.DefaultAccountStateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("state")]);
    exports.DEFAULT_ACCOUNT_STATE_SIZE = exports.DefaultAccountStateLayout.span;
    function getDefaultAccountState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.DefaultAccountState, mint.tlvData);
      if (extensionData !== null) {
        return exports.DefaultAccountStateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getDefaultAccountState = getDefaultAccountState;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js
var require_defaultAccountState = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/defaultAccountState/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions2(), exports);
    __exportStar(require_instructions2(), exports);
    __exportStar(require_state2(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js
var require_immutableOwner = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/immutableOwner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getImmutableOwner = exports.IMMUTABLE_OWNER_SIZE = exports.ImmutableOwnerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports.ImmutableOwnerLayout = (0, buffer_layout_1.struct)([]);
    exports.IMMUTABLE_OWNER_SIZE = exports.ImmutableOwnerLayout.span;
    function getImmutableOwner(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.ImmutableOwner, account.tlvData);
      if (extensionData !== null) {
        return exports.ImmutableOwnerLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getImmutableOwner = getImmutableOwner;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js
var require_state3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInterestBearingMintConfigState = exports.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports.InterestBearingMintConfigStateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.InterestBearingMintConfigStateLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.ns64)("initializationTimestamp"),
      (0, buffer_layout_1.s16)("preUpdateAverageRate"),
      (0, buffer_layout_1.ns64)("lastUpdateTimestamp"),
      (0, buffer_layout_1.s16)("currentRate")
    ]);
    exports.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = exports.InterestBearingMintConfigStateLayout.span;
    function getInterestBearingMintConfigState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.InterestBearingConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports.InterestBearingMintConfigStateLayout.decode(extensionData);
      }
      return null;
    }
    exports.getInterestBearingMintConfigState = getInterestBearingMintConfigState;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js
var require_instructions3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDisableRequiredMemoTransfersInstruction = exports.createEnableRequiredMemoTransfersInstruction = exports.memoTransferInstructionData = exports.MemoTransferInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var MemoTransferInstruction;
    (function(MemoTransferInstruction2) {
      MemoTransferInstruction2[MemoTransferInstruction2["Enable"] = 0] = "Enable";
      MemoTransferInstruction2[MemoTransferInstruction2["Disable"] = 1] = "Disable";
    })(MemoTransferInstruction || (exports.MemoTransferInstruction = MemoTransferInstruction = {}));
    exports.memoTransferInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("memoTransferInstruction")
    ]);
    function createEnableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Enable, account, authority, multiSigners, programId);
    }
    exports.createEnableRequiredMemoTransfersInstruction = createEnableRequiredMemoTransfersInstruction;
    function createDisableRequiredMemoTransfersInstruction(account, authority, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return createMemoTransferInstruction(MemoTransferInstruction.Disable, account, authority, multiSigners, programId);
    }
    exports.createDisableRequiredMemoTransfersInstruction = createDisableRequiredMemoTransfersInstruction;
    function createMemoTransferInstruction(memoTransferInstruction, account, authority, multiSigners, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports.memoTransferInstructionData.span);
      exports.memoTransferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MemoTransferExtension,
        memoTransferInstruction
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js
var require_actions3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.disableRequiredMemoTransfers = exports.enableRequiredMemoTransfers = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions3();
    function enableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createEnableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.enableRequiredMemoTransfers = enableRequiredMemoTransfers;
    function disableRequiredMemoTransfers(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createDisableRequiredMemoTransfersInstruction)(account, ownerPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.disableRequiredMemoTransfers = disableRequiredMemoTransfers;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js
var require_state4 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMemoTransfer = exports.MEMO_TRANSFER_SIZE = exports.MemoTransferLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.MemoTransferLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("requireIncomingTransferMemos")]);
    exports.MEMO_TRANSFER_SIZE = exports.MemoTransferLayout.span;
    function getMemoTransfer(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MemoTransfer, account.tlvData);
      if (extensionData !== null) {
        return exports.MemoTransferLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getMemoTransfer = getMemoTransfer;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js
var require_memoTransfer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/memoTransfer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions3(), exports);
    __exportStar(require_instructions3(), exports);
    __exportStar(require_state4(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js
var require_state5 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMetadataPointerState = exports.METADATA_POINTER_SIZE = exports.MetadataPointerLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var extensionType_js_1 = require_extensionType();
    exports.MetadataPointerLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    exports.METADATA_POINTER_SIZE = exports.MetadataPointerLayout.span;
    function getMetadataPointerState(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MetadataPointer, mint.tlvData);
      if (extensionData !== null) {
        const { authority, metadataAddress } = exports.MetadataPointerLayout.decode(extensionData);
        return {
          authority: authority.equals(web3_js_1.PublicKey.default) ? null : authority,
          metadataAddress: metadataAddress.equals(web3_js_1.PublicKey.default) ? null : metadataAddress
        };
      } else {
        return null;
      }
    }
    exports.getMetadataPointerState = getMetadataPointerState;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js
var require_mintCloseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/mintCloseAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMintCloseAuthority = exports.MINT_CLOSE_AUTHORITY_SIZE = exports.MintCloseAuthorityLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.MintCloseAuthorityLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("closeAuthority")]);
    exports.MINT_CLOSE_AUTHORITY_SIZE = exports.MintCloseAuthorityLayout.span;
    function getMintCloseAuthority(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.MintCloseAuthority, mint.tlvData);
      if (extensionData !== null) {
        return exports.MintCloseAuthorityLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getMintCloseAuthority = getMintCloseAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js
var require_nonTransferable = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/nonTransferable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNonTransferableAccount = exports.getNonTransferable = exports.NON_TRANSFERABLE_ACCOUNT_SIZE = exports.NON_TRANSFERABLE_SIZE = exports.NonTransferableLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    exports.NonTransferableLayout = (0, buffer_layout_1.struct)([]);
    exports.NON_TRANSFERABLE_SIZE = exports.NonTransferableLayout.span;
    exports.NON_TRANSFERABLE_ACCOUNT_SIZE = exports.NonTransferableLayout.span;
    function getNonTransferable(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferable, mint.tlvData);
      if (extensionData !== null) {
        return exports.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getNonTransferable = getNonTransferable;
    function getNonTransferableAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.NonTransferableAccount, account.tlvData);
      if (extensionData !== null) {
        return exports.NonTransferableLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getNonTransferableAccount = getNonTransferableAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js
var require_permanentDelegate = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/permanentDelegate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPermanentDelegate = exports.PERMANENT_DELEGATE_SIZE = exports.PermanentDelegateLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.PermanentDelegateLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("delegate")]);
    exports.PERMANENT_DELEGATE_SIZE = exports.PermanentDelegateLayout.span;
    function getPermanentDelegate(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.PermanentDelegate, mint.tlvData);
      if (extensionData !== null) {
        return exports.PermanentDelegateLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getPermanentDelegate = getPermanentDelegate;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js
var require_instructions4 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeHarvestWithheldTokensToMintInstructionUnchecked = exports.decodeHarvestWithheldTokensToMintInstruction = exports.createHarvestWithheldTokensToMintInstruction = exports.harvestWithheldTokensToMintInstructionData = exports.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = exports.decodeWithdrawWithheldTokensFromAccountsInstruction = exports.createWithdrawWithheldTokensFromAccountsInstruction = exports.withdrawWithheldTokensFromAccountsInstructionData = exports.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = exports.decodeWithdrawWithheldTokensFromMintInstruction = exports.createWithdrawWithheldTokensFromMintInstruction = exports.withdrawWithheldTokensFromMintInstructionData = exports.decodeTransferCheckedWithFeeInstructionUnchecked = exports.decodeTransferCheckedWithFeeInstruction = exports.createTransferCheckedWithFeeInstruction = exports.transferCheckedWithFeeInstructionData = exports.decodeInitializeTransferFeeConfigInstructionUnchecked = exports.decodeInitializeTransferFeeConfigInstruction = exports.createInitializeTransferFeeConfigInstruction = exports.initializeTransferFeeConfigInstructionData = exports.TransferFeeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var TransferFeeInstruction;
    (function(TransferFeeInstruction2) {
      TransferFeeInstruction2[TransferFeeInstruction2["InitializeTransferFeeConfig"] = 0] = "InitializeTransferFeeConfig";
      TransferFeeInstruction2[TransferFeeInstruction2["TransferCheckedWithFee"] = 1] = "TransferCheckedWithFee";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromMint"] = 2] = "WithdrawWithheldTokensFromMint";
      TransferFeeInstruction2[TransferFeeInstruction2["WithdrawWithheldTokensFromAccounts"] = 3] = "WithdrawWithheldTokensFromAccounts";
      TransferFeeInstruction2[TransferFeeInstruction2["HarvestWithheldTokensToMint"] = 4] = "HarvestWithheldTokensToMint";
      TransferFeeInstruction2[TransferFeeInstruction2["SetTransferFee"] = 5] = "SetTransferFee";
    })(TransferFeeInstruction || (exports.TransferFeeInstruction = TransferFeeInstruction = {}));
    exports.initializeTransferFeeConfigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("transferFeeConfigAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_1.u8)("withdrawWithheldAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_1.u16)("transferFeeBasisPoints"),
      (0, buffer_layout_utils_1.u64)("maximumFee")
    ]);
    function createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeTransferFeeConfigInstructionData.span);
      exports.initializeTransferFeeConfigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,
        transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,
        transferFeeConfigAuthority: transferFeeConfigAuthority || new web3_js_1.PublicKey(0),
        withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,
        withdrawWithheldAuthority: withdrawWithheldAuthority || new web3_js_1.PublicKey(0),
        transferFeeBasisPoints,
        maximumFee
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeTransferFeeConfigInstruction = createInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeTransferFeeConfigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeInitializeTransferFeeConfigInstruction = decodeInitializeTransferFeeConfigInstruction;
    function decodeInitializeTransferFeeConfigInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, transferFeeInstruction, transferFeeConfigAuthorityOption, transferFeeConfigAuthority, withdrawWithheldAuthorityOption, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee } = exports.initializeTransferFeeConfigInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          transferFeeInstruction,
          transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,
          withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,
          transferFeeBasisPoints,
          maximumFee
        }
      };
    }
    exports.decodeInitializeTransferFeeConfigInstructionUnchecked = decodeInitializeTransferFeeConfigInstructionUnchecked;
    exports.transferCheckedWithFeeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.u64)("fee")
    ]);
    function createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports.transferCheckedWithFeeInstructionData.span);
      exports.transferCheckedWithFeeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,
        amount,
        decimals,
        fee
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createTransferCheckedWithFeeInstruction = createTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.transferCheckedWithFeeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, authority, signers }, data } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports.decodeTransferCheckedWithFeeInstruction = decodeTransferCheckedWithFeeInstruction;
    function decodeTransferCheckedWithFeeInstructionUnchecked({ programId, keys: [source, mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction, amount, decimals, fee } = exports.transferCheckedWithFeeInstructionData.decode(data);
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction,
          amount,
          decimals,
          fee
        }
      };
    }
    exports.decodeTransferCheckedWithFeeInstructionUnchecked = decodeTransferCheckedWithFeeInstructionUnchecked;
    exports.withdrawWithheldTokensFromMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority, signers = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports.withdrawWithheldTokensFromMintInstructionData.span);
      exports.withdrawWithheldTokensFromMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createWithdrawWithheldTokensFromMintInstruction = createWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.withdrawWithheldTokensFromMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers }, data } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null
        },
        data
      };
    }
    exports.decodeWithdrawWithheldTokensFromMintInstruction = decodeWithdrawWithheldTokensFromMintInstruction;
    function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({ programId, keys: [mint, destination, authority, ...signers], data }) {
      const { instruction, transferFeeInstruction } = exports.withdrawWithheldTokensFromMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = decodeWithdrawWithheldTokensFromMintInstructionUnchecked;
    exports.withdrawWithheldTokensFromAccountsInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction"),
      (0, buffer_layout_1.u8)("numTokenAccounts")
    ]);
    function createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports.withdrawWithheldTokensFromAccountsInstructionData.span);
      exports.withdrawWithheldTokensFromAccountsInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,
        numTokenAccounts: sources.length
      }, data);
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, signers);
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createWithdrawWithheldTokensFromAccountsInstruction = createWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.withdrawWithheldTokensFromAccountsInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, signers, sources }, data } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers: signers ? signers : null,
          sources: sources ? sources : null
        },
        data
      };
    }
    exports.decodeWithdrawWithheldTokensFromAccountsInstruction = decodeWithdrawWithheldTokensFromAccountsInstruction;
    function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({ programId, keys, data }) {
      const { instruction, transferFeeInstruction, numTokenAccounts } = exports.withdrawWithheldTokensFromAccountsInstructionData.decode(data);
      const [mint, destination, authority, signers, sources] = [
        keys[0],
        keys[1],
        keys[2],
        keys.slice(3, 3 + numTokenAccounts),
        keys.slice(-1 * numTokenAccounts)
      ];
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          signers,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction,
          numTokenAccounts
        }
      };
    }
    exports.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked;
    exports.harvestWithheldTokensToMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferFeeInstruction")
    ]);
    function createHarvestWithheldTokensToMintInstruction(mint, sources, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const data = Buffer.alloc(exports.harvestWithheldTokensToMintInstructionData.span);
      exports.harvestWithheldTokensToMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferFeeExtension,
        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint
      }, data);
      const keys = [];
      keys.push({ pubkey: mint, isSigner: false, isWritable: true });
      for (const source of sources) {
        keys.push({ pubkey: source, isSigner: false, isWritable: true });
      }
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createHarvestWithheldTokensToMintInstruction = createHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.harvestWithheldTokensToMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, sources }, data } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data
      };
    }
    exports.decodeHarvestWithheldTokensToMintInstruction = decodeHarvestWithheldTokensToMintInstruction;
    function decodeHarvestWithheldTokensToMintInstructionUnchecked({ programId, keys: [mint, ...sources], data }) {
      const { instruction, transferFeeInstruction } = exports.harvestWithheldTokensToMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          sources
        },
        data: {
          instruction,
          transferFeeInstruction
        }
      };
    }
    exports.decodeHarvestWithheldTokensToMintInstructionUnchecked = decodeHarvestWithheldTokensToMintInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js
var require_actions4 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.harvestWithheldTokensToMint = exports.withdrawWithheldTokensFromAccounts = exports.withdrawWithheldTokensFromMint = exports.transferCheckedWithFee = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions4();
    function transferCheckedWithFee(connection, payer, source, mint, destination, owner, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, fee, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.transferCheckedWithFee = transferCheckedWithFee;
    function withdrawWithheldTokensFromMint(connection, payer, mint, destination, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromMintInstruction)(mint, destination, authorityPublicKey, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.withdrawWithheldTokensFromMint = withdrawWithheldTokensFromMint;
    function withdrawWithheldTokensFromAccounts(connection, payer, mint, destination, authority, multiSigners, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createWithdrawWithheldTokensFromAccountsInstruction)(mint, destination, authorityPublicKey, signers, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.withdrawWithheldTokensFromAccounts = withdrawWithheldTokensFromAccounts;
    function harvestWithheldTokensToMint(connection, payer, mint, sources, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createHarvestWithheldTokensToMintInstruction)(mint, sources, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports.harvestWithheldTokensToMint = harvestWithheldTokensToMint;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js
var require_state6 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransferFeeAmount = exports.getTransferFeeConfig = exports.TRANSFER_FEE_AMOUNT_SIZE = exports.TransferFeeAmountLayout = exports.calculateEpochFee = exports.getEpochFee = exports.TRANSFER_FEE_CONFIG_SIZE = exports.TransferFeeConfigLayout = exports.calculateFee = exports.transferFeeLayout = exports.ONE_IN_BASIS_POINTS = exports.MAX_FEE_BASIS_POINTS = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var extensionType_js_1 = require_extensionType();
    exports.MAX_FEE_BASIS_POINTS = 1e4;
    exports.ONE_IN_BASIS_POINTS = BigInt(exports.MAX_FEE_BASIS_POINTS);
    function transferFeeLayout(property) {
      return (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("epoch"), (0, buffer_layout_utils_1.u64)("maximumFee"), (0, buffer_layout_1.u16)("transferFeeBasisPoints")], property);
    }
    exports.transferFeeLayout = transferFeeLayout;
    function calculateFee(transferFee, preFeeAmount) {
      const transferFeeBasisPoints = transferFee.transferFeeBasisPoints;
      if (transferFeeBasisPoints === 0 || preFeeAmount === BigInt(0)) {
        return BigInt(0);
      } else {
        const numerator = preFeeAmount * BigInt(transferFeeBasisPoints);
        const rawFee = (numerator + exports.ONE_IN_BASIS_POINTS - BigInt(1)) / exports.ONE_IN_BASIS_POINTS;
        const fee = rawFee > transferFee.maximumFee ? transferFee.maximumFee : rawFee;
        return BigInt(fee);
      }
    }
    exports.calculateFee = calculateFee;
    exports.TransferFeeConfigLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.publicKey)("transferFeeConfigAuthority"),
      (0, buffer_layout_utils_1.publicKey)("withdrawWithheldAuthority"),
      (0, buffer_layout_utils_1.u64)("withheldAmount"),
      transferFeeLayout("olderTransferFee"),
      transferFeeLayout("newerTransferFee")
    ]);
    exports.TRANSFER_FEE_CONFIG_SIZE = exports.TransferFeeConfigLayout.span;
    function getEpochFee(transferFeeConfig, epoch) {
      if (epoch >= transferFeeConfig.newerTransferFee.epoch) {
        return transferFeeConfig.newerTransferFee;
      } else {
        return transferFeeConfig.olderTransferFee;
      }
    }
    exports.getEpochFee = getEpochFee;
    function calculateEpochFee(transferFeeConfig, epoch, preFeeAmount) {
      const transferFee = getEpochFee(transferFeeConfig, epoch);
      return calculateFee(transferFee, preFeeAmount);
    }
    exports.calculateEpochFee = calculateEpochFee;
    exports.TransferFeeAmountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.u64)("withheldAmount")]);
    exports.TRANSFER_FEE_AMOUNT_SIZE = exports.TransferFeeAmountLayout.span;
    function getTransferFeeConfig(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeConfig, mint.tlvData);
      if (extensionData !== null) {
        return exports.TransferFeeConfigLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getTransferFeeConfig = getTransferFeeConfig;
    function getTransferFeeAmount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferFeeAmount, account.tlvData);
      if (extensionData !== null) {
        return exports.TransferFeeAmountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getTransferFeeAmount = getTransferFeeAmount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js
var require_transferFee = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferFee/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions4(), exports);
    __exportStar(require_instructions4(), exports);
    __exportStar(require_state6(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js
var require_transferChecked = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/transferChecked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTransferCheckedInstructionUnchecked = exports.decodeTransferCheckedInstruction = exports.createTransferCheckedInstruction = exports.transferCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.transferCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.transferCheckedInstructionData.span);
      exports.transferCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createTransferCheckedInstruction = createTransferCheckedInstruction;
    function decodeTransferCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.transferCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, mint, destination, owner, multiSigners }, data } = decodeTransferCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.TransferChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !mint || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeTransferCheckedInstruction = decodeTransferCheckedInstruction;
    function decodeTransferCheckedInstructionUnchecked({ programId, keys: [source, mint, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          mint,
          destination,
          owner,
          multiSigners
        },
        data: exports.transferCheckedInstructionData.decode(data)
      };
    }
    exports.decodeTransferCheckedInstructionUnchecked = decodeTransferCheckedInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js
var require_seeds = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/seeds.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unpackSeeds = void 0;
    var errors_js_1 = require_errors2();
    var DISCRIMINATOR_SPAN = 1;
    var LITERAL_LENGTH_SPAN = 1;
    var INSTRUCTION_ARG_OFFSET_SPAN = 1;
    var INSTRUCTION_ARG_LENGTH_SPAN = 1;
    var ACCOUNT_KEY_INDEX_SPAN = 1;
    var ACCOUNT_DATA_ACCOUNT_INDEX_SPAN = 1;
    var ACCOUNT_DATA_OFFSET_SPAN = 1;
    var ACCOUNT_DATA_LENGTH_SPAN = 1;
    function unpackSeedLiteral(seeds) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [length, ...rest] = seeds;
      if (rest.length < length) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: Buffer.from(rest.slice(0, length)),
        packedLength: DISCRIMINATOR_SPAN + LITERAL_LENGTH_SPAN + length
      };
    }
    function unpackSeedInstructionArg(seeds, instructionData) {
      if (seeds.length < 2) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index, length] = seeds;
      if (instructionData.length < length + index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: instructionData.subarray(index, index + length),
        packedLength: DISCRIMINATOR_SPAN + INSTRUCTION_ARG_OFFSET_SPAN + INSTRUCTION_ARG_LENGTH_SPAN
      };
    }
    function unpackSeedAccountKey(seeds, previousMetas) {
      if (seeds.length < 1) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      const [index] = seeds;
      if (previousMetas.length <= index) {
        throw new errors_js_1.TokenTransferHookInvalidSeed();
      }
      return {
        data: previousMetas[index].pubkey.toBuffer(),
        packedLength: DISCRIMINATOR_SPAN + ACCOUNT_KEY_INDEX_SPAN
      };
    }
    function unpackSeedAccountData(seeds, previousMetas, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        if (seeds.length < 3) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const [accountIndex, dataIndex, length] = seeds;
        if (previousMetas.length <= accountIndex) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        const accountInfo = yield connection.getAccountInfo(previousMetas[accountIndex].pubkey);
        if (accountInfo == null) {
          throw new errors_js_1.TokenTransferHookAccountDataNotFound();
        }
        if (accountInfo.data.length < dataIndex + length) {
          throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
        return {
          data: accountInfo.data.subarray(dataIndex, dataIndex + length),
          packedLength: DISCRIMINATOR_SPAN + ACCOUNT_DATA_ACCOUNT_INDEX_SPAN + ACCOUNT_DATA_OFFSET_SPAN + ACCOUNT_DATA_LENGTH_SPAN
        };
      });
    }
    function unpackFirstSeed(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const [discriminator, ...rest] = seeds;
        const remaining = new Uint8Array(rest);
        switch (discriminator) {
          case 0:
            return null;
          case 1:
            return unpackSeedLiteral(remaining);
          case 2:
            return unpackSeedInstructionArg(remaining, instructionData);
          case 3:
            return unpackSeedAccountKey(remaining, previousMetas);
          case 4:
            return unpackSeedAccountData(remaining, previousMetas, connection);
          default:
            throw new errors_js_1.TokenTransferHookInvalidSeed();
        }
      });
    }
    function unpackSeeds(seeds, previousMetas, instructionData, connection) {
      return __awaiter(this, void 0, void 0, function* () {
        const unpackedSeeds = [];
        let i = 0;
        while (i < 32) {
          const seed = yield unpackFirstSeed(seeds.slice(i), previousMetas, instructionData, connection);
          if (seed == null) {
            break;
          }
          unpackedSeeds.push(seed.data);
          i += seed.packedLength;
        }
        return unpackedSeeds;
      });
    }
    exports.unpackSeeds = unpackSeeds;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js
var require_state7 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/state.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveExtraAccountMeta = exports.getExtraAccountMetas = exports.ExtraAccountMetaAccountDataLayout = exports.ExtraAccountMetaListLayout = exports.ExtraAccountMetaLayout = exports.getExtraAccountMetaAddress = exports.getTransferHookAccount = exports.TRANSFER_HOOK_ACCOUNT_SIZE = exports.TransferHookAccountLayout = exports.getTransferHook = exports.TRANSFER_HOOK_SIZE = exports.TransferHookLayout = void 0;
    var buffer_layout_1 = require_Layout();
    var extensionType_js_1 = require_extensionType();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var buffer_layout_utils_1 = require_cjs();
    var errors_js_1 = require_errors2();
    var seeds_js_1 = require_seeds();
    exports.TransferHookLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)("authority"), (0, buffer_layout_utils_1.publicKey)("programId")]);
    exports.TRANSFER_HOOK_SIZE = exports.TransferHookLayout.span;
    function getTransferHook(mint) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHook, mint.tlvData);
      if (extensionData !== null) {
        return exports.TransferHookLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getTransferHook = getTransferHook;
    exports.TransferHookAccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.bool)("transferring")]);
    exports.TRANSFER_HOOK_ACCOUNT_SIZE = exports.TransferHookAccountLayout.span;
    function getTransferHookAccount(account) {
      const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TransferHookAccount, account.tlvData);
      if (extensionData !== null) {
        return exports.TransferHookAccountLayout.decode(extensionData);
      } else {
        return null;
      }
    }
    exports.getTransferHookAccount = getTransferHookAccount;
    function getExtraAccountMetaAddress(mint, programId) {
      const seeds = [Buffer.from("extra-account-metas"), mint.toBuffer()];
      return web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
    }
    exports.getExtraAccountMetaAddress = getExtraAccountMetaAddress;
    exports.ExtraAccountMetaLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("discriminator"),
      (0, buffer_layout_1.blob)(32, "addressConfig"),
      (0, buffer_layout_utils_1.bool)("isSigner"),
      (0, buffer_layout_utils_1.bool)("isWritable")
    ]);
    exports.ExtraAccountMetaListLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u32)("count"),
      (0, buffer_layout_1.seq)(exports.ExtraAccountMetaLayout, (0, buffer_layout_1.greedy)(exports.ExtraAccountMetaLayout.span), "extraAccounts")
    ]);
    exports.ExtraAccountMetaAccountDataLayout = (0, buffer_layout_1.struct)([
      (0, buffer_layout_utils_1.u64)("instructionDiscriminator"),
      (0, buffer_layout_1.u32)("length"),
      exports.ExtraAccountMetaListLayout.replicate("extraAccountsList")
    ]);
    function getExtraAccountMetas(account) {
      const extraAccountsList = exports.ExtraAccountMetaAccountDataLayout.decode(account.data).extraAccountsList;
      return extraAccountsList.extraAccounts.slice(0, extraAccountsList.count);
    }
    exports.getExtraAccountMetas = getExtraAccountMetas;
    function resolveExtraAccountMeta(connection, extraMeta, previousMetas, instructionData, transferHookProgramId) {
      return __awaiter(this, void 0, void 0, function* () {
        if (extraMeta.discriminator === 0) {
          return {
            pubkey: new web3_js_1.PublicKey(extraMeta.addressConfig),
            isSigner: extraMeta.isSigner,
            isWritable: extraMeta.isWritable
          };
        }
        let programId = web3_js_1.PublicKey.default;
        if (extraMeta.discriminator === 1) {
          programId = transferHookProgramId;
        } else {
          const accountIndex = extraMeta.discriminator - (1 << 7);
          if (previousMetas.length <= accountIndex) {
            throw new errors_js_1.TokenTransferHookAccountNotFound();
          }
          programId = previousMetas[accountIndex].pubkey;
        }
        const seeds = yield (0, seeds_js_1.unpackSeeds)(extraMeta.addressConfig, previousMetas, instructionData, connection);
        const pubkey = web3_js_1.PublicKey.findProgramAddressSync(seeds, programId)[0];
        return { pubkey, isSigner: extraMeta.isSigner, isWritable: extraMeta.isWritable };
      });
    }
    exports.resolveExtraAccountMeta = resolveExtraAccountMeta;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js
var require_instructions5 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/instructions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransferCheckedWithFeeAndTransferHookInstruction = exports.createTransferCheckedWithTransferHookInstruction = exports.addExtraAccountsToInstruction = exports.createUpdateTransferHookInstruction = exports.updateTransferHookInstructionData = exports.createInitializeTransferHookInstruction = exports.initializeTransferHookInstructionData = exports.TransferHookInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var buffer_layout_utils_1 = require_cjs();
    var transferChecked_js_1 = require_transferChecked();
    var instructions_js_1 = require_instructions4();
    var mint_js_1 = require_mint();
    var state_js_1 = require_state7();
    var TransferHookInstruction;
    (function(TransferHookInstruction2) {
      TransferHookInstruction2[TransferHookInstruction2["Initialize"] = 0] = "Initialize";
      TransferHookInstruction2[TransferHookInstruction2["Update"] = 1] = "Update";
    })(TransferHookInstruction || (exports.TransferHookInstruction = TransferHookInstruction = {}));
    exports.initializeTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeTransferHookInstructionData.span);
      exports.initializeTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Initialize,
        authority,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeTransferHookInstruction = createInitializeTransferHookInstruction;
    exports.updateTransferHookInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("transferHookInstruction"),
      (0, buffer_layout_utils_1.publicKey)("transferHookProgramId")
    ]);
    function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports.updateTransferHookInstructionData.span);
      exports.updateTransferHookInstructionData.encode({
        instruction: types_js_1.TokenInstruction.TransferHookExtension,
        transferHookInstruction: TransferHookInstruction.Update,
        transferHookProgramId
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createUpdateTransferHookInstruction = createUpdateTransferHookInstruction;
    function deEscalateAccountMeta(accountMeta, accountMetas) {
      const maybeHighestPrivileges = accountMetas.filter((x) => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {
        if (!acc)
          return { isSigner: x.isSigner, isWritable: x.isWritable };
        return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };
      }, void 0);
      if (maybeHighestPrivileges) {
        const { isSigner, isWritable } = maybeHighestPrivileges;
        if (!isSigner && isSigner !== accountMeta.isSigner) {
          accountMeta.isSigner = false;
        }
        if (!isWritable && isWritable !== accountMeta.isWritable) {
          accountMeta.isWritable = false;
        }
      }
      return accountMeta;
    }
    function addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
          throw new errors_js_1.TokenUnsupportedInstructionError();
        }
        const mintInfo = yield (0, mint_js_1.getMint)(connection, mint, commitment, programId);
        const transferHook = (0, state_js_1.getTransferHook)(mintInfo);
        if (transferHook == null) {
          return instruction;
        }
        const extraAccountsAccount = (0, state_js_1.getExtraAccountMetaAddress)(mint, transferHook.programId);
        const extraAccountsInfo = yield connection.getAccountInfo(extraAccountsAccount, commitment);
        if (extraAccountsInfo == null) {
          return instruction;
        }
        const extraAccountMetas = (0, state_js_1.getExtraAccountMetas)(extraAccountsInfo);
        const accountMetas = instruction.keys;
        for (const extraAccountMeta of extraAccountMetas) {
          const accountMetaUnchecked = yield (0, state_js_1.resolveExtraAccountMeta)(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);
          const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);
          accountMetas.push(accountMeta);
        }
        accountMetas.push({ pubkey: transferHook.programId, isSigner: false, isWritable: false });
        accountMetas.push({ pubkey: extraAccountsAccount, isSigner: false, isWritable: false });
        return new web3_js_1.TransactionInstruction({ keys: accountMetas, programId, data: instruction.data });
      });
    }
    exports.addExtraAccountsToInstruction = addExtraAccountsToInstruction;
    function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, authority, amount, decimals, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports.createTransferCheckedWithTransferHookInstruction = createTransferCheckedWithTransferHookInstruction;
    function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const rawInstruction = (0, instructions_js_1.createTransferCheckedWithFeeInstruction)(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);
        const hydratedInstruction = yield addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);
        return hydratedInstruction;
      });
    }
    exports.createTransferCheckedWithFeeAndTransferHookInstruction = createTransferCheckedWithFeeAndTransferHookInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js
var require_actions5 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transferCheckedWithFeeAndTransferHook = exports.transferCheckedWithTransferHook = exports.updateTransferHook = exports.initializeTransferHook = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var instructions_js_1 = require_instructions5();
    function initializeTransferHook(connection, payer, mint, authority, transferHookProgramId, confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createInitializeTransferHookInstruction)(mint, authority, transferHookProgramId, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports.initializeTransferHook = initializeTransferHook;
    function updateTransferHook(connection, payer, mint, transferHookProgramId, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateTransferHookInstruction)(mint, authorityPublicKey, transferHookProgramId, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.updateTransferHook = updateTransferHook;
    function transferCheckedWithTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.transferCheckedWithTransferHook = transferCheckedWithTransferHook;
    function transferCheckedWithFeeAndTransferHook(connection, payer, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add(yield (0, instructions_js_1.createTransferCheckedWithFeeAndTransferHookInstruction)(connection, source, mint, destination, authorityPublicKey, amount, decimals, fee, signers, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.transferCheckedWithFeeAndTransferHook = transferCheckedWithFeeAndTransferHook;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js
var require_transferHook = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/transferHook/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions5(), exports);
    __exportStar(require_instructions5(), exports);
    __exportStar(require_seeds(), exports);
    __exportStar(require_state7(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js
var require_extensionType = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/extensionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNewAccountLenForExtensionLen = exports.getAccountLenForMint = exports.getExtensionTypes = exports.getExtensionData = exports.getAccountLen = exports.getMintLen = exports.getAccountTypeOfMintType = exports.isAccountExtension = exports.isMintExtension = exports.getTypeLen = exports.LENGTH_SIZE = exports.TYPE_SIZE = exports.ExtensionType = void 0;
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var multisig_js_1 = require_multisig();
    var accountType_js_1 = require_accountType();
    var index_js_1 = require_cpiGuard();
    var index_js_2 = require_defaultAccountState();
    var immutableOwner_js_1 = require_immutableOwner();
    var state_js_1 = require_state3();
    var index_js_3 = require_memoTransfer();
    var state_js_2 = require_state5();
    var mintCloseAuthority_js_1 = require_mintCloseAuthority();
    var nonTransferable_js_1 = require_nonTransferable();
    var permanentDelegate_js_1 = require_permanentDelegate();
    var index_js_4 = require_transferFee();
    var index_js_5 = require_transferHook();
    var constants_js_1 = require_constants();
    var ExtensionType;
    (function(ExtensionType2) {
      ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
      ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
      ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
      ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
      ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
      ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
      ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
      ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
      ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
      ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
      ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
      ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
      ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
      ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
      ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
      ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
      ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
      ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
    })(ExtensionType || (exports.ExtensionType = ExtensionType = {}));
    exports.TYPE_SIZE = 2;
    exports.LENGTH_SIZE = 2;
    function addTypeAndLengthToLen(len) {
      return len + exports.TYPE_SIZE + exports.LENGTH_SIZE;
    }
    function isVariableLengthExtension(e) {
      switch (e) {
        case ExtensionType.TokenMetadata:
          return true;
        default:
          return false;
      }
    }
    function getTypeLen(e) {
      switch (e) {
        case ExtensionType.Uninitialized:
          return 0;
        case ExtensionType.TransferFeeConfig:
          return index_js_4.TRANSFER_FEE_CONFIG_SIZE;
        case ExtensionType.TransferFeeAmount:
          return index_js_4.TRANSFER_FEE_AMOUNT_SIZE;
        case ExtensionType.MintCloseAuthority:
          return mintCloseAuthority_js_1.MINT_CLOSE_AUTHORITY_SIZE;
        case ExtensionType.ConfidentialTransferMint:
          return 97;
        case ExtensionType.ConfidentialTransferAccount:
          return 286;
        case ExtensionType.CpiGuard:
          return index_js_1.CPI_GUARD_SIZE;
        case ExtensionType.DefaultAccountState:
          return index_js_2.DEFAULT_ACCOUNT_STATE_SIZE;
        case ExtensionType.ImmutableOwner:
          return immutableOwner_js_1.IMMUTABLE_OWNER_SIZE;
        case ExtensionType.MemoTransfer:
          return index_js_3.MEMO_TRANSFER_SIZE;
        case ExtensionType.MetadataPointer:
          return state_js_2.METADATA_POINTER_SIZE;
        case ExtensionType.NonTransferable:
          return nonTransferable_js_1.NON_TRANSFERABLE_SIZE;
        case ExtensionType.InterestBearingConfig:
          return state_js_1.INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
        case ExtensionType.PermanentDelegate:
          return permanentDelegate_js_1.PERMANENT_DELEGATE_SIZE;
        case ExtensionType.NonTransferableAccount:
          return nonTransferable_js_1.NON_TRANSFERABLE_ACCOUNT_SIZE;
        case ExtensionType.TransferHook:
          return index_js_5.TRANSFER_HOOK_SIZE;
        case ExtensionType.TransferHookAccount:
          return index_js_5.TRANSFER_HOOK_ACCOUNT_SIZE;
        case ExtensionType.TokenMetadata:
          throw Error(`Cannot get type length for variable extension type: ${e}`);
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports.getTypeLen = getTypeLen;
    function isMintExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports.isMintExtension = isMintExtension;
    function isAccountExtension(e) {
      switch (e) {
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.CpiGuard:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return true;
        case ExtensionType.Uninitialized:
        case ExtensionType.TransferFeeConfig:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.ConfidentialTransferMint:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.NonTransferable:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.TransferHook:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
          return false;
        default:
          throw Error(`Unknown extension type: ${e}`);
      }
    }
    exports.isAccountExtension = isAccountExtension;
    function getAccountTypeOfMintType(e) {
      switch (e) {
        case ExtensionType.TransferFeeConfig:
          return ExtensionType.TransferFeeAmount;
        case ExtensionType.ConfidentialTransferMint:
          return ExtensionType.ConfidentialTransferAccount;
        case ExtensionType.NonTransferable:
          return ExtensionType.NonTransferableAccount;
        case ExtensionType.TransferHook:
          return ExtensionType.TransferHookAccount;
        case ExtensionType.TransferFeeAmount:
        case ExtensionType.ConfidentialTransferAccount:
        case ExtensionType.CpiGuard:
        case ExtensionType.DefaultAccountState:
        case ExtensionType.ImmutableOwner:
        case ExtensionType.MemoTransfer:
        case ExtensionType.MintCloseAuthority:
        case ExtensionType.MetadataPointer:
        case ExtensionType.TokenMetadata:
        case ExtensionType.Uninitialized:
        case ExtensionType.InterestBearingConfig:
        case ExtensionType.PermanentDelegate:
        case ExtensionType.NonTransferableAccount:
        case ExtensionType.TransferHookAccount:
          return ExtensionType.Uninitialized;
      }
    }
    exports.getAccountTypeOfMintType = getAccountTypeOfMintType;
    function getLen(extensionTypes, baseSize, variableLengthExtensions = {}) {
      if (extensionTypes.length === 0 && Object.keys(variableLengthExtensions).length === 0) {
        return baseSize;
      } else {
        const accountLength = account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE + extensionTypes.filter((element, i) => i === extensionTypes.indexOf(element)).map((element) => addTypeAndLengthToLen(getTypeLen(element))).reduce((a, b) => a + b, 0) + Object.entries(variableLengthExtensions).map(([extension, len]) => {
          if (!isVariableLengthExtension(Number(extension))) {
            throw Error(`Extension ${extension} is not variable length`);
          }
          return addTypeAndLengthToLen(len);
        }).reduce((a, b) => a + b, 0);
        if (accountLength === multisig_js_1.MULTISIG_SIZE) {
          return accountLength + exports.TYPE_SIZE;
        } else {
          return accountLength;
        }
      }
    }
    function getMintLen(extensionTypes, variableLengthExtensions = {}) {
      return getLen(extensionTypes, mint_js_1.MINT_SIZE, variableLengthExtensions);
    }
    exports.getMintLen = getMintLen;
    function getAccountLen(extensionTypes) {
      return getLen(extensionTypes, account_js_1.ACCOUNT_SIZE);
    }
    exports.getAccountLen = getAccountLen;
    function getExtensionData(extension, tlvData) {
      let extensionTypeIndex = 0;
      while (addTypeAndLengthToLen(extensionTypeIndex) <= tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports.TYPE_SIZE);
        const typeIndex = addTypeAndLengthToLen(extensionTypeIndex);
        if (entryType == extension) {
          return tlvData.slice(typeIndex, typeIndex + entryLength);
        }
        extensionTypeIndex = typeIndex + entryLength;
      }
      return null;
    }
    exports.getExtensionData = getExtensionData;
    function getExtensionTypes(tlvData) {
      const extensionTypes = [];
      let extensionTypeIndex = 0;
      while (extensionTypeIndex < tlvData.length) {
        const entryType = tlvData.readUInt16LE(extensionTypeIndex);
        extensionTypes.push(entryType);
        const entryLength = tlvData.readUInt16LE(extensionTypeIndex + exports.TYPE_SIZE);
        extensionTypeIndex += addTypeAndLengthToLen(entryLength);
      }
      return extensionTypes;
    }
    exports.getExtensionTypes = getExtensionTypes;
    function getAccountLenForMint(mint) {
      const extensionTypes = getExtensionTypes(mint.tlvData);
      const accountExtensions = extensionTypes.map(getAccountTypeOfMintType);
      return getAccountLen(accountExtensions);
    }
    exports.getAccountLenForMint = getAccountLenForMint;
    function getNewAccountLenForExtensionLen(info, address, extensionType, extensionLen, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const mint = (0, mint_js_1.unpackMint)(address, info, programId);
      const extensionData = getExtensionData(extensionType, mint.tlvData);
      const currentExtensionLen = extensionData ? addTypeAndLengthToLen(extensionData.length) : 0;
      const newExtensionLen = addTypeAndLengthToLen(extensionLen);
      return info.data.length + newExtensionLen - currentExtensionLen;
    }
    exports.getNewAccountLenForExtensionLen = getNewAccountLenForExtensionLen;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js
var require_initializeAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeAccountInstructionUnchecked = exports.decodeInitializeAccountInstruction = exports.createInitializeAccountInstruction = exports.initializeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createInitializeAccountInstruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports.initializeAccountInstructionData.span);
      exports.initializeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeAccountInstruction = createInitializeAccountInstruction;
    function decodeInitializeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, owner, rent }, data } = decodeInitializeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !owner || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data
      };
    }
    exports.decodeInitializeAccountInstruction = decodeInitializeAccountInstruction;
    function decodeInitializeAccountInstructionUnchecked({ programId, keys: [account, mint, owner, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          owner,
          rent
        },
        data: exports.initializeAccountInstructionData.decode(data)
      };
    }
    exports.decodeInitializeAccountInstructionUnchecked = decodeInitializeAccountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js
var require_associatedTokenAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/associatedTokenAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRecoverNestedInstruction = exports.createAssociatedTokenAccountIdempotentInstruction = exports.createAssociatedTokenAccountInstruction = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    function createAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.alloc(0), programId, associatedTokenProgramId);
    }
    exports.createAssociatedTokenAccountInstruction = createAssociatedTokenAccountInstruction;
    function createAssociatedTokenAccountIdempotentInstruction(payer, associatedToken, owner, mint, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, Buffer.from([1]), programId, associatedTokenProgramId);
    }
    exports.createAssociatedTokenAccountIdempotentInstruction = createAssociatedTokenAccountIdempotentInstruction;
    function buildAssociatedTokenAccountInstruction(payer, associatedToken, owner, mint, instructionData, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: associatedToken, isSigner: false, isWritable: true },
        { pubkey: owner, isSigner: false, isWritable: false },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: instructionData
      });
    }
    function createRecoverNestedInstruction(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, ownerMint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: nestedAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: nestedMint, isSigner: false, isWritable: false },
        { pubkey: destinationAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerAssociatedToken, isSigner: false, isWritable: true },
        { pubkey: ownerMint, isSigner: false, isWritable: false },
        { pubkey: owner, isSigner: true, isWritable: true },
        { pubkey: programId, isSigner: false, isWritable: false }
      ];
      return new web3_js_1.TransactionInstruction({
        keys,
        programId: associatedTokenProgramId,
        data: Buffer.from([2])
      });
    }
    exports.createRecoverNestedInstruction = createRecoverNestedInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js
var require_createAssociatedTokenAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAssociatedTokenAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccount(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports.createAssociatedTokenAccount = createAssociatedTokenAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js
var require_createAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var initializeAccount_js_1 = require_initializeAccount();
    var mint_js_1 = require_mint();
    var createAssociatedTokenAccount_js_1 = require_createAssociatedTokenAccount();
    function createAccount(connection, payer, mint, owner, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!keypair)
          return yield (0, createAssociatedTokenAccount_js_1.createAssociatedTokenAccount)(connection, payer, mint, owner, confirmOptions, programId);
        const mintState = yield (0, mint_js_1.getMint)(connection, mint, confirmOptions === null || confirmOptions === void 0 ? void 0 : confirmOptions.commitment, programId);
        const space = (0, extensionType_js_1.getAccountLenForMint)(mintState);
        const lamports = yield connection.getMinimumBalanceForRentExemption(space);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space,
          lamports,
          programId
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, mint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports.createAccount = createAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js
var require_createAssociatedTokenAccountIdempotent = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createAssociatedTokenAccountIdempotent.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAssociatedTokenAccountIdempotent = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function createAssociatedTokenAccountIdempotent(connection, payer, mint, owner, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, false, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountIdempotentInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
        return associatedToken;
      });
    }
    exports.createAssociatedTokenAccountIdempotent = createAssociatedTokenAccountIdempotent;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js
var require_initializeMint2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeMint2InstructionUnchecked = exports.decodeInitializeMint2Instruction = exports.createInitializeMint2Instruction = exports.initializeMint2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeMint2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMint2Instruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeMint2InstructionData.span);
      exports.initializeMint2InstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint2,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeMint2Instruction = createInitializeMint2Instruction;
    function decodeInitializeMint2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeMint2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMint2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeInitializeMint2Instruction = decodeInitializeMint2Instruction;
    function decodeInitializeMint2InstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports.initializeMint2InstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports.decodeInitializeMint2InstructionUnchecked = decodeInitializeMint2InstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createMint.js
var require_createMint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createMint.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMint = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var initializeMint2_js_1 = require_initializeMint2();
    var mint_js_1 = require_mint();
    function createMint(connection, payer, mintAuthority, freezeAuthority, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, mint_js_1.getMinimumBalanceForRentExemptMint)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mint_js_1.MINT_SIZE,
          lamports,
          programId
        }), (0, initializeMint2_js_1.createInitializeMint2Instruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports.createMint = createMint;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js
var require_initializeMultisig = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeMultisigInstructionUnchecked = exports.decodeInitializeMultisigInstruction = exports.createInitializeMultisigInstruction = exports.initializeMultisigInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeMultisigInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("m")
    ]);
    function createInitializeMultisigInstruction(account, signers, m, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      for (const signer of signers) {
        keys.push({
          pubkey: signer instanceof web3_js_1.PublicKey ? signer : signer.publicKey,
          isSigner: false,
          isWritable: false
        });
      }
      const data = Buffer.alloc(exports.initializeMultisigInstructionData.span);
      exports.initializeMultisigInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMultisig,
        m
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeMultisigInstruction = createInitializeMultisigInstruction;
    function decodeInitializeMultisigInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeMultisigInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, rent, signers }, data } = decodeInitializeMultisigInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMultisig)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !rent || !signers.length)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data
      };
    }
    exports.decodeInitializeMultisigInstruction = decodeInitializeMultisigInstruction;
    function decodeInitializeMultisigInstructionUnchecked({ programId, keys: [account, rent, ...signers], data }) {
      return {
        programId,
        keys: {
          account,
          rent,
          signers
        },
        data: exports.initializeMultisigInstructionData.decode(data)
      };
    }
    exports.decodeInitializeMultisigInstructionUnchecked = decodeInitializeMultisigInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js
var require_createMultisig = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createMultisig.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMultisig = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var multisig_js_1 = require_multisig();
    function createMultisig(connection, payer, signers, m, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const lamports = yield (0, multisig_js_1.getMinimumBalanceForRentExemptMultisig)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: multisig_js_1.MULTISIG_SIZE,
          lamports,
          programId
        }), (0, initializeMultisig_js_1.createInitializeMultisigInstruction)(keypair.publicKey, signers, m, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports.createMultisig = createMultisig;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js
var require_createNativeMint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/createNativeMint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateNativeMintInstruction = exports.createNativeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.createNativeMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createCreateNativeMintInstruction(payer, nativeMintId = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: nativeMintId, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports.createNativeMintInstructionData.span);
      exports.createNativeMintInstructionData.encode({ instruction: types_js_1.TokenInstruction.CreateNativeMint }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createCreateNativeMintInstruction = createCreateNativeMintInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js
var require_createNativeMint2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createNativeMint.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNativeMint = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var createNativeMint_js_1 = require_createNativeMint();
    function createNativeMint(connection, payer, confirmOptions, nativeMint = constants_js_1.NATIVE_MINT_2022, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, createNativeMint_js_1.createCreateNativeMintInstruction)(payer.publicKey, nativeMint, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports.createNativeMint = createNativeMint;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js
var require_syncNative = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/syncNative.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSyncNativeInstructionUnchecked = exports.decodeSyncNativeInstruction = exports.createSyncNativeInstruction = exports.syncNativeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.syncNativeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createSyncNativeInstruction(account, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.syncNativeInstructionData.span);
      exports.syncNativeInstructionData.encode({ instruction: types_js_1.TokenInstruction.SyncNative }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createSyncNativeInstruction = createSyncNativeInstruction;
    function decodeSyncNativeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.syncNativeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeSyncNativeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SyncNative)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports.decodeSyncNativeInstruction = decodeSyncNativeInstruction;
    function decodeSyncNativeInstructionUnchecked({ programId, keys: [account], data }) {
      return {
        programId,
        keys: {
          account
        },
        data: exports.syncNativeInstructionData.decode(data)
      };
    }
    exports.decodeSyncNativeInstructionUnchecked = decodeSyncNativeInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js
var require_createWrappedNativeAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/createWrappedNativeAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWrappedNativeAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var syncNative_js_1 = require_syncNative();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    var createAccount_js_1 = require_createAccount();
    function createWrappedNativeAccount(connection, payer, owner, amount, keypair, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, nativeMint = constants_js_1.NATIVE_MINT) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!amount)
          return yield (0, createAccount_js_1.createAccount)(connection, payer, nativeMint, owner, keypair, confirmOptions, programId);
        if (!keypair) {
          const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nativeMint, owner, false, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID);
          const transaction2 = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, nativeMint, programId, constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID), web3_js_1.SystemProgram.transfer({
            fromPubkey: payer.publicKey,
            toPubkey: associatedToken,
            lamports: amount
          }), (0, syncNative_js_1.createSyncNativeInstruction)(associatedToken, programId));
          yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction2, [payer], confirmOptions);
          return associatedToken;
        }
        const lamports = yield (0, account_js_1.getMinimumBalanceForRentExemptAccount)(connection);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: account_js_1.ACCOUNT_SIZE,
          lamports,
          programId
        }), web3_js_1.SystemProgram.transfer({
          fromPubkey: payer.publicKey,
          toPubkey: keypair.publicKey,
          lamports: amount
        }), (0, initializeAccount_js_1.createInitializeAccountInstruction)(keypair.publicKey, nativeMint, owner, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports.createWrappedNativeAccount = createWrappedNativeAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js
var require_freezeAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/freezeAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFreezeAccountInstructionUnchecked = exports.decodeFreezeAccountInstruction = exports.createFreezeAccountInstruction = exports.freezeAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.freezeAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createFreezeAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports.freezeAccountInstructionData.span);
      exports.freezeAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.FreezeAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createFreezeAccountInstruction = createFreezeAccountInstruction;
    function decodeFreezeAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.freezeAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeFreezeAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.FreezeAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports.decodeFreezeAccountInstruction = decodeFreezeAccountInstruction;
    function decodeFreezeAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports.freezeAccountInstructionData.decode(data)
      };
    }
    exports.decodeFreezeAccountInstructionUnchecked = decodeFreezeAccountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js
var require_freezeAccount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/freezeAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.freezeAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var freezeAccount_js_1 = require_freezeAccount();
    var internal_js_1 = require_internal2();
    function freezeAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, freezeAccount_js_1.createFreezeAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.freezeAccount = freezeAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js
var require_getOrCreateAssociatedTokenAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/getOrCreateAssociatedTokenAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getOrCreateAssociatedTokenAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var account_js_1 = require_account();
    var mint_js_1 = require_mint();
    function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const associatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
        let account;
        try {
          account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
        } catch (error) {
          if (error instanceof errors_js_1.TokenAccountNotFoundError || error instanceof errors_js_1.TokenInvalidAccountOwnerError) {
            try {
              const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));
              yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
            } catch (error2) {
            }
            account = yield (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);
          } else {
            throw error;
          }
        }
        if (!account.mint.equals(mint))
          throw new errors_js_1.TokenInvalidMintError();
        if (!account.owner.equals(owner))
          throw new errors_js_1.TokenInvalidOwnerError();
        return account;
      });
    }
    exports.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js
var require_mintTo = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/mintTo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMintToInstructionUnchecked = exports.decodeMintToInstruction = exports.createMintToInstruction = exports.mintToInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.mintToInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createMintToInstruction(mint, destination, authority, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports.mintToInstructionData.span);
      exports.mintToInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintTo,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createMintToInstruction = createMintToInstruction;
    function decodeMintToInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.mintToInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintTo)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports.decodeMintToInstruction = decodeMintToInstruction;
    function decodeMintToInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports.mintToInstructionData.decode(data)
      };
    }
    exports.decodeMintToInstructionUnchecked = decodeMintToInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js
var require_mintTo2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/mintTo.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mintTo = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var mintTo_js_1 = require_mintTo();
    var internal_js_1 = require_internal2();
    function mintTo(connection, payer, mint, destination, authority, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintTo_js_1.createMintToInstruction)(mint, destination, authorityPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.mintTo = mintTo;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js
var require_mintToChecked = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/mintToChecked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeMintToCheckedInstructionUnchecked = exports.decodeMintToCheckedInstruction = exports.createMintToCheckedInstruction = exports.mintToCheckedInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.mintToCheckedInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.u64)("amount"),
      (0, buffer_layout_1.u8)("decimals")
    ]);
    function createMintToCheckedInstruction(mint, destination, authority, amount, decimals, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports.mintToCheckedInstructionData.span);
      exports.mintToCheckedInstructionData.encode({
        instruction: types_js_1.TokenInstruction.MintToChecked,
        amount: BigInt(amount),
        decimals
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createMintToCheckedInstruction = createMintToCheckedInstruction;
    function decodeMintToCheckedInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.mintToCheckedInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, destination, authority, multiSigners }, data } = decodeMintToCheckedInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.MintToChecked)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !destination || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data
      };
    }
    exports.decodeMintToCheckedInstruction = decodeMintToCheckedInstruction;
    function decodeMintToCheckedInstructionUnchecked({ programId, keys: [mint, destination, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          mint,
          destination,
          authority,
          multiSigners
        },
        data: exports.mintToCheckedInstructionData.decode(data)
      };
    }
    exports.decodeMintToCheckedInstructionUnchecked = decodeMintToCheckedInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js
var require_mintToChecked2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/mintToChecked.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mintToChecked = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var mintToChecked_js_1 = require_mintToChecked();
    var internal_js_1 = require_internal2();
    function mintToChecked(connection, payer, mint, destination, authority, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, mintToChecked_js_1.createMintToCheckedInstruction)(mint, destination, authorityPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.mintToChecked = mintToChecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js
var require_recoverNested = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/recoverNested.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverNested = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var associatedTokenAccount_js_1 = require_associatedTokenAccount();
    var mint_js_1 = require_mint();
    function recoverNested(connection, payer, owner, mint, nestedMint, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const ownerAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(mint, owner.publicKey, false, programId, associatedTokenProgramId);
        const destinationAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, owner.publicKey, false, programId, associatedTokenProgramId);
        const nestedAssociatedToken = (0, mint_js_1.getAssociatedTokenAddressSync)(nestedMint, ownerAssociatedToken, true, programId, associatedTokenProgramId);
        const transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createRecoverNestedInstruction)(nestedAssociatedToken, nestedMint, destinationAssociatedToken, ownerAssociatedToken, mint, owner.publicKey, programId, associatedTokenProgramId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, owner], confirmOptions);
      });
    }
    exports.recoverNested = recoverNested;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js
var require_revoke = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/revoke.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeRevokeInstructionUnchecked = exports.decodeRevokeInstruction = exports.createRevokeInstruction = exports.revokeInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.revokeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createRevokeInstruction(account, owner, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], owner, multiSigners);
      const data = Buffer.alloc(exports.revokeInstructionData.span);
      exports.revokeInstructionData.encode({ instruction: types_js_1.TokenInstruction.Revoke }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createRevokeInstruction = createRevokeInstruction;
    function decodeRevokeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.revokeInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, owner, multiSigners }, data } = decodeRevokeInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Revoke)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeRevokeInstruction = decodeRevokeInstruction;
    function decodeRevokeInstructionUnchecked({ programId, keys: [account, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          owner,
          multiSigners
        },
        data: exports.revokeInstructionData.decode(data)
      };
    }
    exports.decodeRevokeInstructionUnchecked = decodeRevokeInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/revoke.js
var require_revoke2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/revoke.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revoke = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var revoke_js_1 = require_revoke();
    var internal_js_1 = require_internal2();
    function revoke(connection, payer, account, owner, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, revoke_js_1.createRevokeInstruction)(account, ownerPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.revoke = revoke;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js
var require_setAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/setAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeSetAuthorityInstructionUnchecked = exports.decodeSetAuthorityInstruction = exports.createSetAuthorityInstruction = exports.setAuthorityInstructionData = exports.AuthorityType = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var AuthorityType;
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
      AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
      AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
      AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
      AuthorityType2[AuthorityType2["TransferFeeConfig"] = 4] = "TransferFeeConfig";
      AuthorityType2[AuthorityType2["WithheldWithdraw"] = 5] = "WithheldWithdraw";
      AuthorityType2[AuthorityType2["CloseMint"] = 6] = "CloseMint";
      AuthorityType2[AuthorityType2["InterestRate"] = 7] = "InterestRate";
      AuthorityType2[AuthorityType2["PermanentDelegate"] = 8] = "PermanentDelegate";
      AuthorityType2[AuthorityType2["ConfidentialTransferMint"] = 9] = "ConfidentialTransferMint";
      AuthorityType2[AuthorityType2["TransferHookProgramId"] = 10] = "TransferHookProgramId";
      AuthorityType2[AuthorityType2["ConfidentialTransferFeeConfig"] = 11] = "ConfidentialTransferFeeConfig";
      AuthorityType2[AuthorityType2["MetadataPointer"] = 12] = "MetadataPointer";
    })(AuthorityType || (exports.AuthorityType = AuthorityType = {}));
    exports.setAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("authorityType"),
      (0, buffer_layout_1.u8)("newAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("newAuthority")
    ]);
    function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([{ pubkey: account, isSigner: false, isWritable: true }], currentAuthority, multiSigners);
      const data = Buffer.alloc(exports.setAuthorityInstructionData.span);
      exports.setAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.SetAuthority,
        authorityType,
        newAuthorityOption: newAuthority ? 1 : 0,
        newAuthority: newAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createSetAuthorityInstruction = createSetAuthorityInstruction;
    function decodeSetAuthorityInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.setAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, currentAuthority, multiSigners }, data } = decodeSetAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.SetAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !currentAuthority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data
      };
    }
    exports.decodeSetAuthorityInstruction = decodeSetAuthorityInstruction;
    function decodeSetAuthorityInstructionUnchecked({ programId, keys: [account, currentAuthority, ...multiSigners], data }) {
      const { instruction, authorityType, newAuthorityOption, newAuthority } = exports.setAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          account,
          currentAuthority,
          multiSigners
        },
        data: {
          instruction,
          authorityType,
          newAuthority: newAuthorityOption ? newAuthority : null
        }
      };
    }
    exports.decodeSetAuthorityInstructionUnchecked = decodeSetAuthorityInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js
var require_setAuthority2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/setAuthority.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAuthority = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var setAuthority_js_1 = require_setAuthority();
    var internal_js_1 = require_internal2();
    function setAuthority(connection, payer, account, currentAuthority, authorityType, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [currentAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(currentAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, setAuthority_js_1.createSetAuthorityInstruction)(account, currentAuthorityPublicKey, authorityType, newAuthority, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.setAuthority = setAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js
var require_syncNative2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/syncNative.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syncNative = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var syncNative_js_1 = require_syncNative();
    function syncNative(connection, payer, account, confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, syncNative_js_1.createSyncNativeInstruction)(account, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);
      });
    }
    exports.syncNative = syncNative;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js
var require_thawAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/thawAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeThawAccountInstructionUnchecked = exports.decodeThawAccountInstruction = exports.createThawAccountInstruction = exports.thawAccountInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.thawAccountInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction")]);
    function createThawAccountInstruction(account, mint, authority, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ], authority, multiSigners);
      const data = Buffer.alloc(exports.thawAccountInstructionData.span);
      exports.thawAccountInstructionData.encode({ instruction: types_js_1.TokenInstruction.ThawAccount }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createThawAccountInstruction = createThawAccountInstruction;
    function decodeThawAccountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.thawAccountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, authority, multiSigners }, data } = decodeThawAccountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.ThawAccount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !authority)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data
      };
    }
    exports.decodeThawAccountInstruction = decodeThawAccountInstruction;
    function decodeThawAccountInstructionUnchecked({ programId, keys: [account, mint, authority, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          authority,
          multiSigners
        },
        data: exports.thawAccountInstructionData.decode(data)
      };
    }
    exports.decodeThawAccountInstructionUnchecked = decodeThawAccountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js
var require_thawAccount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/thawAccount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thawAccount = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var thawAccount_js_1 = require_thawAccount();
    var internal_js_1 = require_internal2();
    function thawAccount(connection, payer, account, mint, authority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [authorityPublicKey, signers] = (0, internal_js_1.getSigners)(authority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, thawAccount_js_1.createThawAccountInstruction)(account, mint, authorityPublicKey, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.thawAccount = thawAccount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js
var require_transfer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/transfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTransferInstructionUnchecked = exports.decodeTransferInstruction = exports.createTransferInstruction = exports.transferInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    exports.transferInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)("instruction"), (0, buffer_layout_utils_1.u64)("amount")]);
    function createTransferInstruction(source, destination, owner, amount, multiSigners = [], programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: source, isSigner: false, isWritable: true },
        { pubkey: destination, isSigner: false, isWritable: true }
      ], owner, multiSigners);
      const data = Buffer.alloc(exports.transferInstructionData.span);
      exports.transferInstructionData.encode({
        instruction: types_js_1.TokenInstruction.Transfer,
        amount: BigInt(amount)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createTransferInstruction = createTransferInstruction;
    function decodeTransferInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.transferInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { source, destination, owner, multiSigners }, data } = decodeTransferInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.Transfer)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!source || !destination || !owner)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data
      };
    }
    exports.decodeTransferInstruction = decodeTransferInstruction;
    function decodeTransferInstructionUnchecked({ programId, keys: [source, destination, owner, ...multiSigners], data }) {
      return {
        programId,
        keys: {
          source,
          destination,
          owner,
          multiSigners
        },
        data: exports.transferInstructionData.decode(data)
      };
    }
    exports.decodeTransferInstructionUnchecked = decodeTransferInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/transfer.js
var require_transfer2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/transfer.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transfer = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var transfer_js_1 = require_transfer();
    var internal_js_1 = require_internal2();
    function transfer(connection, payer, source, destination, owner, amount, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transfer_js_1.createTransferInstruction)(source, destination, ownerPublicKey, amount, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.transfer = transfer;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js
var require_transferChecked2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/transferChecked.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transferChecked = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var transferChecked_js_1 = require_transferChecked();
    var internal_js_1 = require_internal2();
    function transferChecked(connection, payer, source, mint, destination, owner, amount, decimals, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [ownerPublicKey, signers] = (0, internal_js_1.getSigners)(owner, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, transferChecked_js_1.createTransferCheckedInstruction)(source, mint, destination, ownerPublicKey, amount, decimals, multiSigners, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.transferChecked = transferChecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js
var require_uiAmountToAmount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/uiAmountToAmount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeUiAmountToAmountInstructionUnchecked = exports.decodeUiAmountToAmountInstruction = exports.createUiAmountToAmountInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    function createUiAmountToAmountInstruction(mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: false }];
      const buf = Buffer.from(amount, "utf8");
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(buf.length, "amount")
      ]);
      const data = Buffer.alloc(uiAmountToAmountInstructionData.span);
      uiAmountToAmountInstructionData.encode({
        instruction: types_js_1.TokenInstruction.UiAmountToAmount,
        amount: buf
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createUiAmountToAmountInstruction = createUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(instruction.data.length - 1, "amount")
      ]);
      if (instruction.data.length !== uiAmountToAmountInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeUiAmountToAmountInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.UiAmountToAmount)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeUiAmountToAmountInstruction = decodeUiAmountToAmountInstruction;
    function decodeUiAmountToAmountInstructionUnchecked({ programId, keys: [mint], data }) {
      const uiAmountToAmountInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.blob)(data.length - 1, "amount")
      ]);
      return {
        programId,
        keys: {
          mint
        },
        data: uiAmountToAmountInstructionData.decode(data)
      };
    }
    exports.decodeUiAmountToAmountInstructionUnchecked = decodeUiAmountToAmountInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js
var require_uiAmountToAmount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/uiAmountToAmount.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uiAmountToAmount = void 0;
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function uiAmountToAmount(connection, payer, mint, amount, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const transaction = new web3_js_1.Transaction().add((0, uiAmountToAmount_js_1.createUiAmountToAmountInstruction)(mint, amount, programId));
        const { returnData, err } = (yield connection.simulateTransaction(transaction, [payer], false)).value;
        if (returnData) {
          const data = Buffer.from(returnData.data[0], returnData.data[1]);
          return (0, buffer_layout_utils_1.u64)().decode(data);
        }
        return err;
      });
    }
    exports.uiAmountToAmount = uiAmountToAmount;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/index.js
var require_actions6 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/actions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_amountToUiAmount2(), exports);
    __exportStar(require_approve2(), exports);
    __exportStar(require_approveChecked2(), exports);
    __exportStar(require_burn2(), exports);
    __exportStar(require_burnChecked2(), exports);
    __exportStar(require_closeAccount2(), exports);
    __exportStar(require_createAccount(), exports);
    __exportStar(require_createAssociatedTokenAccount(), exports);
    __exportStar(require_createAssociatedTokenAccountIdempotent(), exports);
    __exportStar(require_createMint(), exports);
    __exportStar(require_createMultisig(), exports);
    __exportStar(require_createNativeMint2(), exports);
    __exportStar(require_createWrappedNativeAccount(), exports);
    __exportStar(require_freezeAccount2(), exports);
    __exportStar(require_getOrCreateAssociatedTokenAccount(), exports);
    __exportStar(require_mintTo2(), exports);
    __exportStar(require_mintToChecked2(), exports);
    __exportStar(require_recoverNested(), exports);
    __exportStar(require_revoke2(), exports);
    __exportStar(require_setAuthority2(), exports);
    __exportStar(require_syncNative2(), exports);
    __exportStar(require_thawAccount2(), exports);
    __exportStar(require_transfer2(), exports);
    __exportStar(require_transferChecked2(), exports);
    __exportStar(require_uiAmountToAmount2(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js
var require_initializeMint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeMintInstructionUnchecked = exports.decodeInitializeMintInstruction = exports.createInitializeMintInstruction = exports.initializeMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("decimals"),
      (0, buffer_layout_utils_1.publicKey)("mintAuthority"),
      (0, buffer_layout_1.u8)("freezeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("freezeAuthority")
    ]);
    function createInitializeMintInstruction(mint, decimals, mintAuthority, freezeAuthority, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports.initializeMintInstructionData.span);
      exports.initializeMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMint,
        decimals,
        mintAuthority,
        freezeAuthorityOption: freezeAuthority ? 1 : 0,
        freezeAuthority: freezeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeMintInstruction = createInitializeMintInstruction;
    function decodeInitializeMintInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeMintInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint, rent }, data } = decodeInitializeMintInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMint)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data
      };
    }
    exports.decodeInitializeMintInstruction = decodeInitializeMintInstruction;
    function decodeInitializeMintInstructionUnchecked({ programId, keys: [mint, rent], data }) {
      const { instruction, decimals, mintAuthority, freezeAuthorityOption, freezeAuthority } = exports.initializeMintInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint,
          rent
        },
        data: {
          instruction,
          decimals,
          mintAuthority,
          freezeAuthority: freezeAuthorityOption ? freezeAuthority : null
        }
      };
    }
    exports.decodeInitializeMintInstructionUnchecked = decodeInitializeMintInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js
var require_instructions6 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateRateInterestBearingMintInstruction = exports.createInitializeInterestBearingMintInstruction = exports.interestBearingMintUpdateRateInstructionData = exports.interestBearingMintInitializeInstructionData = exports.InterestBearingMintInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    var InterestBearingMintInstruction;
    (function(InterestBearingMintInstruction2) {
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["Initialize"] = 0] = "Initialize";
      InterestBearingMintInstruction2[InterestBearingMintInstruction2["UpdateRate"] = 1] = "UpdateRate";
    })(InterestBearingMintInstruction || (exports.InterestBearingMintInstruction = InterestBearingMintInstruction = {}));
    exports.interestBearingMintInitializeInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      // TODO: Make this an optional public key
      (0, buffer_layout_utils_1.publicKey)("rateAuthority"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    exports.interestBearingMintUpdateRateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("interestBearingMintInstruction"),
      (0, buffer_layout_1.s16)("rate")
    ]);
    function createInitializeInterestBearingMintInstruction(mint, rateAuthority, rate, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.interestBearingMintInitializeInstructionData.span);
      exports.interestBearingMintInitializeInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.Initialize,
        rateAuthority,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeInterestBearingMintInstruction = createInitializeInterestBearingMintInstruction;
    function createUpdateRateInterestBearingMintInstruction(mint, rateAuthority, rate, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      const keys = (0, internal_js_1.addSigners)([
        { pubkey: mint, isSigner: false, isWritable: true },
        { pubkey: rateAuthority, isSigner: !multiSigners.length, isWritable: false }
      ], rateAuthority, multiSigners);
      const data = Buffer.alloc(exports.interestBearingMintUpdateRateInstructionData.span);
      exports.interestBearingMintUpdateRateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InterestBearingMintExtension,
        interestBearingMintInstruction: InterestBearingMintInstruction.UpdateRate,
        rate
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createUpdateRateInterestBearingMintInstruction = createUpdateRateInterestBearingMintInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js
var require_actions7 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateRateInterestBearingMint = exports.createInterestBearingMint = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var internal_js_1 = require_internal2();
    var constants_js_1 = require_constants();
    var initializeMint_js_1 = require_initializeMint();
    var extensionType_js_1 = require_extensionType();
    var instructions_js_1 = require_instructions6();
    function createInterestBearingMint(connection, payer, mintAuthority, freezeAuthority, rateAuthority, rate, decimals, keypair = web3_js_1.Keypair.generate(), confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintLen = (0, extensionType_js_1.getMintLen)([extensionType_js_1.ExtensionType.InterestBearingConfig]);
        const lamports = yield connection.getMinimumBalanceForRentExemption(mintLen);
        const transaction = new web3_js_1.Transaction().add(web3_js_1.SystemProgram.createAccount({
          fromPubkey: payer.publicKey,
          newAccountPubkey: keypair.publicKey,
          space: mintLen,
          lamports,
          programId
        }), (0, instructions_js_1.createInitializeInterestBearingMintInstruction)(keypair.publicKey, rateAuthority, rate, programId), (0, initializeMint_js_1.createInitializeMintInstruction)(keypair.publicKey, decimals, mintAuthority, freezeAuthority, programId));
        yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, keypair], confirmOptions);
        return keypair.publicKey;
      });
    }
    exports.createInterestBearingMint = createInterestBearingMint;
    function updateRateInterestBearingMint(connection, payer, mint, rateAuthority, rate, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [rateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(rateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, instructions_js_1.createUpdateRateInterestBearingMintInstruction)(mint, rateAuthorityPublicKey, rate, signers, programId));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, rateAuthority, ...signers], confirmOptions);
      });
    }
    exports.updateRateInterestBearingMint = updateRateInterestBearingMint;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js
var require_interestBearingMint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/interestBearingMint/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions7(), exports);
    __exportStar(require_instructions6(), exports);
    __exportStar(require_state3(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js
var require_instructions7 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/instructions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateMetadataPointerInstruction = exports.updateMetadataPointerData = exports.createInitializeMetadataPointerInstruction = exports.initializeMetadataPointerData = exports.MetadataPointerInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    var internal_js_1 = require_internal();
    var MetadataPointerInstruction;
    (function(MetadataPointerInstruction2) {
      MetadataPointerInstruction2[MetadataPointerInstruction2["Initialize"] = 0] = "Initialize";
      MetadataPointerInstruction2[MetadataPointerInstruction2["Update"] = 1] = "Update";
    })(MetadataPointerInstruction || (exports.MetadataPointerInstruction = MetadataPointerInstruction = {}));
    exports.initializeMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("authority"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createInitializeMetadataPointerInstruction(mint, authority, metadataAddress, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeMetadataPointerData.span);
      exports.initializeMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Initialize,
        authority: authority !== null && authority !== void 0 ? authority : web3_js_1.PublicKey.default,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeMetadataPointerInstruction = createInitializeMetadataPointerInstruction;
    exports.updateMetadataPointerData = (0, buffer_layout_1.struct)([
      // prettier-ignore
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("metadataPointerInstruction"),
      (0, buffer_layout_utils_1.publicKey)("metadataAddress")
    ]);
    function createUpdateMetadataPointerInstruction(mint, authority, metadataAddress, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = (0, internal_js_1.addSigners)([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);
      const data = Buffer.alloc(exports.updateMetadataPointerData.span);
      exports.updateMetadataPointerData.encode({
        instruction: types_js_1.TokenInstruction.MetadataPointerExtension,
        metadataPointerInstruction: MetadataPointerInstruction.Update,
        metadataAddress: metadataAddress !== null && metadataAddress !== void 0 ? metadataAddress : web3_js_1.PublicKey.default
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createUpdateMetadataPointerInstruction = createUpdateMetadataPointerInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js
var require_metadataPointer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/metadataPointer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_instructions7(), exports);
    __exportStar(require_state5(), exports);
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/errors.js
var require_errors3 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyNotFoundError = exports.ImmutableMetadataError = exports.IncorrectUpdateAuthorityError = exports.IncorrectMintAuthorityError = exports.MintHasNoMintAuthorityError = exports.IncorrectAccountError = exports.TokenMetadataError = void 0;
    var TokenMetadataError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    exports.TokenMetadataError = TokenMetadataError;
    var IncorrectAccountError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectAccountError";
      }
    };
    exports.IncorrectAccountError = IncorrectAccountError;
    var MintHasNoMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "MintHasNoMintAuthorityError";
      }
    };
    exports.MintHasNoMintAuthorityError = MintHasNoMintAuthorityError;
    var IncorrectMintAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectMintAuthorityError";
      }
    };
    exports.IncorrectMintAuthorityError = IncorrectMintAuthorityError;
    var IncorrectUpdateAuthorityError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "IncorrectUpdateAuthorityError";
      }
    };
    exports.IncorrectUpdateAuthorityError = IncorrectUpdateAuthorityError;
    var ImmutableMetadataError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "ImmutableMetadataError";
      }
    };
    exports.ImmutableMetadataError = ImmutableMetadataError;
    var KeyNotFoundError = class extends TokenMetadataError {
      constructor() {
        super(...arguments);
        this.name = "KeyNotFoundError";
      }
    };
    exports.KeyNotFoundError = KeyNotFoundError;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/errors/dist/index.browser.cjs
var require_index_browser = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/errors/dist/index.browser.cjs"(exports) {
    "use strict";
    var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
    var SOLANA_ERROR__INVALID_NONCE = 2;
    var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
    var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
    var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
    var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
    var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
    var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
    var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
    var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
    var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
    var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
    var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
    var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
    var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
    var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
    var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
    var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
    var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
    var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
    var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
    var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
    var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
    var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
    var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
    var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
    var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
    var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
    var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
    var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
    var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
    var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
    var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
    var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
    var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
    var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
    var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
    var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
    var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
    var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
    var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
    var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
    var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
    var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
    var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
    var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
    var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
    var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
    var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
    var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
    var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
    var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
    var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
    var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
    var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
    var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
    var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
    var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
    var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
    var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
    var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
    var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
    var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
    var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
    var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
    var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
    var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
    var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
    var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
    var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
    var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
    var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
    var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
    var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
    var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
    var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
    var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
    var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
    var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
    var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
    var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
    var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
    var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
    var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
    var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
    var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
    var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
    var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
    var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
    var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
    var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
    var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
    var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
    var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
    var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
    var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
    var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
    var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
    var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
    var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
    var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
    var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
    var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
    var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
    var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
    var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
    var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
    var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
    var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
    var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
    var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
    var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
    var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
    var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
    var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
    var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
    var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
    var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
    var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
    var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = 819e4;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = 8190003;
    var SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = 8190004;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = 99e5;
    var SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
    var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
    var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
    var SolanaErrorMessages = {
      [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
      [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
      [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
      [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
      [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
      [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
      [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
      [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
      [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
      [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
      [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
      [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
      [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
      [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
      [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
      [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
      [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
      [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
      [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
      [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
      [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
      [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
      [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
      [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
      [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
      [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
      [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
      [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
      [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
      [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
      [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
      [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
      [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
      [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
      [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
      [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
      [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
      [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
      [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
      [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
      [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
      [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
      [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
      [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
      [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
      [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
      [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
      [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
      [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
      [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
      [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
      [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
      [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
      [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
      [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
      [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
      [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
      [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
      [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST]: "Either the notification name must end in 'Notifications' or the API must supply a subscription creator function for the notification '$notificationName' to map between the notification name and the subscribe/unsubscribe method names.",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED]: "WebSocket connection closed",
      [SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT]: "WebSocket failed to connect",
      [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
      [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
      [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
      [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
      [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
      [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
      [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",
      [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
      [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
      [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
      [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-8.64e15, 8.64e15]. `$value` given",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
      [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
      [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
      [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
      [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
      [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
      [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
      [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
      [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
      [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
      [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
      [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
      [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
      [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
      [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
      [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
      [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
      [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
      [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
      [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
      [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
      [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
      [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
      [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
      [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
      [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
      [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
      [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
      [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
    };
    var START_INDEX = "i";
    var TYPE = "t";
    function getHumanReadableErrorMessage(code, context = {}) {
      const messageFormatString = SolanaErrorMessages[code];
      if (messageFormatString.length === 0) {
        return "";
      }
      let state;
      function commitStateUpTo(endIndex) {
        if (state[TYPE] === 2) {
          const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
          fragments.push(
            variableName in context ? `${context[variableName]}` : `$${variableName}`
          );
        } else if (state[TYPE] === 1) {
          fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
        }
      }
      const fragments = [];
      messageFormatString.split("").forEach((char, ii) => {
        if (ii === 0) {
          state = {
            [START_INDEX]: 0,
            [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
            /* Text */
          };
          return;
        }
        let nextState;
        switch (state[TYPE]) {
          case 0:
            nextState = {
              [START_INDEX]: ii,
              [TYPE]: 1
              /* Text */
            };
            break;
          case 1:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            }
            break;
          case 2:
            if (char === "\\") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 0
                /* EscapeSequence */
              };
            } else if (char === "$") {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 2
                /* Variable */
              };
            } else if (!char.match(/\w/)) {
              nextState = {
                [START_INDEX]: ii,
                [TYPE]: 1
                /* Text */
              };
            }
            break;
        }
        if (nextState) {
          if (state !== nextState) {
            commitStateUpTo(ii);
          }
          state = nextState;
        }
      });
      commitStateUpTo();
      return fragments.join("");
    }
    function getErrorMessage(code, context = {}) {
      if (true) {
        return getHumanReadableErrorMessage(code, context);
      } else {
        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
        if (Object.keys(context).length) {
          decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
        }
        return `${decodingAdviceMessage}\``;
      }
    }
    function isSolanaError(e, code) {
      const isSolanaError2 = e instanceof Error && e.name === "SolanaError";
      if (isSolanaError2) {
        if (code !== void 0) {
          return e.context.__code === code;
        }
        return true;
      }
      return false;
    }
    var SolanaError = class extends Error {
      constructor(...[code, contextAndErrorOptions]) {
        let context;
        let errorOptions;
        if (contextAndErrorOptions) {
          const { cause, ...contextRest } = contextAndErrorOptions;
          if (cause) {
            errorOptions = { cause };
          }
          if (Object.keys(contextRest).length > 0) {
            context = contextRest;
          }
        }
        const message = getErrorMessage(code, context);
        super(message, errorOptions);
        __publicField(this, "cause", this.cause);
        __publicField(this, "context");
        this.context = {
          __code: code,
          ...context
        };
        this.name = "SolanaError";
      }
    };
    function safeCaptureStackTrace(...args) {
      if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(...args);
      }
    }
    function getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {
      let rpcErrorName;
      let rpcErrorContext;
      if (typeof rpcEnumError === "string") {
        rpcErrorName = rpcEnumError;
      } else {
        rpcErrorName = Object.keys(rpcEnumError)[0];
        rpcErrorContext = rpcEnumError[rpcErrorName];
      }
      const codeOffset = orderedErrorNames.indexOf(rpcErrorName);
      const errorCode = errorCodeBaseOffset + codeOffset;
      const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);
      const err = new SolanaError(errorCode, errorContext);
      safeCaptureStackTrace(err, constructorOpt);
      return err;
    }
    var ORDERED_ERROR_NAMES = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "GenericError",
      "InvalidArgument",
      "InvalidInstructionData",
      "InvalidAccountData",
      "AccountDataTooSmall",
      "InsufficientFunds",
      "IncorrectProgramId",
      "MissingRequiredSignature",
      "AccountAlreadyInitialized",
      "UninitializedAccount",
      "UnbalancedInstruction",
      "ModifiedProgramId",
      "ExternalAccountLamportSpend",
      "ExternalAccountDataModified",
      "ReadonlyLamportChange",
      "ReadonlyDataModified",
      "DuplicateAccountIndex",
      "ExecutableModified",
      "RentEpochModified",
      "NotEnoughAccountKeys",
      "AccountDataSizeChanged",
      "AccountNotExecutable",
      "AccountBorrowFailed",
      "AccountBorrowOutstanding",
      "DuplicateAccountOutOfSync",
      "Custom",
      "InvalidError",
      "ExecutableDataModified",
      "ExecutableLamportChange",
      "ExecutableAccountNotRentExempt",
      "UnsupportedProgramId",
      "CallDepth",
      "MissingAccount",
      "ReentrancyNotAllowed",
      "MaxSeedLengthExceeded",
      "InvalidSeeds",
      "InvalidRealloc",
      "ComputationalBudgetExceeded",
      "PrivilegeEscalation",
      "ProgramEnvironmentSetupFailure",
      "ProgramFailedToComplete",
      "ProgramFailedToCompile",
      "Immutable",
      "IncorrectAuthority",
      "BorshIoError",
      "AccountNotRentExempt",
      "InvalidAccountOwner",
      "ArithmeticOverflow",
      "UnsupportedSysvar",
      "IllegalOwner",
      "MaxAccountsDataAllocationsExceeded",
      "MaxAccountsExceeded",
      "MaxInstructionTraceLengthExceeded",
      "BuiltinProgramsMustConsumeComputeUnits"
    ];
    function getSolanaErrorFromInstructionError(index, instructionError) {
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 4615001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                index,
                ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {
              return {
                code: rpcErrorContext,
                index
              };
            } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {
              return {
                encodedData: rpcErrorContext,
                index
              };
            }
            return { index };
          },
          orderedErrorNames: ORDERED_ERROR_NAMES,
          rpcEnumError: instructionError
        },
        getSolanaErrorFromInstructionError
      );
    }
    var ORDERED_ERROR_NAMES2 = [
      // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs
      // If this list ever gets too large, consider implementing a compression strategy like this:
      // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47
      "AccountInUse",
      "AccountLoadedTwice",
      "AccountNotFound",
      "ProgramAccountNotFound",
      "InsufficientFundsForFee",
      "InvalidAccountForFee",
      "AlreadyProcessed",
      "BlockhashNotFound",
      // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`
      "CallChainTooDeep",
      "MissingSignatureForFee",
      "InvalidAccountIndex",
      "SignatureFailure",
      "InvalidProgramForExecution",
      "SanitizeFailure",
      "ClusterMaintenance",
      "AccountBorrowOutstanding",
      "WouldExceedMaxBlockCostLimit",
      "UnsupportedVersion",
      "InvalidWritableAccount",
      "WouldExceedMaxAccountCostLimit",
      "WouldExceedAccountDataBlockLimit",
      "TooManyAccountLocks",
      "AddressLookupTableNotFound",
      "InvalidAddressLookupTableOwner",
      "InvalidAddressLookupTableData",
      "InvalidAddressLookupTableIndex",
      "InvalidRentPayingAccount",
      "WouldExceedMaxVoteCostLimit",
      "WouldExceedAccountDataTotalLimit",
      "DuplicateInstruction",
      "InsufficientFundsForRent",
      "MaxLoadedAccountsDataSizeExceeded",
      "InvalidLoadedAccountsDataSizeLimit",
      "ResanitizationNeeded",
      "ProgramExecutionTemporarilyRestricted",
      "UnbalancedTransaction"
    ];
    function getSolanaErrorFromTransactionError(transactionError) {
      if (typeof transactionError === "object" && "InstructionError" in transactionError) {
        return getSolanaErrorFromInstructionError(
          ...transactionError.InstructionError
        );
      }
      return getSolanaErrorFromRpcError(
        {
          errorCodeBaseOffset: 7050001,
          getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {
            if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {
              return {
                errorName: rpcErrorName,
                ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {
              return {
                index: rpcErrorContext
              };
            } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {
              return {
                accountIndex: rpcErrorContext.account_index
              };
            }
          },
          orderedErrorNames: ORDERED_ERROR_NAMES2,
          rpcEnumError: transactionError
        },
        getSolanaErrorFromTransactionError
      );
    }
    function getSolanaErrorFromJsonRpcError({ code, data, message }) {
      let out;
      if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {
        const { err, ...preflightErrorContext } = data;
        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;
        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {
          ...preflightErrorContext,
          ...causeObject
        });
      } else {
        let errorContext;
        switch (code) {
          case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:
          case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:
          case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:
          case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:
          case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:
          case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:
          case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:
            errorContext = { __serverMessage: message };
            break;
          default:
            if (typeof data === "object" && !Array.isArray(data)) {
              errorContext = data;
            }
        }
        out = new SolanaError(code, errorContext);
      }
      safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);
      return out;
    }
    exports.SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND;
    exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED;
    exports.SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT;
    exports.SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT;
    exports.SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND;
    exports.SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED;
    exports.SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS;
    exports.SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH;
    exports.SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY;
    exports.SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE;
    exports.SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = SOLANA_ERROR__ADDRESSES__MALFORMED_PDA;
    exports.SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED;
    exports.SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED;
    exports.SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE;
    exports.SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER;
    exports.SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE;
    exports.SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE;
    exports.SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED;
    exports.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY;
    exports.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS;
    exports.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL;
    exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH;
    exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH;
    exports.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH;
    exports.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE;
    exports.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH;
    exports.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH;
    exports.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH;
    exports.SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE;
    exports.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH;
    exports.SOLANA_ERROR__CODECS__INVALID_CONSTANT = SOLANA_ERROR__CODECS__INVALID_CONSTANT;
    exports.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT;
    exports.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT;
    exports.SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT;
    exports.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS;
    exports.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE;
    exports.SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE;
    exports.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE;
    exports.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE;
    exports.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES;
    exports.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE;
    exports.SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID;
    exports.SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR;
    exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS;
    exports.SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA;
    exports.SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH;
    exports.SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH;
    exports.SOLANA_ERROR__INVALID_NONCE = SOLANA_ERROR__INVALID_NONCE;
    exports.SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING;
    exports.SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE;
    exports.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE;
    exports.SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING = SOLANA_ERROR__INVARIANT_VIOLATION__WEBSOCKET_MESSAGE_ITERATOR_STATE_MISSING;
    exports.SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR;
    exports.SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = SOLANA_ERROR__JSON_RPC__INVALID_PARAMS;
    exports.SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = SOLANA_ERROR__JSON_RPC__INVALID_REQUEST;
    exports.SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND;
    exports.SOLANA_ERROR__JSON_RPC__PARSE_ERROR = SOLANA_ERROR__JSON_RPC__PARSE_ERROR;
    exports.SOLANA_ERROR__JSON_RPC__SCAN_ERROR = SOLANA_ERROR__JSON_RPC__SCAN_ERROR;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE;
    exports.SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION;
    exports.SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH;
    exports.SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH;
    exports.SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH;
    exports.SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY;
    exports.SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE;
    exports.SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE;
    exports.SOLANA_ERROR__MALFORMED_BIGINT_STRING = SOLANA_ERROR__MALFORMED_BIGINT_STRING;
    exports.SOLANA_ERROR__MALFORMED_NUMBER_STRING = SOLANA_ERROR__MALFORMED_NUMBER_STRING;
    exports.SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND;
    exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST = SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_REQUEST;
    exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID;
    exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CLOSED_BEFORE_MESSAGE_BUFFERED;
    exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_CONNECTION_CLOSED;
    exports.SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT = SOLANA_ERROR__RPC_SUBSCRIPTIONS__TRANSPORT_FAILED_TO_CONNECT;
    exports.SOLANA_ERROR__RPC__INTEGER_OVERFLOW = SOLANA_ERROR__RPC__INTEGER_OVERFLOW;
    exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR;
    exports.SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN;
    exports.SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER;
    exports.SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER;
    exports.SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS;
    exports.SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING;
    exports.SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED;
    exports.SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED;
    exports.SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION;
    exports.SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES;
    exports.SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME;
    exports.SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME;
    exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE;
    exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND;
    exports.SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT;
    exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE;
    exports.SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES;
    exports.SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE;
    exports.SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH;
    exports.SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING;
    exports.SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE;
    exports.SolanaError = SolanaError;
    exports.getSolanaErrorFromInstructionError = getSolanaErrorFromInstructionError;
    exports.getSolanaErrorFromJsonRpcError = getSolanaErrorFromJsonRpcError;
    exports.getSolanaErrorFromTransactionError = getSolanaErrorFromTransactionError;
    exports.isSolanaError = isSolanaError;
    exports.safeCaptureStackTrace = safeCaptureStackTrace;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-core/dist/index.browser.cjs
var require_index_browser2 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-core/dist/index.browser.cjs"(exports) {
    "use strict";
    var errors = require_index_browser();
    var mergeBytes = (byteArrays) => {
      const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);
      if (nonEmptyByteArrays.length === 0) {
        return byteArrays.length ? byteArrays[0] : new Uint8Array();
      }
      if (nonEmptyByteArrays.length === 1) {
        return nonEmptyByteArrays[0];
      }
      const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      nonEmptyByteArrays.forEach((arr) => {
        result.set(arr, offset);
        offset += arr.length;
      });
      return result;
    };
    var padBytes = (bytes, length) => {
      if (bytes.length >= length) return bytes;
      const paddedBytes = new Uint8Array(length).fill(0);
      paddedBytes.set(bytes);
      return paddedBytes;
    };
    var fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);
    function containsBytes(data, bytes, offset) {
      const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);
      if (slice.length !== bytes.length) return false;
      return bytes.every((b, i) => b === slice[i]);
    }
    function getEncodedSize(value, encoder) {
      return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
    }
    function createEncoder(encoder) {
      return Object.freeze({
        ...encoder,
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, encoder));
          encoder.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function createDecoder(decoder) {
      return Object.freeze({
        ...decoder,
        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
      });
    }
    function createCodec(codec) {
      return Object.freeze({
        ...codec,
        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],
        encode: (value) => {
          const bytes = new Uint8Array(getEncodedSize(value, codec));
          codec.write(value, bytes, 0);
          return bytes;
        }
      });
    }
    function isFixedSize(codec) {
      return "fixedSize" in codec && typeof codec.fixedSize === "number";
    }
    function assertIsFixedSize(codec) {
      if (!isFixedSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);
      }
    }
    function isVariableSize(codec) {
      return !isFixedSize(codec);
    }
    function assertIsVariableSize(codec) {
      if (!isVariableSize(codec)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);
      }
    }
    function combineCodec(encoder, decoder) {
      if (isFixedSize(encoder) !== isFixedSize(decoder)) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
      }
      if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
          decoderFixedSize: decoder.fixedSize,
          encoderFixedSize: encoder.fixedSize
        });
      }
      if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
          decoderMaxSize: decoder.maxSize,
          encoderMaxSize: encoder.maxSize
        });
      }
      return {
        ...decoder,
        ...encoder,
        decode: decoder.decode,
        encode: encoder.encode,
        read: decoder.read,
        write: encoder.write
      };
    }
    function addEncoderSentinel(encoder, sentinel) {
      const write = (value, bytes, offset) => {
        const encoderBytes = encoder.encode(value);
        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {
            encodedBytes: encoderBytes,
            hexEncodedBytes: hexBytes(encoderBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        bytes.set(encoderBytes, offset);
        offset += encoderBytes.length;
        bytes.set(sentinel, offset);
        offset += sentinel.length;
        return offset;
      };
      if (isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });
      }
      return createEncoder({
        ...encoder,
        ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},
        getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,
        write
      });
    }
    function addDecoderSentinel(decoder, sentinel) {
      const read = (bytes, offset) => {
        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);
        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);
        if (sentinelIndex === -1) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {
            decodedBytes: candidateBytes,
            hexDecodedBytes: hexBytes(candidateBytes),
            hexSentinel: hexBytes(sentinel),
            sentinel
          });
        }
        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);
        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];
      };
      if (isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });
      }
      return createDecoder({
        ...decoder,
        ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},
        read
      });
    }
    function addCodecSentinel(codec, sentinel) {
      return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));
    }
    function findSentinelIndex(bytes, sentinel) {
      return bytes.findIndex((byte, index, arr) => {
        if (sentinel.length === 1) return byte === sentinel[0];
        return containsBytes(arr, sentinel, index);
      });
    }
    function hexBytes(bytes) {
      return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    }
    function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
      if (bytes.length - offset <= 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
          codecDescription
        });
      }
    }
    function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
      const bytesLength = bytes.length - offset;
      if (bytesLength < expected) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
          bytesLength,
          codecDescription,
          expected
        });
      }
    }
    function assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {
      if (offset < 0 || offset > bytesLength) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {
          bytesLength,
          codecDescription,
          offset
        });
      }
    }
    function addEncoderSizePrefix(encoder, prefix) {
      const write = (value, bytes, offset) => {
        const encoderBytes = encoder.encode(value);
        offset = prefix.write(encoderBytes.length, bytes, offset);
        bytes.set(encoderBytes, offset);
        return offset + encoderBytes.length;
      };
      if (isFixedSize(prefix) && isFixedSize(encoder)) {
        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;
      return createEncoder({
        ...encoder,
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (value) => {
          const encoderSize = getEncodedSize(value, encoder);
          return getEncodedSize(encoderSize, prefix) + encoderSize;
        },
        write
      });
    }
    function addDecoderSizePrefix(decoder, prefix) {
      const read = (bytes, offset) => {
        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);
        const size = Number(bigintSize);
        offset = decoderOffset;
        if (offset > 0 || bytes.length > size) {
          bytes = bytes.slice(offset, offset + size);
        }
        assertByteArrayHasEnoughBytesForCodec("addDecoderSizePrefix", size, bytes);
        return [decoder.decode(bytes), offset + size];
      };
      if (isFixedSize(prefix) && isFixedSize(decoder)) {
        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });
      }
      const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;
      const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;
      const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;
      return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });
    }
    function addCodecSizePrefix(codec, prefix) {
      return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));
    }
    function fixEncoderSize(encoder, fixedBytes) {
      return createEncoder({
        fixedSize: fixedBytes,
        write: (value, bytes, offset) => {
          const variableByteArray = encoder.encode(value);
          const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;
          bytes.set(fixedByteArray, offset);
          return offset + fixedBytes;
        }
      });
    }
    function fixDecoderSize(decoder, fixedBytes) {
      return createDecoder({
        fixedSize: fixedBytes,
        read: (bytes, offset) => {
          assertByteArrayHasEnoughBytesForCodec("fixCodecSize", fixedBytes, bytes, offset);
          if (offset > 0 || bytes.length > fixedBytes) {
            bytes = bytes.slice(offset, offset + fixedBytes);
          }
          if (isFixedSize(decoder)) {
            bytes = fixBytes(bytes, decoder.fixedSize);
          }
          const [value] = decoder.read(bytes, 0);
          return [value, offset + fixedBytes];
        }
      });
    }
    function fixCodecSize(codec, fixedBytes) {
      return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));
    }
    function offsetEncoder(encoder, config) {
      return createEncoder({
        ...encoder,
        write: (value, bytes, preOffset) => {
          const wrapBytes = (offset) => modulo(offset, bytes.length);
          const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPreOffset, bytes.length);
          const postOffset = encoder.write(value, bytes, newPreOffset);
          const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetEncoder", newPostOffset, bytes.length);
          return newPostOffset;
        }
      });
    }
    function offsetDecoder(decoder, config) {
      return createDecoder({
        ...decoder,
        read: (bytes, preOffset) => {
          const wrapBytes = (offset) => modulo(offset, bytes.length);
          const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPreOffset, bytes.length);
          const [value, postOffset] = decoder.read(bytes, newPreOffset);
          const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;
          assertByteArrayOffsetIsNotOutOfRange("offsetDecoder", newPostOffset, bytes.length);
          return [value, newPostOffset];
        }
      });
    }
    function offsetCodec(codec, config) {
      return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));
    }
    function modulo(dividend, divisor) {
      if (divisor === 0) return 0;
      return (dividend % divisor + divisor) % divisor;
    }
    function resizeEncoder(encoder, resize) {
      if (isFixedSize(encoder)) {
        const fixedSize = resize(encoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeEncoder"
          });
        }
        return createEncoder({ ...encoder, fixedSize });
      }
      return createEncoder({
        ...encoder,
        getSizeFromValue: (value) => {
          const newSize = resize(encoder.getSizeFromValue(value));
          if (newSize < 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
              bytesLength: newSize,
              codecDescription: "resizeEncoder"
            });
          }
          return newSize;
        }
      });
    }
    function resizeDecoder(decoder, resize) {
      if (isFixedSize(decoder)) {
        const fixedSize = resize(decoder.fixedSize);
        if (fixedSize < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {
            bytesLength: fixedSize,
            codecDescription: "resizeDecoder"
          });
        }
        return createDecoder({ ...decoder, fixedSize });
      }
      return decoder;
    }
    function resizeCodec(codec, resize) {
      return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));
    }
    function padLeftEncoder(encoder, offset) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset),
        { preOffset: ({ preOffset }) => preOffset + offset }
      );
    }
    function padRightEncoder(encoder, offset) {
      return offsetEncoder(
        resizeEncoder(encoder, (size) => size + offset),
        { postOffset: ({ postOffset }) => postOffset + offset }
      );
    }
    function padLeftDecoder(decoder, offset) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset),
        { preOffset: ({ preOffset }) => preOffset + offset }
      );
    }
    function padRightDecoder(decoder, offset) {
      return offsetDecoder(
        resizeDecoder(decoder, (size) => size + offset),
        { postOffset: ({ postOffset }) => postOffset + offset }
      );
    }
    function padLeftCodec(codec, offset) {
      return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));
    }
    function padRightCodec(codec, offset) {
      return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));
    }
    function copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {
      while (sourceOffset < --sourceLength) {
        const leftValue = source[sourceOffset];
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];
        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;
        sourceOffset++;
      }
      if (sourceOffset === sourceLength) {
        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];
      }
    }
    function reverseEncoder(encoder) {
      assertIsFixedSize(encoder);
      return createEncoder({
        ...encoder,
        write: (value, bytes, offset) => {
          const newOffset = encoder.write(value, bytes, offset);
          copySourceToTargetInReverse(
            bytes,
            bytes,
            offset,
            offset + encoder.fixedSize
          );
          return newOffset;
        }
      });
    }
    function reverseDecoder(decoder) {
      assertIsFixedSize(decoder);
      return createDecoder({
        ...decoder,
        read: (bytes, offset) => {
          const reversedBytes = bytes.slice();
          copySourceToTargetInReverse(
            bytes,
            reversedBytes,
            offset,
            offset + decoder.fixedSize
          );
          return decoder.read(reversedBytes, offset);
        }
      });
    }
    function reverseCodec(codec) {
      return combineCodec(reverseEncoder(codec), reverseDecoder(codec));
    }
    function transformEncoder(encoder, unmap) {
      return createEncoder({
        ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,
        write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)
      });
    }
    function transformDecoder(decoder, map) {
      return createDecoder({
        ...decoder,
        read: (bytes, offset) => {
          const [value, newOffset] = decoder.read(bytes, offset);
          return [map(value, bytes, offset), newOffset];
        }
      });
    }
    function transformCodec(codec, unmap, map) {
      return createCodec({
        ...transformEncoder(codec, unmap),
        read: map ? transformDecoder(codec, map).read : codec.read
      });
    }
    exports.addCodecSentinel = addCodecSentinel;
    exports.addCodecSizePrefix = addCodecSizePrefix;
    exports.addDecoderSentinel = addDecoderSentinel;
    exports.addDecoderSizePrefix = addDecoderSizePrefix;
    exports.addEncoderSentinel = addEncoderSentinel;
    exports.addEncoderSizePrefix = addEncoderSizePrefix;
    exports.assertByteArrayHasEnoughBytesForCodec = assertByteArrayHasEnoughBytesForCodec;
    exports.assertByteArrayIsNotEmptyForCodec = assertByteArrayIsNotEmptyForCodec;
    exports.assertByteArrayOffsetIsNotOutOfRange = assertByteArrayOffsetIsNotOutOfRange;
    exports.assertIsFixedSize = assertIsFixedSize;
    exports.assertIsVariableSize = assertIsVariableSize;
    exports.combineCodec = combineCodec;
    exports.containsBytes = containsBytes;
    exports.createCodec = createCodec;
    exports.createDecoder = createDecoder;
    exports.createEncoder = createEncoder;
    exports.fixBytes = fixBytes;
    exports.fixCodecSize = fixCodecSize;
    exports.fixDecoderSize = fixDecoderSize;
    exports.fixEncoderSize = fixEncoderSize;
    exports.getEncodedSize = getEncodedSize;
    exports.isFixedSize = isFixedSize;
    exports.isVariableSize = isVariableSize;
    exports.mergeBytes = mergeBytes;
    exports.offsetCodec = offsetCodec;
    exports.offsetDecoder = offsetDecoder;
    exports.offsetEncoder = offsetEncoder;
    exports.padBytes = padBytes;
    exports.padLeftCodec = padLeftCodec;
    exports.padLeftDecoder = padLeftDecoder;
    exports.padLeftEncoder = padLeftEncoder;
    exports.padRightCodec = padRightCodec;
    exports.padRightDecoder = padRightDecoder;
    exports.padRightEncoder = padRightEncoder;
    exports.resizeCodec = resizeCodec;
    exports.resizeDecoder = resizeDecoder;
    exports.resizeEncoder = resizeEncoder;
    exports.reverseCodec = reverseCodec;
    exports.reverseDecoder = reverseDecoder;
    exports.reverseEncoder = reverseEncoder;
    exports.transformCodec = transformCodec;
    exports.transformDecoder = transformDecoder;
    exports.transformEncoder = transformEncoder;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-numbers/dist/index.browser.cjs
var require_index_browser3 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-numbers/dist/index.browser.cjs"(exports) {
    "use strict";
    var errors = require_index_browser();
    var codecsCore = require_index_browser2();
    function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
      if (value < min || value > max) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
          codecDescription,
          max,
          min,
          value
        });
      }
    }
    var Endian = ((Endian2) => {
      Endian2[Endian2["Little"] = 0] = "Little";
      Endian2[Endian2["Big"] = 1] = "Big";
      return Endian2;
    })(Endian || {});
    function isLittleEndian(config) {
      return (config == null ? void 0 : config.endian) === 1 ? false : true;
    }
    function numberEncoderFactory(input) {
      return codecsCore.createEncoder({
        fixedSize: input.size,
        write(value, bytes, offset) {
          if (input.range) {
            assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
          }
          const arrayBuffer = new ArrayBuffer(input.size);
          input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
          bytes.set(new Uint8Array(arrayBuffer), offset);
          return offset + input.size;
        }
      });
    }
    function numberDecoderFactory(input) {
      return codecsCore.createDecoder({
        fixedSize: input.size,
        read(bytes, offset = 0) {
          codecsCore.assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
          codecsCore.assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
          const view = new DataView(toArrayBuffer(bytes, offset, input.size));
          return [input.get(view, isLittleEndian(input.config)), offset + input.size];
        }
      });
    }
    function toArrayBuffer(bytes, offset, length) {
      const bytesOffset = bytes.byteOffset + (offset ?? 0);
      const bytesLength = length ?? bytes.byteLength;
      return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
    }
    var getF32Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "f32",
      set: (view, value, le) => view.setFloat32(0, Number(value), le),
      size: 4
    });
    var getF32Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getFloat32(0, le),
      name: "f32",
      size: 4
    });
    var getF32Codec = (config = {}) => codecsCore.combineCodec(getF32Encoder(config), getF32Decoder(config));
    var getF64Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "f64",
      set: (view, value, le) => view.setFloat64(0, Number(value), le),
      size: 8
    });
    var getF64Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getFloat64(0, le),
      name: "f64",
      size: 8
    });
    var getF64Codec = (config = {}) => codecsCore.combineCodec(getF64Encoder(config), getF64Decoder(config));
    var getI128Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "i128",
      range: [-BigInt("0x7fffffffffffffffffffffffffffffff") - 1n, BigInt("0x7fffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getI128Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigInt64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "i128",
      size: 16
    });
    var getI128Codec = (config = {}) => codecsCore.combineCodec(getI128Encoder(config), getI128Decoder(config));
    var getI16Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "i16",
      range: [-Number("0x7fff") - 1, Number("0x7fff")],
      set: (view, value, le) => view.setInt16(0, Number(value), le),
      size: 2
    });
    var getI16Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getInt16(0, le),
      name: "i16",
      size: 2
    });
    var getI16Codec = (config = {}) => codecsCore.combineCodec(getI16Encoder(config), getI16Decoder(config));
    var getI32Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "i32",
      range: [-Number("0x7fffffff") - 1, Number("0x7fffffff")],
      set: (view, value, le) => view.setInt32(0, Number(value), le),
      size: 4
    });
    var getI32Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getInt32(0, le),
      name: "i32",
      size: 4
    });
    var getI32Codec = (config = {}) => codecsCore.combineCodec(getI32Encoder(config), getI32Decoder(config));
    var getI64Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "i64",
      range: [-BigInt("0x7fffffffffffffff") - 1n, BigInt("0x7fffffffffffffff")],
      set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),
      size: 8
    });
    var getI64Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getBigInt64(0, le),
      name: "i64",
      size: 8
    });
    var getI64Codec = (config = {}) => codecsCore.combineCodec(getI64Encoder(config), getI64Decoder(config));
    var getI8Encoder = () => numberEncoderFactory({
      name: "i8",
      range: [-Number("0x7f") - 1, Number("0x7f")],
      set: (view, value) => view.setInt8(0, Number(value)),
      size: 1
    });
    var getI8Decoder = () => numberDecoderFactory({
      get: (view) => view.getInt8(0),
      name: "i8",
      size: 1
    });
    var getI8Codec = () => codecsCore.combineCodec(getI8Encoder(), getI8Decoder());
    var getShortU16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => {
        if (value <= 127) return 1;
        if (value <= 16383) return 2;
        return 3;
      },
      maxSize: 3,
      write: (value, bytes, offset) => {
        assertNumberIsBetweenForCodec("shortU16", 0, 65535, value);
        const shortU16Bytes = [0];
        for (let ii = 0; ; ii += 1) {
          const alignedValue = Number(value) >> ii * 7;
          if (alignedValue === 0) {
            break;
          }
          const nextSevenBits = 127 & alignedValue;
          shortU16Bytes[ii] = nextSevenBits;
          if (ii > 0) {
            shortU16Bytes[ii - 1] |= 128;
          }
        }
        bytes.set(shortU16Bytes, offset);
        return offset + shortU16Bytes.length;
      }
    });
    var getShortU16Decoder = () => codecsCore.createDecoder({
      maxSize: 3,
      read: (bytes, offset) => {
        let value = 0;
        let byteCount = 0;
        while (++byteCount) {
          const byteIndex = byteCount - 1;
          const currentByte = bytes[offset + byteIndex];
          const nextSevenBits = 127 & currentByte;
          value |= nextSevenBits << byteIndex * 7;
          if ((currentByte & 128) === 0) {
            break;
          }
        }
        return [value, offset + byteCount];
      }
    });
    var getShortU16Codec = () => codecsCore.combineCodec(getShortU16Encoder(), getShortU16Decoder());
    var getU128Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "u128",
      range: [0n, BigInt("0xffffffffffffffffffffffffffffffff")],
      set: (view, value, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const rightMask = 0xffffffffffffffffn;
        view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);
        view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);
      },
      size: 16
    });
    var getU128Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => {
        const leftOffset = le ? 8 : 0;
        const rightOffset = le ? 0 : 8;
        const left = view.getBigUint64(leftOffset, le);
        const right = view.getBigUint64(rightOffset, le);
        return (left << 64n) + right;
      },
      name: "u128",
      size: 16
    });
    var getU128Codec = (config = {}) => codecsCore.combineCodec(getU128Encoder(config), getU128Decoder(config));
    var getU16Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "u16",
      range: [0, Number("0xffff")],
      set: (view, value, le) => view.setUint16(0, Number(value), le),
      size: 2
    });
    var getU16Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getUint16(0, le),
      name: "u16",
      size: 2
    });
    var getU16Codec = (config = {}) => codecsCore.combineCodec(getU16Encoder(config), getU16Decoder(config));
    var getU32Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "u32",
      range: [0, Number("0xffffffff")],
      set: (view, value, le) => view.setUint32(0, Number(value), le),
      size: 4
    });
    var getU32Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getUint32(0, le),
      name: "u32",
      size: 4
    });
    var getU32Codec = (config = {}) => codecsCore.combineCodec(getU32Encoder(config), getU32Decoder(config));
    var getU64Encoder = (config = {}) => numberEncoderFactory({
      config,
      name: "u64",
      range: [0n, BigInt("0xffffffffffffffff")],
      set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
      size: 8
    });
    var getU64Decoder = (config = {}) => numberDecoderFactory({
      config,
      get: (view, le) => view.getBigUint64(0, le),
      name: "u64",
      size: 8
    });
    var getU64Codec = (config = {}) => codecsCore.combineCodec(getU64Encoder(config), getU64Decoder(config));
    var getU8Encoder = () => numberEncoderFactory({
      name: "u8",
      range: [0, Number("0xff")],
      set: (view, value) => view.setUint8(0, Number(value)),
      size: 1
    });
    var getU8Decoder = () => numberDecoderFactory({
      get: (view) => view.getUint8(0),
      name: "u8",
      size: 1
    });
    var getU8Codec = () => codecsCore.combineCodec(getU8Encoder(), getU8Decoder());
    exports.Endian = Endian;
    exports.assertNumberIsBetweenForCodec = assertNumberIsBetweenForCodec;
    exports.getF32Codec = getF32Codec;
    exports.getF32Decoder = getF32Decoder;
    exports.getF32Encoder = getF32Encoder;
    exports.getF64Codec = getF64Codec;
    exports.getF64Decoder = getF64Decoder;
    exports.getF64Encoder = getF64Encoder;
    exports.getI128Codec = getI128Codec;
    exports.getI128Decoder = getI128Decoder;
    exports.getI128Encoder = getI128Encoder;
    exports.getI16Codec = getI16Codec;
    exports.getI16Decoder = getI16Decoder;
    exports.getI16Encoder = getI16Encoder;
    exports.getI32Codec = getI32Codec;
    exports.getI32Decoder = getI32Decoder;
    exports.getI32Encoder = getI32Encoder;
    exports.getI64Codec = getI64Codec;
    exports.getI64Decoder = getI64Decoder;
    exports.getI64Encoder = getI64Encoder;
    exports.getI8Codec = getI8Codec;
    exports.getI8Decoder = getI8Decoder;
    exports.getI8Encoder = getI8Encoder;
    exports.getShortU16Codec = getShortU16Codec;
    exports.getShortU16Decoder = getShortU16Decoder;
    exports.getShortU16Encoder = getShortU16Encoder;
    exports.getU128Codec = getU128Codec;
    exports.getU128Decoder = getU128Decoder;
    exports.getU128Encoder = getU128Encoder;
    exports.getU16Codec = getU16Codec;
    exports.getU16Decoder = getU16Decoder;
    exports.getU16Encoder = getU16Encoder;
    exports.getU32Codec = getU32Codec;
    exports.getU32Decoder = getU32Decoder;
    exports.getU32Encoder = getU32Encoder;
    exports.getU64Codec = getU64Codec;
    exports.getU64Decoder = getU64Decoder;
    exports.getU64Encoder = getU64Encoder;
    exports.getU8Codec = getU8Codec;
    exports.getU8Decoder = getU8Decoder;
    exports.getU8Encoder = getU8Encoder;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-data-structures/dist/index.browser.cjs
var require_index_browser4 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-data-structures/dist/index.browser.cjs"(exports) {
    "use strict";
    var codecsCore = require_index_browser2();
    var codecsNumbers = require_index_browser3();
    var errors = require_index_browser();
    function assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {
      if (expected !== actual) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {
          actual,
          codecDescription,
          expected
        });
      }
    }
    function maxCodecSizes(sizes) {
      return sizes.reduce(
        (all, size) => all === null || size === null ? null : Math.max(all, size),
        0
      );
    }
    function sumCodecSizes(sizes) {
      return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
    }
    function getFixedSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : null;
    }
    function getMaxSize(codec) {
      return codecsCore.isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
    }
    function getArrayEncoder(item, config = {}) {
      const size = config.size ?? codecsNumbers.getU32Encoder();
      const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize !== null ? { fixedSize } : {
          getSizeFromValue: (array) => {
            const prefixSize = typeof size === "object" ? codecsCore.getEncodedSize(array.length, size) : 0;
            return prefixSize + [...array].reduce((all, value) => all + codecsCore.getEncodedSize(value, item), 0);
          },
          maxSize
        },
        write: (array, bytes, offset) => {
          if (typeof size === "number") {
            assertValidNumberOfItemsForCodec("array", size, array.length);
          }
          if (typeof size === "object") {
            offset = size.write(array.length, bytes, offset);
          }
          array.forEach((value) => {
            offset = item.write(value, bytes, offset);
          });
          return offset;
        }
      });
    }
    function getArrayDecoder(item, config = {}) {
      const size = config.size ?? codecsNumbers.getU32Decoder();
      const itemSize = getFixedSize(item);
      const fixedSize = computeArrayLikeCodecSize(size, itemSize);
      const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize !== null ? { fixedSize } : { maxSize },
        read: (bytes, offset) => {
          const array = [];
          if (typeof size === "object" && bytes.slice(offset).length === 0) {
            return [array, offset];
          }
          if (size === "remainder") {
            while (offset < bytes.length) {
              const [value, newOffset2] = item.read(bytes, offset);
              offset = newOffset2;
              array.push(value);
            }
            return [array, offset];
          }
          const [resolvedSize, newOffset] = typeof size === "number" ? [size, offset] : size.read(bytes, offset);
          offset = newOffset;
          for (let i = 0; i < resolvedSize; i += 1) {
            const [value, newOffset2] = item.read(bytes, offset);
            offset = newOffset2;
            array.push(value);
          }
          return [array, offset];
        }
      });
    }
    function getArrayCodec(item, config = {}) {
      return codecsCore.combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));
    }
    function computeArrayLikeCodecSize(size, itemSize) {
      if (typeof size !== "number") return null;
      if (size === 0) return 0;
      return itemSize === null ? null : itemSize * size;
    }
    function getBitArrayEncoder(size, config = {}) {
      const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createEncoder({
        fixedSize: size,
        write(value, bytes, offset) {
          const bytesToAdd = [];
          for (let i = 0; i < size; i += 1) {
            let byte = 0;
            for (let j = 0; j < 8; j += 1) {
              const feature = Number(value[i * 8 + j] ?? 0);
              byte |= feature << (backward ? j : 7 - j);
            }
            if (backward) {
              bytesToAdd.unshift(byte);
            } else {
              bytesToAdd.push(byte);
            }
          }
          bytes.set(bytesToAdd, offset);
          return size;
        }
      });
    }
    function getBitArrayDecoder(size, config = {}) {
      const parsedConfig = typeof config === "boolean" ? { backward: config } : config;
      const backward = parsedConfig.backward ?? false;
      return codecsCore.createDecoder({
        fixedSize: size,
        read(bytes, offset) {
          codecsCore.assertByteArrayHasEnoughBytesForCodec("bitArray", size, bytes, offset);
          const booleans = [];
          let slice = bytes.slice(offset, offset + size);
          slice = backward ? slice.reverse() : slice;
          slice.forEach((byte) => {
            for (let i = 0; i < 8; i += 1) {
              if (backward) {
                booleans.push(Boolean(byte & 1));
                byte >>= 1;
              } else {
                booleans.push(Boolean(byte & 128));
                byte <<= 1;
              }
            }
          });
          return [booleans, offset + size];
        }
      });
    }
    function getBitArrayCodec(size, config = {}) {
      return codecsCore.combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));
    }
    function getBooleanEncoder(config = {}) {
      return codecsCore.transformEncoder(config.size ?? codecsNumbers.getU8Encoder(), (value) => value ? 1 : 0);
    }
    function getBooleanDecoder(config = {}) {
      return codecsCore.transformDecoder(config.size ?? codecsNumbers.getU8Decoder(), (value) => Number(value) === 1);
    }
    function getBooleanCodec(config = {}) {
      return codecsCore.combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));
    }
    function getBytesEncoder() {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => value.length,
        write: (value, bytes, offset) => {
          bytes.set(value, offset);
          return offset + value.length;
        }
      });
    }
    function getBytesDecoder() {
      return codecsCore.createDecoder({
        read: (bytes, offset) => {
          const slice = bytes.slice(offset);
          return [slice, offset + slice.length];
        }
      });
    }
    function getBytesCodec() {
      return codecsCore.combineCodec(getBytesEncoder(), getBytesDecoder());
    }
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset) {
        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    function getConstantEncoder(constant) {
      return codecsCore.createEncoder({
        fixedSize: constant.length,
        write: (_, bytes, offset) => {
          bytes.set(constant, offset);
          return offset + constant.length;
        }
      });
    }
    function getConstantDecoder(constant) {
      return codecsCore.createDecoder({
        fixedSize: constant.length,
        read: (bytes, offset) => {
          const base16 = getBase16Decoder();
          if (!codecsCore.containsBytes(bytes, constant, offset)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_CONSTANT, {
              constant,
              data: bytes,
              hexConstant: base16.decode(constant),
              hexData: base16.decode(bytes),
              offset
            });
          }
          return [void 0, offset + constant.length];
        }
      });
    }
    function getConstantCodec(constant) {
      return codecsCore.combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));
    }
    function getTupleEncoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => items.map((item, index) => codecsCore.getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (value, bytes, offset) => {
          assertValidNumberOfItemsForCodec("tuple", items.length, value.length);
          items.forEach((item, index) => {
            offset = item.write(value[index], bytes, offset);
          });
          return offset;
        }
      });
    }
    function getTupleDecoder(items) {
      const fixedSize = sumCodecSizes(items.map(getFixedSize));
      const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset) => {
          const values = [];
          items.forEach((item) => {
            const [newValue, newOffset] = item.read(bytes, offset);
            values.push(newValue);
            offset = newOffset;
          });
          return [values, offset];
        }
      });
    }
    function getTupleCodec(items) {
      return codecsCore.combineCodec(
        getTupleEncoder(items),
        getTupleDecoder(items)
      );
    }
    function getUnionEncoder(variants, getIndexFromValue) {
      const fixedSize = getUnionFixedSize(variants);
      const write = (variant, bytes, offset) => {
        const index = getIndexFromValue(variant);
        assertValidVariantIndex(variants, index);
        return variants[index].write(variant, bytes, offset);
      };
      if (fixedSize !== null) {
        return codecsCore.createEncoder({ fixedSize, write });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createEncoder({
        ...maxSize !== null ? { maxSize } : {},
        getSizeFromValue: (variant) => {
          const index = getIndexFromValue(variant);
          assertValidVariantIndex(variants, index);
          return codecsCore.getEncodedSize(variant, variants[index]);
        },
        write
      });
    }
    function getUnionDecoder(variants, getIndexFromBytes) {
      const fixedSize = getUnionFixedSize(variants);
      const read = (bytes, offset) => {
        const index = getIndexFromBytes(bytes, offset);
        assertValidVariantIndex(variants, index);
        return variants[index].read(bytes, offset);
      };
      if (fixedSize !== null) {
        return codecsCore.createDecoder({ fixedSize, read });
      }
      const maxSize = getUnionMaxSize(variants);
      return codecsCore.createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });
    }
    function getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {
      return codecsCore.combineCodec(
        getUnionEncoder(variants, getIndexFromValue),
        getUnionDecoder(variants, getIndexFromBytes)
      );
    }
    function assertValidVariantIndex(variants, index) {
      if (typeof variants[index] === "undefined") {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {
          maxRange: variants.length - 1,
          minRange: 0,
          variant: index
        });
      }
    }
    function getUnionFixedSize(variants) {
      if (variants.length === 0) return 0;
      if (!codecsCore.isFixedSize(variants[0])) return null;
      const variantSize = variants[0].fixedSize;
      const sameSizedVariants = variants.every((variant) => codecsCore.isFixedSize(variant) && variant.fixedSize === variantSize);
      return sameSizedVariants ? variantSize : null;
    }
    function getUnionMaxSize(variants) {
      return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));
    }
    function getDiscriminatedUnionEncoder(variants, config = {}) {
      const discriminatorProperty = config.discriminator ?? "__kind";
      const prefix = config.size ?? codecsNumbers.getU8Encoder();
      return getUnionEncoder(
        variants.map(
          ([, variant], index) => codecsCore.transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])
        ),
        (value) => getVariantDiscriminator(variants, value[discriminatorProperty])
      );
    }
    function getDiscriminatedUnionDecoder(variants, config = {}) {
      const discriminatorProperty = config.discriminator ?? "__kind";
      const prefix = config.size ?? codecsNumbers.getU8Decoder();
      return getUnionDecoder(
        variants.map(
          ([discriminator, variant]) => codecsCore.transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({
            [discriminatorProperty]: discriminator,
            ...value
          }))
        ),
        (bytes, offset) => Number(prefix.read(bytes, offset)[0])
      );
    }
    function getDiscriminatedUnionCodec(variants, config = {}) {
      return codecsCore.combineCodec(
        getDiscriminatedUnionEncoder(variants, config),
        getDiscriminatedUnionDecoder(variants, config)
      );
    }
    function getVariantDiscriminator(variants, discriminatorValue) {
      const discriminator = variants.findIndex(([key]) => discriminatorValue === key);
      if (discriminator < 0) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {
          value: discriminatorValue,
          variants: variants.map(([key]) => key)
        });
      }
      return discriminator;
    }
    var getDataEnumEncoder = getDiscriminatedUnionEncoder;
    var getDataEnumDecoder = getDiscriminatedUnionDecoder;
    var getDataEnumCodec = getDiscriminatedUnionCodec;
    function getEnumStats(constructor) {
      const numericalValues = [
        ...new Set(Object.values(constructor).filter((v) => typeof v === "number"))
      ].sort();
      const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));
      const enumKeys = Object.keys(enumRecord);
      const enumValues = Object.values(enumRecord);
      const stringValues = [
        .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === "string")])
      ];
      return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };
    }
    function getEnumIndexFromVariant({
      enumKeys,
      enumValues,
      variant
    }) {
      const valueIndex = findLastIndex(enumValues, (value) => value === variant);
      if (valueIndex >= 0) return valueIndex;
      return enumKeys.findIndex((key) => key === variant);
    }
    function getEnumIndexFromDiscriminator({
      discriminator,
      enumKeys,
      enumValues,
      useValuesAsDiscriminators
    }) {
      if (!useValuesAsDiscriminators) {
        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;
      }
      return findLastIndex(enumValues, (value) => value === discriminator);
    }
    function findLastIndex(array, predicate) {
      let l = array.length;
      while (l--) {
        if (predicate(array[l], l, array)) return l;
      }
      return -1;
    }
    function formatNumericalValues(values) {
      if (values.length === 0) return "";
      let range = [values[0], values[0]];
      const ranges = [];
      for (let index = 1; index < values.length; index++) {
        const value = values[index];
        if (range[1] + 1 === value) {
          range[1] = value;
        } else {
          ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
          range = [value, value];
        }
      }
      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);
      return ranges.join(", ");
    }
    function getEnumEncoder(constructor, config = {}) {
      const prefix = config.size ?? codecsNumbers.getU8Encoder();
      const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformEncoder(prefix, (variant) => {
        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });
        if (index < 0) {
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {
            formattedNumericalValues: formatNumericalValues(numericalValues),
            numericalValues,
            stringValues,
            variant
          });
        }
        return useValuesAsDiscriminators ? enumValues[index] : index;
      });
    }
    function getEnumDecoder(constructor, config = {}) {
      const prefix = config.size ?? codecsNumbers.getU8Decoder();
      const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;
      const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);
      if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === "string")) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {
          stringValues: enumValues.filter((v) => typeof v === "string")
        });
      }
      return codecsCore.transformDecoder(prefix, (value) => {
        const discriminator = Number(value);
        const index = getEnumIndexFromDiscriminator({
          discriminator,
          enumKeys,
          enumValues,
          useValuesAsDiscriminators
        });
        if (index < 0) {
          const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];
          throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {
            discriminator,
            formattedValidDiscriminators: formatNumericalValues(validDiscriminators),
            validDiscriminators
          });
        }
        return enumValues[index];
      });
    }
    function getEnumCodec(constructor, config = {}) {
      return codecsCore.combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));
    }
    var getScalarEnumEncoder = getEnumEncoder;
    var getScalarEnumDecoder = getEnumDecoder;
    var getScalarEnumCodec = getEnumCodec;
    function getHiddenPrefixEncoder(encoder, prefixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([...prefixedEncoders, encoder]),
        (value) => [...prefixedEncoders.map(() => void 0), value]
      );
    }
    function getHiddenPrefixDecoder(decoder, prefixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([...prefixedDecoders, decoder]),
        (tuple) => tuple[tuple.length - 1]
      );
    }
    function getHiddenPrefixCodec(codec, prefixedCodecs) {
      return codecsCore.combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));
    }
    function getHiddenSuffixEncoder(encoder, suffixedEncoders) {
      return codecsCore.transformEncoder(
        getTupleEncoder([encoder, ...suffixedEncoders]),
        (value) => [value, ...suffixedEncoders.map(() => void 0)]
      );
    }
    function getHiddenSuffixDecoder(decoder, suffixedDecoders) {
      return codecsCore.transformDecoder(
        getTupleDecoder([decoder, ...suffixedDecoders]),
        (tuple) => tuple[0]
      );
    }
    function getHiddenSuffixCodec(codec, suffixedCodecs) {
      return codecsCore.combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));
    }
    function getMapEncoder(key, value, config = {}) {
      return codecsCore.transformEncoder(
        getArrayEncoder(getTupleEncoder([key, value]), config),
        (map) => [...map.entries()]
      );
    }
    function getMapDecoder(key, value, config = {}) {
      return codecsCore.transformDecoder(
        getArrayDecoder(getTupleDecoder([key, value]), config),
        (entries) => new Map(entries)
      );
    }
    function getMapCodec(key, value, config = {}) {
      return codecsCore.combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));
    }
    function getUnitEncoder() {
      return codecsCore.createEncoder({
        fixedSize: 0,
        write: (_value, _bytes, offset) => offset
      });
    }
    function getUnitDecoder() {
      return codecsCore.createDecoder({
        fixedSize: 0,
        read: (_bytes, offset) => [void 0, offset]
      });
    }
    function getUnitCodec() {
      return codecsCore.combineCodec(getUnitEncoder(), getUnitDecoder());
    }
    function getNullableEncoder(item, config = {}) {
      const prefix = (() => {
        if (config.prefix === null) {
          return codecsCore.transformEncoder(getUnitEncoder(), (_boolean) => void 0);
        }
        return getBooleanEncoder({ size: config.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(getUnitEncoder(), item.fixedSize);
        }
        if (!config.noneValue) {
          return getUnitEncoder();
        }
        return getConstantEncoder(config.noneValue);
      })();
      return getUnionEncoder(
        [
          codecsCore.transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])
        ],
        (variant) => Number(variant !== null)
      );
    }
    function getNullableDecoder(item, config = {}) {
      const prefix = (() => {
        if (config.prefix === null) {
          return codecsCore.transformDecoder(getUnitDecoder(), () => false);
        }
        return getBooleanDecoder({ size: config.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(getUnitDecoder(), item.fixedSize);
        }
        if (!config.noneValue) {
          return getUnitDecoder();
        }
        return getConstantDecoder(config.noneValue);
      })();
      return getUnionDecoder(
        [
          codecsCore.transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),
          codecsCore.transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)
        ],
        (bytes, offset) => {
          if (config.prefix === null && !config.noneValue) {
            return Number(offset < bytes.length);
          }
          if (config.prefix === null && config.noneValue != null) {
            const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset)[0]);
        }
      );
    }
    function getNullableCodec(item, config = {}) {
      return codecsCore.combineCodec(
        getNullableEncoder(item, config),
        getNullableDecoder(item, config)
      );
    }
    function getSetEncoder(item, config = {}) {
      return codecsCore.transformEncoder(getArrayEncoder(item, config), (set) => [...set]);
    }
    function getSetDecoder(item, config = {}) {
      return codecsCore.transformDecoder(getArrayDecoder(item, config), (entries) => new Set(entries));
    }
    function getSetCodec(item, config = {}) {
      return codecsCore.combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));
    }
    function getStructEncoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createEncoder({
        ...fixedSize === null ? {
          getSizeFromValue: (value) => fields.map(([key, codec]) => codecsCore.getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),
          maxSize
        } : { fixedSize },
        write: (struct, bytes, offset) => {
          fields.forEach(([key, codec]) => {
            offset = codec.write(struct[key], bytes, offset);
          });
          return offset;
        }
      });
    }
    function getStructDecoder(fields) {
      const fieldCodecs = fields.map(([, codec]) => codec);
      const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
      const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
      return codecsCore.createDecoder({
        ...fixedSize === null ? { maxSize } : { fixedSize },
        read: (bytes, offset) => {
          const struct = {};
          fields.forEach(([key, codec]) => {
            const [value, newOffset] = codec.read(bytes, offset);
            offset = newOffset;
            struct[key] = value;
          });
          return [struct, offset];
        }
      });
    }
    function getStructCodec(fields) {
      return codecsCore.combineCodec(
        getStructEncoder(fields),
        getStructDecoder(fields)
      );
    }
    exports.assertValidNumberOfItemsForCodec = assertValidNumberOfItemsForCodec;
    exports.getArrayCodec = getArrayCodec;
    exports.getArrayDecoder = getArrayDecoder;
    exports.getArrayEncoder = getArrayEncoder;
    exports.getBitArrayCodec = getBitArrayCodec;
    exports.getBitArrayDecoder = getBitArrayDecoder;
    exports.getBitArrayEncoder = getBitArrayEncoder;
    exports.getBooleanCodec = getBooleanCodec;
    exports.getBooleanDecoder = getBooleanDecoder;
    exports.getBooleanEncoder = getBooleanEncoder;
    exports.getBytesCodec = getBytesCodec;
    exports.getBytesDecoder = getBytesDecoder;
    exports.getBytesEncoder = getBytesEncoder;
    exports.getConstantCodec = getConstantCodec;
    exports.getConstantDecoder = getConstantDecoder;
    exports.getConstantEncoder = getConstantEncoder;
    exports.getDataEnumCodec = getDataEnumCodec;
    exports.getDataEnumDecoder = getDataEnumDecoder;
    exports.getDataEnumEncoder = getDataEnumEncoder;
    exports.getDiscriminatedUnionCodec = getDiscriminatedUnionCodec;
    exports.getDiscriminatedUnionDecoder = getDiscriminatedUnionDecoder;
    exports.getDiscriminatedUnionEncoder = getDiscriminatedUnionEncoder;
    exports.getEnumCodec = getEnumCodec;
    exports.getEnumDecoder = getEnumDecoder;
    exports.getEnumEncoder = getEnumEncoder;
    exports.getHiddenPrefixCodec = getHiddenPrefixCodec;
    exports.getHiddenPrefixDecoder = getHiddenPrefixDecoder;
    exports.getHiddenPrefixEncoder = getHiddenPrefixEncoder;
    exports.getHiddenSuffixCodec = getHiddenSuffixCodec;
    exports.getHiddenSuffixDecoder = getHiddenSuffixDecoder;
    exports.getHiddenSuffixEncoder = getHiddenSuffixEncoder;
    exports.getMapCodec = getMapCodec;
    exports.getMapDecoder = getMapDecoder;
    exports.getMapEncoder = getMapEncoder;
    exports.getNullableCodec = getNullableCodec;
    exports.getNullableDecoder = getNullableDecoder;
    exports.getNullableEncoder = getNullableEncoder;
    exports.getScalarEnumCodec = getScalarEnumCodec;
    exports.getScalarEnumDecoder = getScalarEnumDecoder;
    exports.getScalarEnumEncoder = getScalarEnumEncoder;
    exports.getSetCodec = getSetCodec;
    exports.getSetDecoder = getSetDecoder;
    exports.getSetEncoder = getSetEncoder;
    exports.getStructCodec = getStructCodec;
    exports.getStructDecoder = getStructDecoder;
    exports.getStructEncoder = getStructEncoder;
    exports.getTupleCodec = getTupleCodec;
    exports.getTupleDecoder = getTupleDecoder;
    exports.getTupleEncoder = getTupleEncoder;
    exports.getUnionCodec = getUnionCodec;
    exports.getUnionDecoder = getUnionDecoder;
    exports.getUnionEncoder = getUnionEncoder;
    exports.getUnitCodec = getUnitCodec;
    exports.getUnitDecoder = getUnitDecoder;
    exports.getUnitEncoder = getUnitEncoder;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/dist/index.browser.cjs
var require_index_browser5 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs-strings/dist/index.browser.cjs"(exports) {
    "use strict";
    var errors = require_index_browser();
    var codecsCore = require_index_browser2();
    function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
      if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
        throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
          alphabet: alphabet4,
          base: alphabet4.length,
          value: givenValue
        });
      }
    }
    var getBaseXEncoder = (alphabet4) => {
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => {
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars) return value.length;
          const base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);
        },
        write(value, bytes, offset) {
          assertValidBaseString(alphabet4, value);
          if (value === "") return offset;
          const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);
          if (!tailChars) {
            bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);
            return offset + leadingZeroes.length;
          }
          let base10Number = getBigIntFromBaseX(tailChars, alphabet4);
          const tailBytes = [];
          while (base10Number > 0n) {
            tailBytes.unshift(Number(base10Number % 256n));
            base10Number /= 256n;
          }
          const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];
          bytes.set(bytesToAdd, offset);
          return offset + bytesToAdd.length;
        }
      });
    };
    var getBaseXDecoder = (alphabet4) => {
      return codecsCore.createDecoder({
        read(rawBytes, offset) {
          const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
          if (bytes.length === 0) return ["", 0];
          let trailIndex = bytes.findIndex((n) => n !== 0);
          trailIndex = trailIndex === -1 ? bytes.length : trailIndex;
          const leadingZeroes = alphabet4[0].repeat(trailIndex);
          if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];
          const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);
          const tailChars = getBaseXFromBigInt(base10Number, alphabet4);
          return [leadingZeroes + tailChars, rawBytes.length];
        }
      });
    };
    var getBaseXCodec = (alphabet4) => codecsCore.combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));
    function partitionLeadingZeroes(value, zeroCharacter) {
      const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));
      return [leadingZeros, tailChars];
    }
    function getBigIntFromBaseX(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      let sum = 0n;
      for (const char of value) {
        sum *= base;
        sum += BigInt(alphabet4.indexOf(char));
      }
      return sum;
    }
    function getBaseXFromBigInt(value, alphabet4) {
      const base = BigInt(alphabet4.length);
      const tailChars = [];
      while (value > 0n) {
        tailChars.unshift(alphabet4[Number(value % base)]);
        value /= base;
      }
      return tailChars.join("");
    }
    var alphabet = "0123456789";
    var getBase10Encoder = () => getBaseXEncoder(alphabet);
    var getBase10Decoder = () => getBaseXDecoder(alphabet);
    var getBase10Codec = () => getBaseXCodec(alphabet);
    var INVALID_STRING_ERROR_BASE_CONFIG = {
      alphabet: "0123456789abcdef",
      base: 16
    };
    function charCodeToBase16(char) {
      if (char >= 48 && char <= 57) return char - 48;
      if (char >= 65 && char <= 70) return char - (65 - 10);
      if (char >= 97 && char <= 102) return char - (97 - 10);
    }
    var getBase16Encoder = () => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.ceil(value.length / 2),
      write(value, bytes, offset) {
        const len = value.length;
        const al = len / 2;
        if (len === 1) {
          const c = value.charCodeAt(0);
          const n = charCodeToBase16(c);
          if (n === void 0) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          bytes.set([n], offset);
          return 1 + offset;
        }
        const hexBytes = new Uint8Array(al);
        for (let i = 0, j = 0; i < al; i++) {
          const c1 = value.charCodeAt(j++);
          const c2 = value.charCodeAt(j++);
          const n1 = charCodeToBase16(c1);
          const n2 = charCodeToBase16(c2);
          if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {
            throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
              ...INVALID_STRING_ERROR_BASE_CONFIG,
              value
            });
          }
          hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;
        }
        bytes.set(hexBytes, offset);
        return hexBytes.length + offset;
      }
    });
    var getBase16Decoder = () => codecsCore.createDecoder({
      read(bytes, offset) {
        const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        return [value, bytes.length];
      }
    });
    var getBase16Codec = () => codecsCore.combineCodec(getBase16Encoder(), getBase16Decoder());
    var alphabet2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var getBase58Encoder = () => getBaseXEncoder(alphabet2);
    var getBase58Decoder = () => getBaseXDecoder(alphabet2);
    var getBase58Codec = () => getBaseXCodec(alphabet2);
    var getBaseXResliceEncoder = (alphabet4, bits) => codecsCore.createEncoder({
      getSizeFromValue: (value) => Math.floor(value.length * bits / 8),
      write(value, bytes, offset) {
        assertValidBaseString(alphabet4, value);
        if (value === "") return offset;
        const charIndices = [...value].map((c) => alphabet4.indexOf(c));
        const reslicedBytes = reslice(charIndices, bits, 8, false);
        bytes.set(reslicedBytes, offset);
        return reslicedBytes.length + offset;
      }
    });
    var getBaseXResliceDecoder = (alphabet4, bits) => codecsCore.createDecoder({
      read(rawBytes, offset = 0) {
        const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);
        if (bytes.length === 0) return ["", rawBytes.length];
        const charIndices = reslice([...bytes], 8, bits, true);
        return [charIndices.map((i) => alphabet4[i]).join(""), rawBytes.length];
      }
    });
    var getBaseXResliceCodec = (alphabet4, bits) => codecsCore.combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));
    function reslice(input, inputBits, outputBits, useRemainder) {
      const output = [];
      let accumulator = 0;
      let bitsInAccumulator = 0;
      const mask = (1 << outputBits) - 1;
      for (const value of input) {
        accumulator = accumulator << inputBits | value;
        bitsInAccumulator += inputBits;
        while (bitsInAccumulator >= outputBits) {
          bitsInAccumulator -= outputBits;
          output.push(accumulator >> bitsInAccumulator & mask);
        }
      }
      if (useRemainder && bitsInAccumulator > 0) {
        output.push(accumulator << outputBits - bitsInAccumulator & mask);
      }
      return output;
    }
    var alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var getBase64Encoder = () => {
      {
        return codecsCore.createEncoder({
          getSizeFromValue: (value) => {
            try {
              return atob(value).length;
            } catch (e2) {
              throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
                alphabet: alphabet3,
                base: 64,
                value
              });
            }
          },
          write(value, bytes, offset) {
            try {
              const bytesToAdd = atob(value).split("").map((c) => c.charCodeAt(0));
              bytes.set(bytesToAdd, offset);
              return bytesToAdd.length + offset;
            } catch (e2) {
              throw new errors.SolanaError(errors.SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
                alphabet: alphabet3,
                base: 64,
                value
              });
            }
          }
        });
      }
    };
    var getBase64Decoder = () => {
      {
        return codecsCore.createDecoder({
          read(bytes, offset = 0) {
            const slice = bytes.slice(offset);
            const value = btoa(String.fromCharCode(...slice));
            return [value, bytes.length];
          }
        });
      }
    };
    var getBase64Codec = () => codecsCore.combineCodec(getBase64Encoder(), getBase64Decoder());
    var removeNullCharacters = (value) => (
      // eslint-disable-next-line no-control-regex
      value.replace(/\u0000/g, "")
    );
    var padNullCharacters = (value, chars) => value.padEnd(chars, "\0");
    var e = globalThis.TextDecoder;
    var o = globalThis.TextEncoder;
    var getUtf8Encoder = () => {
      let textEncoder;
      return codecsCore.createEncoder({
        getSizeFromValue: (value) => (textEncoder || (textEncoder = new o())).encode(value).length,
        write: (value, bytes, offset) => {
          const bytesToAdd = (textEncoder || (textEncoder = new o())).encode(value);
          bytes.set(bytesToAdd, offset);
          return offset + bytesToAdd.length;
        }
      });
    };
    var getUtf8Decoder = () => {
      let textDecoder;
      return codecsCore.createDecoder({
        read(bytes, offset) {
          const value = (textDecoder || (textDecoder = new e())).decode(bytes.slice(offset));
          return [removeNullCharacters(value), bytes.length];
        }
      });
    };
    var getUtf8Codec = () => codecsCore.combineCodec(getUtf8Encoder(), getUtf8Decoder());
    exports.assertValidBaseString = assertValidBaseString;
    exports.getBase10Codec = getBase10Codec;
    exports.getBase10Decoder = getBase10Decoder;
    exports.getBase10Encoder = getBase10Encoder;
    exports.getBase16Codec = getBase16Codec;
    exports.getBase16Decoder = getBase16Decoder;
    exports.getBase16Encoder = getBase16Encoder;
    exports.getBase58Codec = getBase58Codec;
    exports.getBase58Decoder = getBase58Decoder;
    exports.getBase58Encoder = getBase58Encoder;
    exports.getBase64Codec = getBase64Codec;
    exports.getBase64Decoder = getBase64Decoder;
    exports.getBase64Encoder = getBase64Encoder;
    exports.getBaseXCodec = getBaseXCodec;
    exports.getBaseXDecoder = getBaseXDecoder;
    exports.getBaseXEncoder = getBaseXEncoder;
    exports.getBaseXResliceCodec = getBaseXResliceCodec;
    exports.getBaseXResliceDecoder = getBaseXResliceDecoder;
    exports.getBaseXResliceEncoder = getBaseXResliceEncoder;
    exports.getUtf8Codec = getUtf8Codec;
    exports.getUtf8Decoder = getUtf8Decoder;
    exports.getUtf8Encoder = getUtf8Encoder;
    exports.padNullCharacters = padNullCharacters;
    exports.removeNullCharacters = removeNullCharacters;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/options/dist/index.browser.cjs
var require_index_browser6 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/options/dist/index.browser.cjs"(exports) {
    "use strict";
    var codecsCore = require_index_browser2();
    var codecsDataStructures = require_index_browser4();
    var codecsNumbers = require_index_browser3();
    var some = (value) => ({ __option: "Some", value });
    var none = () => ({ __option: "None" });
    var isOption = (input) => !!(input && typeof input === "object" && "__option" in input && (input.__option === "Some" && "value" in input || input.__option === "None"));
    var isSome = (option) => option.__option === "Some";
    var isNone = (option) => option.__option === "None";
    function unwrapOption(option, fallback) {
      if (isSome(option)) return option.value;
      return fallback ? fallback() : null;
    }
    var wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();
    function getOptionEncoder(item, config = {}) {
      const prefix = (() => {
        if (config.prefix === null) {
          return codecsCore.transformEncoder(codecsDataStructures.getUnitEncoder(), (_boolean) => void 0);
        }
        return codecsDataStructures.getBooleanEncoder({ size: config.prefix ?? codecsNumbers.getU8Encoder() });
      })();
      const noneValue = (() => {
        if (config.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixEncoderSize(codecsDataStructures.getUnitEncoder(), item.fixedSize);
        }
        if (!config.noneValue) {
          return codecsDataStructures.getUnitEncoder();
        }
        return codecsDataStructures.getConstantEncoder(config.noneValue);
      })();
      return codecsDataStructures.getUnionEncoder(
        [
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, noneValue]), (_value) => [
            false,
            void 0
          ]),
          codecsCore.transformEncoder(codecsDataStructures.getTupleEncoder([prefix, item]), (value) => [
            true,
            isOption(value) && isSome(value) ? value.value : value
          ])
        ],
        (variant) => {
          const option = isOption(variant) ? variant : wrapNullable(variant);
          return Number(isSome(option));
        }
      );
    }
    function getOptionDecoder(item, config = {}) {
      const prefix = (() => {
        if (config.prefix === null) {
          return codecsCore.transformDecoder(codecsDataStructures.getUnitDecoder(), () => false);
        }
        return codecsDataStructures.getBooleanDecoder({ size: config.prefix ?? codecsNumbers.getU8Decoder() });
      })();
      const noneValue = (() => {
        if (config.noneValue === "zeroes") {
          codecsCore.assertIsFixedSize(item);
          return codecsCore.fixDecoderSize(codecsDataStructures.getUnitDecoder(), item.fixedSize);
        }
        if (!config.noneValue) {
          return codecsDataStructures.getUnitDecoder();
        }
        return codecsDataStructures.getConstantDecoder(config.noneValue);
      })();
      return codecsDataStructures.getUnionDecoder(
        [
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, noneValue]), () => none()),
          codecsCore.transformDecoder(codecsDataStructures.getTupleDecoder([prefix, item]), ([, value]) => some(value))
        ],
        (bytes, offset) => {
          if (config.prefix === null && !config.noneValue) {
            return Number(offset < bytes.length);
          }
          if (config.prefix === null && config.noneValue != null) {
            const zeroValue = config.noneValue === "zeroes" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;
            return codecsCore.containsBytes(bytes, zeroValue, offset) ? 0 : 1;
          }
          return Number(prefix.read(bytes, offset)[0]);
        }
      );
    }
    function getOptionCodec(item, config = {}) {
      return codecsCore.combineCodec(
        getOptionEncoder(item, config),
        getOptionDecoder(item, config)
      );
    }
    function unwrapOptionRecursively(input, fallback) {
      if (!input || ArrayBuffer.isView(input)) {
        return input;
      }
      const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);
      if (isOption(input)) {
        if (isSome(input)) return next(input.value);
        return fallback ? fallback() : null;
      }
      if (Array.isArray(input)) {
        return input.map(next);
      }
      if (typeof input === "object") {
        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));
      }
      return input;
    }
    exports.getOptionCodec = getOptionCodec;
    exports.getOptionDecoder = getOptionDecoder;
    exports.getOptionEncoder = getOptionEncoder;
    exports.isNone = isNone;
    exports.isOption = isOption;
    exports.isSome = isSome;
    exports.none = none;
    exports.some = some;
    exports.unwrapOption = unwrapOption;
    exports.unwrapOptionRecursively = unwrapOptionRecursively;
    exports.wrapNullable = wrapNullable;
  }
});

// node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs/dist/index.browser.cjs
var require_index_browser7 = __commonJS({
  "node_modules/@solana/spl-token-metadata/node_modules/@solana/codecs/dist/index.browser.cjs"(exports) {
    "use strict";
    var codecsCore = require_index_browser2();
    var codecsDataStructures = require_index_browser4();
    var codecsNumbers = require_index_browser3();
    var codecsStrings = require_index_browser5();
    var options = require_index_browser6();
    Object.keys(codecsCore).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return codecsCore[k];
        }
      });
    });
    Object.keys(codecsDataStructures).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return codecsDataStructures[k];
        }
      });
    });
    Object.keys(codecsNumbers).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return codecsNumbers[k];
        }
      });
    });
    Object.keys(codecsStrings).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return codecsStrings[k];
        }
      });
    });
    Object.keys(options).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function() {
          return options[k];
        }
      });
    });
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/field.js
var require_field = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/field.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFieldCodec = exports.Field = void 0;
    exports.getFieldConfig = getFieldConfig;
    var codecs_1 = require_index_browser7();
    var Field;
    (function(Field2) {
      Field2[Field2["Name"] = 0] = "Name";
      Field2[Field2["Symbol"] = 1] = "Symbol";
      Field2[Field2["Uri"] = 2] = "Uri";
    })(Field || (exports.Field = Field = {}));
    var getFieldCodec = () => [
      ["Name", (0, codecs_1.getUnitCodec)()],
      ["Symbol", (0, codecs_1.getUnitCodec)()],
      ["Uri", (0, codecs_1.getUnitCodec)()],
      ["Key", (0, codecs_1.getStructCodec)([["value", (0, codecs_1.getTupleCodec)([(0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)())])]])]
    ];
    exports.getFieldCodec = getFieldCodec;
    function getFieldConfig(field) {
      if (field === Field.Name || field === "Name" || field === "name") {
        return { __kind: "Name" };
      } else if (field === Field.Symbol || field === "Symbol" || field === "symbol") {
        return { __kind: "Symbol" };
      } else if (field === Field.Uri || field === "Uri" || field === "uri") {
        return { __kind: "Uri" };
      } else {
        return { __kind: "Key", value: [field] };
      }
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js
var require_instruction = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/instruction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInitializeInstruction = createInitializeInstruction;
    exports.createUpdateFieldInstruction = createUpdateFieldInstruction;
    exports.createRemoveKeyInstruction = createRemoveKeyInstruction;
    exports.createUpdateAuthorityInstruction = createUpdateAuthorityInstruction;
    exports.createEmitInstruction = createEmitInstruction;
    var codecs_1 = require_index_browser7();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var field_js_1 = require_field();
    function getInstructionEncoder(discriminator, dataEncoder) {
      return (0, codecs_1.transformEncoder)((0, codecs_1.getTupleEncoder)([(0, codecs_1.getBytesEncoder)(), dataEncoder]), (data) => [
        discriminator,
        data
      ]);
    }
    function getPublicKeyEncoder() {
      return (0, codecs_1.transformEncoder)((0, codecs_1.fixEncoderSize)((0, codecs_1.getBytesEncoder)(), 32), (publicKey) => publicKey.toBytes());
    }
    function getStringEncoder() {
      return (0, codecs_1.addEncoderSizePrefix)((0, codecs_1.getUtf8Encoder)(), (0, codecs_1.getU32Encoder)());
    }
    function createInitializeInstruction(args) {
      const { programId, metadata, updateAuthority, mint, mintAuthority, name, symbol, uri } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: false, isWritable: false, pubkey: updateAuthority },
          { isSigner: false, isWritable: false, pubkey: mint },
          { isSigner: true, isWritable: false, pubkey: mintAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:initialize_account') */
          210,
          225,
          30,
          162,
          88,
          184,
          77,
          141
        ]), (0, codecs_1.getStructEncoder)([
          ["name", getStringEncoder()],
          ["symbol", getStringEncoder()],
          ["uri", getStringEncoder()]
        ])).encode({ name, symbol, uri }))
      });
    }
    function createUpdateFieldInstruction(args) {
      const { programId, metadata, updateAuthority, field, value } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:updating_field') */
          221,
          233,
          49,
          45,
          181,
          202,
          220,
          200
        ]), (0, codecs_1.getStructEncoder)([
          ["field", (0, codecs_1.getDataEnumCodec)((0, field_js_1.getFieldCodec)())],
          ["value", getStringEncoder()]
        ])).encode({ field: (0, field_js_1.getFieldConfig)(field), value }))
      });
    }
    function createRemoveKeyInstruction(args) {
      const { programId, metadata, updateAuthority, key, idempotent } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: updateAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:remove_key_ix') */
          234,
          18,
          32,
          56,
          89,
          141,
          37,
          181
        ]), (0, codecs_1.getStructEncoder)([
          ["idempotent", (0, codecs_1.getBooleanEncoder)()],
          ["key", getStringEncoder()]
        ])).encode({ idempotent, key }))
      });
    }
    function createUpdateAuthorityInstruction(args) {
      const { programId, metadata, oldAuthority, newAuthority } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [
          { isSigner: false, isWritable: true, pubkey: metadata },
          { isSigner: true, isWritable: false, pubkey: oldAuthority }
        ],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:update_the_authority') */
          215,
          228,
          166,
          228,
          84,
          100,
          86,
          123
        ]), (0, codecs_1.getStructEncoder)([["newAuthority", getPublicKeyEncoder()]])).encode({ newAuthority: newAuthority !== null && newAuthority !== void 0 ? newAuthority : web3_js_1.SystemProgram.programId }))
      });
    }
    function createEmitInstruction(args) {
      const { programId, metadata, start, end } = args;
      return new web3_js_1.TransactionInstruction({
        programId,
        keys: [{ isSigner: false, isWritable: false, pubkey: metadata }],
        data: Buffer.from(getInstructionEncoder(new Uint8Array([
          /* await splDiscriminate('spl_token_metadata_interface:emitter') */
          250,
          166,
          180,
          250,
          13,
          12,
          184,
          70
        ]), (0, codecs_1.getStructEncoder)([
          ["start", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())],
          ["end", (0, codecs_1.getOptionEncoder)((0, codecs_1.getU64Encoder)())]
        ])).encode({ start: start !== null && start !== void 0 ? start : null, end: end !== null && end !== void 0 ? end : null }))
      });
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/state.js
var require_state8 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/state.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TOKEN_METADATA_DISCRIMINATOR = void 0;
    exports.pack = pack;
    exports.unpack = unpack;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var codecs_1 = require_index_browser7();
    exports.TOKEN_METADATA_DISCRIMINATOR = Buffer.from([112, 132, 90, 90, 11, 88, 157, 87]);
    function getStringCodec() {
      return (0, codecs_1.addCodecSizePrefix)((0, codecs_1.getUtf8Codec)(), (0, codecs_1.getU32Codec)());
    }
    var tokenMetadataCodec = (0, codecs_1.getStructCodec)([
      ["updateAuthority", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["mint", (0, codecs_1.fixCodecSize)((0, codecs_1.getBytesCodec)(), 32)],
      ["name", getStringCodec()],
      ["symbol", getStringCodec()],
      ["uri", getStringCodec()],
      ["additionalMetadata", (0, codecs_1.getArrayCodec)((0, codecs_1.getTupleCodec)([getStringCodec(), getStringCodec()]))]
    ]);
    function isNonePubkey(buffer) {
      for (let i = 0; i < buffer.length; i++) {
        if (buffer[i] !== 0) {
          return false;
        }
      }
      return true;
    }
    function pack(meta) {
      var _a;
      const updateAuthority = (_a = meta.updateAuthority) !== null && _a !== void 0 ? _a : web3_js_1.PublicKey.default;
      return tokenMetadataCodec.encode(Object.assign(Object.assign({}, meta), { updateAuthority: updateAuthority.toBuffer(), mint: meta.mint.toBuffer() }));
    }
    function unpack(buffer) {
      const data = tokenMetadataCodec.decode(buffer);
      return isNonePubkey(data.updateAuthority) ? {
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      } : {
        updateAuthority: new web3_js_1.PublicKey(data.updateAuthority),
        mint: new web3_js_1.PublicKey(data.mint),
        name: data.name,
        symbol: data.symbol,
        uri: data.uri,
        additionalMetadata: data.additionalMetadata
      };
    }
  }
});

// node_modules/@solana/spl-token-metadata/lib/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@solana/spl-token-metadata/lib/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors3(), exports);
    __exportStar(require_field(), exports);
    __exportStar(require_instruction(), exports);
    __exportStar(require_state8(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js
var require_state9 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/state.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTokenMetadata = exports.updateTokenMetadata = void 0;
    var spl_token_metadata_1 = require_cjs2();
    var constants_js_1 = require_constants();
    var extensionType_js_1 = require_extensionType();
    var mint_js_1 = require_mint();
    var getNormalizedTokenMetadataField = (field) => {
      if (field === spl_token_metadata_1.Field.Name || field === "Name" || field === "name") {
        return "name";
      }
      if (field === spl_token_metadata_1.Field.Symbol || field === "Symbol" || field === "symbol") {
        return "symbol";
      }
      if (field === spl_token_metadata_1.Field.Uri || field === "Uri" || field === "uri") {
        return "uri";
      }
      return field;
    };
    function updateTokenMetadata(current, key, value) {
      const field = getNormalizedTokenMetadataField(key);
      if (field === "mint" || field === "updateAuthority") {
        throw new Error(`Cannot update ${field} via this instruction`);
      }
      if (["name", "symbol", "uri"].includes(field)) {
        return Object.assign(Object.assign({}, current), { [field]: value });
      }
      const additionalMetadata = [...current.additionalMetadata];
      const i = current.additionalMetadata.findIndex((x) => x[0] === field);
      if (i === -1) {
        additionalMetadata.push([field, value]);
      } else {
        additionalMetadata[i] = [field, value];
      }
      return Object.assign(Object.assign({}, current), { additionalMetadata });
    }
    exports.updateTokenMetadata = updateTokenMetadata;
    function getTokenMetadata(connection, address, commitment, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const mintInfo = yield (0, mint_js_1.getMint)(connection, address, commitment, programId);
        const data = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mintInfo.tlvData);
        if (data === null) {
          return null;
        }
        return (0, spl_token_metadata_1.unpack)(data);
      });
    }
    exports.getTokenMetadata = getTokenMetadata;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/index.js
var require_state10 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/state/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_account(), exports);
    __exportStar(require_mint(), exports);
    __exportStar(require_multisig(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js
var require_actions8 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/actions.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tokenMetadataUpdateAuthority = exports.tokenMetadataRemoveKey = exports.tokenMetadataUpdateFieldWithRentTransfer = exports.tokenMetadataUpdateField = exports.tokenMetadataInitializeWithRentTransfer = exports.tokenMetadataInitialize = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var spl_token_metadata_1 = require_cjs2();
    var constants_js_1 = require_constants();
    var internal_js_1 = require_internal2();
    var extensionType_js_1 = require_extensionType();
    var state_js_1 = require_state9();
    var errors_js_1 = require_errors2();
    var index_js_1 = require_state10();
    function getAdditionalRentForNewMetadata(connection, address, tokenMetadata, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const extensionLen = (0, spl_token_metadata_1.pack)(tokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function getAdditionalRentForUpdatedMetadata(connection, address, field, value, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const info = yield connection.getAccountInfo(address);
        if (!info) {
          throw new errors_js_1.TokenAccountNotFoundError();
        }
        const mint = (0, index_js_1.unpackMint)(address, info, programId);
        const extensionData = (0, extensionType_js_1.getExtensionData)(extensionType_js_1.ExtensionType.TokenMetadata, mint.tlvData);
        if (extensionData === null) {
          throw new Error("TokenMetadata extension not initialized");
        }
        const updatedTokenMetadata = (0, state_js_1.updateTokenMetadata)((0, spl_token_metadata_1.unpack)(extensionData), field, value);
        const extensionLen = (0, spl_token_metadata_1.pack)(updatedTokenMetadata).length;
        const newAccountLen = (0, extensionType_js_1.getNewAccountLenForExtensionLen)(info, address, extensionType_js_1.ExtensionType.TokenMetadata, extensionLen, programId);
        if (newAccountLen <= info.data.length) {
          return 0;
        }
        const newRentExemptMinimum = yield connection.getMinimumBalanceForRentExemption(newAccountLen);
        return newRentExemptMinimum - info.lamports;
      });
    }
    function tokenMetadataInitialize(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataInitialize = tokenMetadataInitialize;
    function tokenMetadataInitializeWithRentTransfer(connection, payer, mint, updateAuthority, mintAuthority, name, symbol, uri, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [mintAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(mintAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForNewMetadata(connection, mint, {
          updateAuthority,
          mint,
          name,
          symbol,
          uri,
          additionalMetadata: []
        }, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createInitializeInstruction)({
          programId,
          metadata: mint,
          updateAuthority,
          mint,
          mintAuthority: mintAuthorityPublicKey,
          name,
          symbol,
          uri
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataInitializeWithRentTransfer = tokenMetadataInitializeWithRentTransfer;
    function tokenMetadataUpdateField(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataUpdateField = tokenMetadataUpdateField;
    function tokenMetadataUpdateFieldWithRentTransfer(connection, payer, mint, updateAuthority, field, value, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction();
        const lamports = yield getAdditionalRentForUpdatedMetadata(connection, mint, field, value, programId);
        if (lamports > 0) {
          transaction.add(web3_js_1.SystemProgram.transfer({ fromPubkey: payer.publicKey, toPubkey: mint, lamports }));
        }
        transaction.add((0, spl_token_metadata_1.createUpdateFieldInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          field,
          value
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataUpdateFieldWithRentTransfer = tokenMetadataUpdateFieldWithRentTransfer;
    function tokenMetadataRemoveKey(connection, payer, mint, updateAuthority, key, idempotent, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createRemoveKeyInstruction)({
          programId,
          metadata: mint,
          updateAuthority: updateAuthorityPublicKey,
          key,
          idempotent
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataRemoveKey = tokenMetadataRemoveKey;
    function tokenMetadataUpdateAuthority(connection, payer, mint, updateAuthority, newAuthority, multiSigners = [], confirmOptions, programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      return __awaiter(this, void 0, void 0, function* () {
        const [updateAuthorityPublicKey, signers] = (0, internal_js_1.getSigners)(updateAuthority, multiSigners);
        const transaction = new web3_js_1.Transaction().add((0, spl_token_metadata_1.createUpdateAuthorityInstruction)({
          programId,
          metadata: mint,
          oldAuthority: updateAuthorityPublicKey,
          newAuthority
        }));
        return yield (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer, ...signers], confirmOptions);
      });
    }
    exports.tokenMetadataUpdateAuthority = tokenMetadataUpdateAuthority;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js
var require_tokenMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/tokenMetadata/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions8(), exports);
    __exportStar(require_state9(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/index.js
var require_extensions = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/extensions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_accountType(), exports);
    __exportStar(require_cpiGuard(), exports);
    __exportStar(require_defaultAccountState(), exports);
    __exportStar(require_extensionType(), exports);
    __exportStar(require_immutableOwner(), exports);
    __exportStar(require_interestBearingMint(), exports);
    __exportStar(require_memoTransfer(), exports);
    __exportStar(require_metadataPointer(), exports);
    __exportStar(require_tokenMetadata(), exports);
    __exportStar(require_mintCloseAuthority(), exports);
    __exportStar(require_nonTransferable(), exports);
    __exportStar(require_transferFee(), exports);
    __exportStar(require_permanentDelegate(), exports);
    __exportStar(require_transferHook(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js
var require_initializeAccount2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeAccount2InstructionUnchecked = exports.decodeInitializeAccount2Instruction = exports.createInitializeAccount2Instruction = exports.initializeAccount2InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeAccount2InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount2Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports.initializeAccount2InstructionData.span);
      exports.initializeAccount2InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount2, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeAccount2Instruction = createInitializeAccount2Instruction;
    function decodeInitializeAccount2Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeAccount2InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint, rent }, data } = decodeInitializeAccount2InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint || !rent)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data
      };
    }
    exports.decodeInitializeAccount2Instruction = decodeInitializeAccount2Instruction;
    function decodeInitializeAccount2InstructionUnchecked({ programId, keys: [account, mint, rent], data }) {
      return {
        programId,
        keys: {
          account,
          mint,
          rent
        },
        data: exports.initializeAccount2InstructionData.decode(data)
      };
    }
    exports.decodeInitializeAccount2InstructionUnchecked = decodeInitializeAccount2InstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js
var require_initializeAccount3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeAccount3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeAccount3InstructionUnchecked = exports.decodeInitializeAccount3Instruction = exports.createInitializeAccount3Instruction = exports.initializeAccount3InstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeAccount3InstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("owner")
    ]);
    function createInitializeAccount3Instruction(account, mint, owner, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      const keys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: mint, isSigner: false, isWritable: false }
      ];
      const data = Buffer.alloc(exports.initializeAccount3InstructionData.span);
      exports.initializeAccount3InstructionData.encode({ instruction: types_js_1.TokenInstruction.InitializeAccount3, owner }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeAccount3Instruction = createInitializeAccount3Instruction;
    function decodeInitializeAccount3Instruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeAccount3InstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account, mint }, data } = decodeInitializeAccount3InstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeAccount3)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account || !mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account,
          mint
        },
        data
      };
    }
    exports.decodeInitializeAccount3Instruction = decodeInitializeAccount3Instruction;
    function decodeInitializeAccount3InstructionUnchecked({ programId, keys: [account, mint], data }) {
      return {
        programId,
        keys: {
          account,
          mint
        },
        data: exports.initializeAccount3InstructionData.decode(data)
      };
    }
    exports.decodeInitializeAccount3InstructionUnchecked = decodeInitializeAccount3InstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/decode.js
var require_decode = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUiamountToAmountInstruction = exports.isAmountToUiAmountInstruction = exports.isInitializeMint2Instruction = exports.isInitializeAccount3Instruction = exports.isSyncNativeInstruction = exports.isInitializeAccount2Instruction = exports.isBurnCheckedInstruction = exports.isMintToCheckedInstruction = exports.isApproveCheckedInstruction = exports.isTransferCheckedInstruction = exports.isThawAccountInstruction = exports.isFreezeAccountInstruction = exports.isCloseAccountInstruction = exports.isBurnInstruction = exports.isMintToInstruction = exports.isSetAuthorityInstruction = exports.isRevokeInstruction = exports.isApproveInstruction = exports.isTransferInstruction = exports.isInitializeMultisigInstruction = exports.isInitializeAccountInstruction = exports.isInitializeMintInstruction = exports.decodeInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var amountToUiAmount_js_1 = require_amountToUiAmount();
    var approve_js_1 = require_approve();
    var approveChecked_js_1 = require_approveChecked();
    var burn_js_1 = require_burn();
    var burnChecked_js_1 = require_burnChecked();
    var closeAccount_js_1 = require_closeAccount();
    var freezeAccount_js_1 = require_freezeAccount();
    var initializeAccount_js_1 = require_initializeAccount();
    var initializeAccount2_js_1 = require_initializeAccount2();
    var initializeAccount3_js_1 = require_initializeAccount3();
    var initializeMint_js_1 = require_initializeMint();
    var initializeMint2_js_1 = require_initializeMint2();
    var initializeMultisig_js_1 = require_initializeMultisig();
    var mintTo_js_1 = require_mintTo();
    var mintToChecked_js_1 = require_mintToChecked();
    var revoke_js_1 = require_revoke();
    var setAuthority_js_1 = require_setAuthority();
    var syncNative_js_1 = require_syncNative();
    var thawAccount_js_1 = require_thawAccount();
    var transfer_js_1 = require_transfer();
    var transferChecked_js_1 = require_transferChecked();
    var types_js_1 = require_types3();
    var uiAmountToAmount_js_1 = require_uiAmountToAmount();
    function decodeInstruction(instruction, programId = constants_js_1.TOKEN_PROGRAM_ID) {
      if (!instruction.data.length)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const type = (0, buffer_layout_1.u8)().decode(instruction.data);
      if (type === types_js_1.TokenInstruction.InitializeMint)
        return (0, initializeMint_js_1.decodeInitializeMintInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount)
        return (0, initializeAccount_js_1.decodeInitializeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig)
        return (0, initializeMultisig_js_1.decodeInitializeMultisigInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Transfer)
        return (0, transfer_js_1.decodeTransferInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Approve)
        return (0, approve_js_1.decodeApproveInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Revoke)
        return (0, revoke_js_1.decodeRevokeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SetAuthority)
        return (0, setAuthority_js_1.decodeSetAuthorityInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintTo)
        return (0, mintTo_js_1.decodeMintToInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.Burn)
        return (0, burn_js_1.decodeBurnInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.CloseAccount)
        return (0, closeAccount_js_1.decodeCloseAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.FreezeAccount)
        return (0, freezeAccount_js_1.decodeFreezeAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ThawAccount)
        return (0, thawAccount_js_1.decodeThawAccountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.TransferChecked)
        return (0, transferChecked_js_1.decodeTransferCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.ApproveChecked)
        return (0, approveChecked_js_1.decodeApproveCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.MintToChecked)
        return (0, mintToChecked_js_1.decodeMintToCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.BurnChecked)
        return (0, burnChecked_js_1.decodeBurnCheckedInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount2)
        return (0, initializeAccount2_js_1.decodeInitializeAccount2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.SyncNative)
        return (0, syncNative_js_1.decodeSyncNativeInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeAccount3)
        return (0, initializeAccount3_js_1.decodeInitializeAccount3Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMint2)
        return (0, initializeMint2_js_1.decodeInitializeMint2Instruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.AmountToUiAmount)
        return (0, amountToUiAmount_js_1.decodeAmountToUiAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.UiAmountToAmount)
        return (0, uiAmountToAmount_js_1.decodeUiAmountToAmountInstruction)(instruction, programId);
      if (type === types_js_1.TokenInstruction.InitializeMultisig2)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      throw new errors_js_1.TokenInvalidInstructionTypeError();
    }
    exports.decodeInstruction = decodeInstruction;
    function isInitializeMintInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint;
    }
    exports.isInitializeMintInstruction = isInitializeMintInstruction;
    function isInitializeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount;
    }
    exports.isInitializeAccountInstruction = isInitializeAccountInstruction;
    function isInitializeMultisigInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMultisig;
    }
    exports.isInitializeMultisigInstruction = isInitializeMultisigInstruction;
    function isTransferInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Transfer;
    }
    exports.isTransferInstruction = isTransferInstruction;
    function isApproveInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Approve;
    }
    exports.isApproveInstruction = isApproveInstruction;
    function isRevokeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Revoke;
    }
    exports.isRevokeInstruction = isRevokeInstruction;
    function isSetAuthorityInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SetAuthority;
    }
    exports.isSetAuthorityInstruction = isSetAuthorityInstruction;
    function isMintToInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintTo;
    }
    exports.isMintToInstruction = isMintToInstruction;
    function isBurnInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.Burn;
    }
    exports.isBurnInstruction = isBurnInstruction;
    function isCloseAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.CloseAccount;
    }
    exports.isCloseAccountInstruction = isCloseAccountInstruction;
    function isFreezeAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.FreezeAccount;
    }
    exports.isFreezeAccountInstruction = isFreezeAccountInstruction;
    function isThawAccountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ThawAccount;
    }
    exports.isThawAccountInstruction = isThawAccountInstruction;
    function isTransferCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.TransferChecked;
    }
    exports.isTransferCheckedInstruction = isTransferCheckedInstruction;
    function isApproveCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.ApproveChecked;
    }
    exports.isApproveCheckedInstruction = isApproveCheckedInstruction;
    function isMintToCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.MintToChecked;
    }
    exports.isMintToCheckedInstruction = isMintToCheckedInstruction;
    function isBurnCheckedInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.BurnChecked;
    }
    exports.isBurnCheckedInstruction = isBurnCheckedInstruction;
    function isInitializeAccount2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount2;
    }
    exports.isInitializeAccount2Instruction = isInitializeAccount2Instruction;
    function isSyncNativeInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.SyncNative;
    }
    exports.isSyncNativeInstruction = isSyncNativeInstruction;
    function isInitializeAccount3Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeAccount3;
    }
    exports.isInitializeAccount3Instruction = isInitializeAccount3Instruction;
    function isInitializeMint2Instruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.InitializeMint2;
    }
    exports.isInitializeMint2Instruction = isInitializeMint2Instruction;
    function isAmountToUiAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.AmountToUiAmount;
    }
    exports.isAmountToUiAmountInstruction = isAmountToUiAmountInstruction;
    function isUiamountToAmountInstruction(decoded) {
      return decoded.data.instruction === types_js_1.TokenInstruction.UiAmountToAmount;
    }
    exports.isUiamountToAmountInstruction = isUiamountToAmountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js
var require_initializeMultisig2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMultisig2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js
var require_initializeImmutableOwner = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeImmutableOwner.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeImmutableOwnerInstructionUnchecked = exports.decodeInitializeImmutableOwnerInstruction = exports.createInitializeImmutableOwnerInstruction = exports.initializeImmutableOwnerInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeImmutableOwnerInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeImmutableOwnerInstruction(account, programId) {
      const keys = [{ pubkey: account, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeImmutableOwnerInstructionData.span);
      exports.initializeImmutableOwnerInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeImmutableOwner
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeImmutableOwnerInstruction = createInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeImmutableOwnerInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { account }, data } = decodeInitializeImmutableOwnerInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeImmutableOwner)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!account)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          account
        },
        data
      };
    }
    exports.decodeInitializeImmutableOwnerInstruction = decodeInitializeImmutableOwnerInstruction;
    function decodeInitializeImmutableOwnerInstructionUnchecked({ programId, keys: [account], data }) {
      const { instruction } = exports.initializeImmutableOwnerInstructionData.decode(data);
      return {
        programId,
        keys: {
          account
        },
        data: {
          instruction
        }
      };
    }
    exports.decodeInitializeImmutableOwnerInstructionUnchecked = decodeInitializeImmutableOwnerInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js
var require_initializeMintCloseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeMintCloseAuthority.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializeMintCloseAuthorityInstructionUnchecked = exports.decodeInitializeMintCloseAuthorityInstruction = exports.createInitializeMintCloseAuthorityInstruction = exports.initializeMintCloseAuthorityInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeMintCloseAuthorityInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_1.u8)("closeAuthorityOption"),
      (0, buffer_layout_utils_1.publicKey)("closeAuthority")
    ]);
    function createInitializeMintCloseAuthorityInstruction(mint, closeAuthority, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeMintCloseAuthorityInstructionData.span);
      exports.initializeMintCloseAuthorityInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeMintCloseAuthority,
        closeAuthorityOption: closeAuthority ? 1 : 0,
        closeAuthority: closeAuthority || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeMintCloseAuthorityInstruction = createInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializeMintCloseAuthorityInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializeMintCloseAuthorityInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializeMintCloseAuthority)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeInitializeMintCloseAuthorityInstruction = decodeInitializeMintCloseAuthorityInstruction;
    function decodeInitializeMintCloseAuthorityInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, closeAuthorityOption, closeAuthority } = exports.initializeMintCloseAuthorityInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          closeAuthority: closeAuthorityOption ? closeAuthority : null
        }
      };
    }
    exports.decodeInitializeMintCloseAuthorityInstructionUnchecked = decodeInitializeMintCloseAuthorityInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js
var require_reallocate = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/reallocate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReallocateInstruction = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var internal_js_1 = require_internal();
    var types_js_1 = require_types3();
    function createReallocateInstruction(account, payer, extensionTypes, owner, multiSigners = [], programId = constants_js_1.TOKEN_2022_PROGRAM_ID) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const baseKeys = [
        { pubkey: account, isSigner: false, isWritable: true },
        { pubkey: payer, isSigner: true, isWritable: true },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false }
      ];
      const keys = (0, internal_js_1.addSigners)(baseKeys, owner, multiSigners);
      const reallocateInstructionData = (0, buffer_layout_1.struct)([
        (0, buffer_layout_1.u8)("instruction"),
        (0, buffer_layout_1.seq)((0, buffer_layout_1.u16)(), extensionTypes.length, "extensionTypes")
      ]);
      const data = Buffer.alloc(reallocateInstructionData.span);
      reallocateInstructionData.encode({ instruction: types_js_1.TokenInstruction.Reallocate, extensionTypes }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createReallocateInstruction = createReallocateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js
var require_initializeNonTransferableMint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializeNonTransferableMint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createInitializeNonTransferableMintInstruction = exports.initializeNonTransferableMintInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializeNonTransferableMintInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction")
    ]);
    function createInitializeNonTransferableMintInstruction(mint, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializeNonTransferableMintInstructionData.span);
      exports.initializeNonTransferableMintInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializeNonTransferableMint
      }, data);
      return new web3_js_1.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializeNonTransferableMintInstruction = createInitializeNonTransferableMintInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js
var require_initializePermanentDelegate = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/initializePermanentDelegate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeInitializePermanentDelegateInstructionUnchecked = exports.decodeInitializePermanentDelegateInstruction = exports.createInitializePermanentDelegateInstruction = exports.initializePermanentDelegateInstructionData = void 0;
    var buffer_layout_1 = require_Layout();
    var buffer_layout_utils_1 = require_cjs();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var web3_js_2 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var constants_js_1 = require_constants();
    var errors_js_1 = require_errors2();
    var types_js_1 = require_types3();
    exports.initializePermanentDelegateInstructionData = (0, buffer_layout_1.struct)([
      (0, buffer_layout_1.u8)("instruction"),
      (0, buffer_layout_utils_1.publicKey)("delegate")
    ]);
    function createInitializePermanentDelegateInstruction(mint, permanentDelegate, programId) {
      if (!(0, constants_js_1.programSupportsExtensions)(programId)) {
        throw new errors_js_1.TokenUnsupportedInstructionError();
      }
      const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];
      const data = Buffer.alloc(exports.initializePermanentDelegateInstructionData.span);
      exports.initializePermanentDelegateInstructionData.encode({
        instruction: types_js_1.TokenInstruction.InitializePermanentDelegate,
        delegate: permanentDelegate || new web3_js_1.PublicKey(0)
      }, data);
      return new web3_js_2.TransactionInstruction({ keys, programId, data });
    }
    exports.createInitializePermanentDelegateInstruction = createInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstruction(instruction, programId) {
      if (!instruction.programId.equals(programId))
        throw new errors_js_1.TokenInvalidInstructionProgramError();
      if (instruction.data.length !== exports.initializePermanentDelegateInstructionData.span)
        throw new errors_js_1.TokenInvalidInstructionDataError();
      const { keys: { mint }, data } = decodeInitializePermanentDelegateInstructionUnchecked(instruction);
      if (data.instruction !== types_js_1.TokenInstruction.InitializePermanentDelegate)
        throw new errors_js_1.TokenInvalidInstructionTypeError();
      if (!mint)
        throw new errors_js_1.TokenInvalidInstructionKeysError();
      return {
        programId,
        keys: {
          mint
        },
        data
      };
    }
    exports.decodeInitializePermanentDelegateInstruction = decodeInitializePermanentDelegateInstruction;
    function decodeInitializePermanentDelegateInstructionUnchecked({ programId, keys: [mint], data }) {
      const { instruction, delegate } = exports.initializePermanentDelegateInstructionData.decode(data);
      return {
        programId,
        keys: {
          mint
        },
        data: {
          instruction,
          delegate
        }
      };
    }
    exports.decodeInitializePermanentDelegateInstructionUnchecked = decodeInitializePermanentDelegateInstructionUnchecked;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/index.js
var require_instructions8 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/instructions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEmitInstruction = exports.createUpdateAuthorityInstruction = exports.createRemoveKeyInstruction = exports.createUpdateFieldInstruction = exports.createInitializeInstruction = void 0;
    var spl_token_metadata_1 = require_cjs2();
    Object.defineProperty(exports, "createInitializeInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createInitializeInstruction;
    } });
    Object.defineProperty(exports, "createUpdateFieldInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateFieldInstruction;
    } });
    Object.defineProperty(exports, "createRemoveKeyInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createRemoveKeyInstruction;
    } });
    Object.defineProperty(exports, "createUpdateAuthorityInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createUpdateAuthorityInstruction;
    } });
    Object.defineProperty(exports, "createEmitInstruction", { enumerable: true, get: function() {
      return spl_token_metadata_1.createEmitInstruction;
    } });
    __exportStar(require_associatedTokenAccount(), exports);
    __exportStar(require_decode(), exports);
    __exportStar(require_types3(), exports);
    __exportStar(require_initializeMint(), exports);
    __exportStar(require_initializeAccount(), exports);
    __exportStar(require_initializeMultisig(), exports);
    __exportStar(require_transfer(), exports);
    __exportStar(require_approve(), exports);
    __exportStar(require_revoke(), exports);
    __exportStar(require_setAuthority(), exports);
    __exportStar(require_mintTo(), exports);
    __exportStar(require_burn(), exports);
    __exportStar(require_closeAccount(), exports);
    __exportStar(require_freezeAccount(), exports);
    __exportStar(require_thawAccount(), exports);
    __exportStar(require_transferChecked(), exports);
    __exportStar(require_approveChecked(), exports);
    __exportStar(require_mintToChecked(), exports);
    __exportStar(require_burnChecked(), exports);
    __exportStar(require_initializeAccount2(), exports);
    __exportStar(require_syncNative(), exports);
    __exportStar(require_initializeAccount3(), exports);
    __exportStar(require_initializeMultisig2(), exports);
    __exportStar(require_initializeMint2(), exports);
    __exportStar(require_initializeImmutableOwner(), exports);
    __exportStar(require_amountToUiAmount(), exports);
    __exportStar(require_uiAmountToAmount(), exports);
    __exportStar(require_initializeMintCloseAuthority(), exports);
    __exportStar(require_reallocate(), exports);
    __exportStar(require_createNativeMint(), exports);
    __exportStar(require_initializeNonTransferableMint(), exports);
    __exportStar(require_initializePermanentDelegate(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/node_modules/@solana/spl-token/lib/cjs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actions6(), exports);
    __exportStar(require_constants(), exports);
    __exportStar(require_errors2(), exports);
    __exportStar(require_extensions(), exports);
    __exportStar(require_instructions8(), exports);
    __exportStar(require_state10(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ApproveUseAuthorityArgs.js
var require_ApproveUseAuthorityArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/ApproveUseAuthorityArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.approveUseAuthorityArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.approveUseAuthorityArgsBeet = new beet.BeetArgsStruct([["numberOfUses", beet.u64]], "ApproveUseAuthorityArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ApproveUseAuthority.js
var require_ApproveUseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ApproveUseAuthority.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createApproveUseAuthorityInstruction = exports.approveUseAuthorityInstructionDiscriminator = exports.ApproveUseAuthorityStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var ApproveUseAuthorityArgs_1 = require_ApproveUseAuthorityArgs();
    exports.ApproveUseAuthorityStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["approveUseAuthorityArgs", ApproveUseAuthorityArgs_1.approveUseAuthorityArgsBeet]
    ], "ApproveUseAuthorityInstructionArgs");
    exports.approveUseAuthorityInstructionDiscriminator = 20;
    function createApproveUseAuthorityInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.ApproveUseAuthorityStruct.serialize({
        instructionDiscriminator: exports.approveUseAuthorityInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.useAuthorityRecord,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.owner,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.user,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.ownerTokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.burner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createApproveUseAuthorityInstruction = createApproveUseAuthorityInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/SetCollectionSizeArgs.js
var require_SetCollectionSizeArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/SetCollectionSizeArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCollectionSizeArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.setCollectionSizeArgsBeet = new beet.BeetArgsStruct([["size", beet.u64]], "SetCollectionSizeArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BubblegumSetCollectionSize.js
var require_BubblegumSetCollectionSize = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BubblegumSetCollectionSize.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBubblegumSetCollectionSizeInstruction = exports.bubblegumSetCollectionSizeInstructionDiscriminator = exports.BubblegumSetCollectionSizeStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var SetCollectionSizeArgs_1 = require_SetCollectionSizeArgs();
    exports.BubblegumSetCollectionSizeStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["setCollectionSizeArgs", SetCollectionSizeArgs_1.setCollectionSizeArgsBeet]
    ], "BubblegumSetCollectionSizeInstructionArgs");
    exports.bubblegumSetCollectionSizeInstructionDiscriminator = 36;
    function createBubblegumSetCollectionSizeInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.BubblegumSetCollectionSizeStruct.serialize({
        instructionDiscriminator: exports.bubblegumSetCollectionSizeInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.collectionMetadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.bubblegumSigner,
          isWritable: false,
          isSigner: true
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createBubblegumSetCollectionSizeInstruction = createBubblegumSetCollectionSizeInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/BurnArgs.js
var require_BurnArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/BurnArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.burnArgsBeet = exports.isBurnArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var isBurnArgsV1 = (x) => x.__kind === "V1";
    exports.isBurnArgsV1 = isBurnArgsV1;
    exports.burnArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.BeetArgsStruct([["amount", beet.u64]], 'BurnArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Burn.js
var require_Burn = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Burn.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBurnInstruction = exports.burnInstructionDiscriminator = exports.BurnStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var BurnArgs_1 = require_BurnArgs();
    exports.BurnStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["burnArgs", BurnArgs_1.burnArgsBeet]
    ], "BurnInstructionArgs");
    exports.burnInstructionDiscriminator = 41;
    function createBurnInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const [data] = exports.BurnStruct.serialize({
        instructionDiscriminator: exports.burnInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.collectionMetadata) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.collectionMetadata != null,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.edition) !== null && _b !== void 0 ? _b : programId,
          isWritable: accounts.edition != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.masterEdition) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.masterEdition != null,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.masterEditionMint) !== null && _d !== void 0 ? _d : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.masterEditionToken) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.editionMarker) !== null && _f !== void 0 ? _f : programId,
          isWritable: accounts.editionMarker != null,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.tokenRecord) !== null && _g !== void 0 ? _g : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: (_h = accounts.systemProgram) !== null && _h !== void 0 ? _h : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createBurnInstruction = createBurnInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BurnEditionNft.js
var require_BurnEditionNft = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BurnEditionNft.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBurnEditionNftInstruction = exports.burnEditionNftInstructionDiscriminator = exports.BurnEditionNftStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.BurnEditionNftStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "BurnEditionNftInstructionArgs");
    exports.burnEditionNftInstructionDiscriminator = 37;
    function createBurnEditionNftInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.BurnEditionNftStruct.serialize({
        instructionDiscriminator: exports.burnEditionNftInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.owner,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.printEditionMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEditionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.printEditionTokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEditionTokenAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.masterEditionAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.printEditionAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMarkerAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createBurnEditionNftInstruction = createBurnEditionNftInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BurnNft.js
var require_BurnNft = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/BurnNft.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBurnNftInstruction = exports.burnNftInstructionDiscriminator = exports.BurnNftStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.BurnNftStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "BurnNftInstructionArgs");
    exports.burnNftInstructionDiscriminator = 29;
    function createBurnNftInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.BurnNftStruct.serialize({
        instructionDiscriminator: exports.burnNftInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.owner,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEditionAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionMetadata != null) {
        keys.push({
          pubkey: accounts.collectionMetadata,
          isWritable: true,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createBurnNftInstruction = createBurnNftInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CloseEscrowAccount.js
var require_CloseEscrowAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CloseEscrowAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCloseEscrowAccountInstruction = exports.closeEscrowAccountInstructionDiscriminator = exports.CloseEscrowAccountStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CloseEscrowAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CloseEscrowAccountInstructionArgs");
    exports.closeEscrowAccountInstructionDiscriminator = 39;
    function createCloseEscrowAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.CloseEscrowAccountStruct.serialize({
        instructionDiscriminator: exports.closeEscrowAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.escrow,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCloseEscrowAccountInstruction = createCloseEscrowAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Collect.js
var require_Collect = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Collect.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCollectInstruction = exports.collectInstructionDiscriminator = exports.CollectStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CollectStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CollectInstructionArgs");
    exports.collectInstructionDiscriminator = 54;
    function createCollectInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.CollectStruct.serialize({
        instructionDiscriminator: exports.collectInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.pdaAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCollectInstruction = createCollectInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ConvertMasterEditionV1ToV2.js
var require_ConvertMasterEditionV1ToV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ConvertMasterEditionV1ToV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConvertMasterEditionV1ToV2Instruction = exports.convertMasterEditionV1ToV2InstructionDiscriminator = exports.ConvertMasterEditionV1ToV2Struct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.ConvertMasterEditionV1ToV2Struct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "ConvertMasterEditionV1ToV2InstructionArgs");
    exports.convertMasterEditionV1ToV2InstructionDiscriminator = 12;
    function createConvertMasterEditionV1ToV2Instruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.ConvertMasterEditionV1ToV2Struct.serialize({
        instructionDiscriminator: exports.convertMasterEditionV1ToV2InstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.oneTimeAuth,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.printingMint,
          isWritable: true,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createConvertMasterEditionV1ToV2Instruction = createConvertMasterEditionV1ToV2Instruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AssetData.js
var require_AssetData = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AssetData.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assetDataBeet = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Creator_1 = require_Creator();
    var TokenStandard_1 = require_TokenStandard();
    var Collection_1 = require_Collection();
    var Uses_1 = require_Uses();
    var CollectionDetails_1 = require_CollectionDetails();
    exports.assetDataBeet = new beet.FixableBeetArgsStruct([
      ["name", beet.utf8String],
      ["symbol", beet.utf8String],
      ["uri", beet.utf8String],
      ["sellerFeeBasisPoints", beet.u16],
      ["creators", beet.coption(beet.array(Creator_1.creatorBeet))],
      ["primarySaleHappened", beet.bool],
      ["isMutable", beet.bool],
      ["tokenStandard", TokenStandard_1.tokenStandardBeet],
      ["collection", beet.coption(Collection_1.collectionBeet)],
      ["uses", beet.coption(Uses_1.usesBeet)],
      ["collectionDetails", beet.coption(CollectionDetails_1.collectionDetailsBeet)],
      ["ruleSet", beet.coption(beetSolana.publicKey)]
    ], "AssetData");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PrintSupply.js
var require_PrintSupply = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PrintSupply.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printSupplyBeet = exports.isPrintSupplyUnlimited = exports.isPrintSupplyLimited = exports.isPrintSupplyZero = void 0;
    var beet = __importStar(require_beet());
    var isPrintSupplyZero = (x) => x.__kind === "Zero";
    exports.isPrintSupplyZero = isPrintSupplyZero;
    var isPrintSupplyLimited = (x) => x.__kind === "Limited";
    exports.isPrintSupplyLimited = isPrintSupplyLimited;
    var isPrintSupplyUnlimited = (x) => x.__kind === "Unlimited";
    exports.isPrintSupplyUnlimited = isPrintSupplyUnlimited;
    exports.printSupplyBeet = beet.dataEnum([
      ["Zero", beet.unit],
      [
        "Limited",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([beet.u64])]], 'PrintSupplyRecord["Limited"]')
      ],
      ["Unlimited", beet.unit]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateArgs.js
var require_CreateArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createArgsBeet = exports.isCreateArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AssetData_1 = require_AssetData();
    var PrintSupply_1 = require_PrintSupply();
    var isCreateArgsV1 = (x) => x.__kind === "V1";
    exports.isCreateArgsV1 = isCreateArgsV1;
    exports.createArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([
          ["assetData", AssetData_1.assetDataBeet],
          ["decimals", beet.coption(beet.u8)],
          ["printSupply", beet.coption(PrintSupply_1.printSupplyBeet)]
        ], 'CreateArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Create.js
var require_Create = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Create.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateInstruction = exports.createInstructionDiscriminator = exports.CreateStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var CreateArgs_1 = require_CreateArgs();
    exports.CreateStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["createArgs", CreateArgs_1.createArgsBeet]
    ], "CreateInstructionArgs");
    exports.createInstructionDiscriminator = 42;
    function createCreateInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.CreateStruct.serialize({
        instructionDiscriminator: exports.createInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.masterEdition) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.masterEdition != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateInstruction = createCreateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateEscrowAccount.js
var require_CreateEscrowAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateEscrowAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateEscrowAccountInstruction = exports.createEscrowAccountInstructionDiscriminator = exports.CreateEscrowAccountStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CreateEscrowAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CreateEscrowAccountInstructionArgs");
    exports.createEscrowAccountInstructionDiscriminator = 38;
    function createCreateEscrowAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.CreateEscrowAccountStruct.serialize({
        instructionDiscriminator: exports.createEscrowAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.escrow,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.authority != null) {
        keys.push({
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateEscrowAccountInstruction = createCreateEscrowAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMasterEdition.js
var require_CreateMasterEdition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMasterEdition.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateMasterEditionInstruction = exports.createMasterEditionInstructionDiscriminator = exports.CreateMasterEditionStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CreateMasterEditionStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CreateMasterEditionInstructionArgs");
    exports.createMasterEditionInstructionDiscriminator = 10;
    function createCreateMasterEditionInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c;
      const [data] = exports.CreateMasterEditionStruct.serialize({
        instructionDiscriminator: exports.createMasterEditionInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.rent) !== null && _c !== void 0 ? _c : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateMasterEditionInstruction = createCreateMasterEditionInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateMasterEditionArgs.js
var require_CreateMasterEditionArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateMasterEditionArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMasterEditionArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.createMasterEditionArgsBeet = new beet.FixableBeetArgsStruct([["maxSupply", beet.coption(beet.u64)]], "CreateMasterEditionArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMasterEditionV3.js
var require_CreateMasterEditionV3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMasterEditionV3.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateMasterEditionV3Instruction = exports.createMasterEditionV3InstructionDiscriminator = exports.CreateMasterEditionV3Struct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var CreateMasterEditionArgs_1 = require_CreateMasterEditionArgs();
    exports.CreateMasterEditionV3Struct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["createMasterEditionArgs", CreateMasterEditionArgs_1.createMasterEditionArgsBeet]
    ], "CreateMasterEditionV3InstructionArgs");
    exports.createMasterEditionV3InstructionDiscriminator = 17;
    function createCreateMasterEditionV3Instruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.CreateMasterEditionV3Struct.serialize({
        instructionDiscriminator: exports.createMasterEditionV3InstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateMasterEditionV3Instruction = createCreateMasterEditionV3Instruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccount.js
var require_CreateMetadataAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateMetadataAccountInstruction = exports.createMetadataAccountInstructionDiscriminator = exports.CreateMetadataAccountStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CreateMetadataAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CreateMetadataAccountInstructionArgs");
    exports.createMetadataAccountInstructionDiscriminator = 0;
    function createCreateMetadataAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.CreateMetadataAccountStruct.serialize({
        instructionDiscriminator: exports.createMetadataAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.rent) !== null && _b !== void 0 ? _b : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateMetadataAccountInstruction = createCreateMetadataAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccountV2.js
var require_CreateMetadataAccountV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccountV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateMetadataAccountV2Instruction = exports.createMetadataAccountV2InstructionDiscriminator = exports.CreateMetadataAccountV2Struct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.CreateMetadataAccountV2Struct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "CreateMetadataAccountV2InstructionArgs");
    exports.createMetadataAccountV2InstructionDiscriminator = 16;
    function createCreateMetadataAccountV2Instruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.CreateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: exports.createMetadataAccountV2InstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateMetadataAccountV2Instruction = createCreateMetadataAccountV2Instruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/DataV2.js
var require_DataV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/DataV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataV2Beet = void 0;
    var beet = __importStar(require_beet());
    var Creator_1 = require_Creator();
    var Collection_1 = require_Collection();
    var Uses_1 = require_Uses();
    exports.dataV2Beet = new beet.FixableBeetArgsStruct([
      ["name", beet.utf8String],
      ["symbol", beet.utf8String],
      ["uri", beet.utf8String],
      ["sellerFeeBasisPoints", beet.u16],
      ["creators", beet.coption(beet.array(Creator_1.creatorBeet))],
      ["collection", beet.coption(Collection_1.collectionBeet)],
      ["uses", beet.coption(Uses_1.usesBeet)]
    ], "DataV2");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateMetadataAccountArgsV3.js
var require_CreateMetadataAccountArgsV3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CreateMetadataAccountArgsV3.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMetadataAccountArgsV3Beet = void 0;
    var beet = __importStar(require_beet());
    var DataV2_1 = require_DataV2();
    var CollectionDetails_1 = require_CollectionDetails();
    exports.createMetadataAccountArgsV3Beet = new beet.FixableBeetArgsStruct([
      ["data", DataV2_1.dataV2Beet],
      ["isMutable", beet.bool],
      ["collectionDetails", beet.coption(CollectionDetails_1.collectionDetailsBeet)]
    ], "CreateMetadataAccountArgsV3");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccountV3.js
var require_CreateMetadataAccountV3 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/CreateMetadataAccountV3.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCreateMetadataAccountV3Instruction = exports.createMetadataAccountV3InstructionDiscriminator = exports.CreateMetadataAccountV3Struct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var CreateMetadataAccountArgsV3_1 = require_CreateMetadataAccountArgsV3();
    exports.CreateMetadataAccountV3Struct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["createMetadataAccountArgsV3", CreateMetadataAccountArgsV3_1.createMetadataAccountArgsV3Beet]
    ], "CreateMetadataAccountV3InstructionArgs");
    exports.createMetadataAccountV3InstructionDiscriminator = 33;
    function createCreateMetadataAccountV3Instruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.CreateMetadataAccountV3Struct.serialize({
        instructionDiscriminator: exports.createMetadataAccountV3InstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createCreateMetadataAccountV3Instruction = createCreateMetadataAccountV3Instruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/SeedsVec.js
var require_SeedsVec = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/SeedsVec.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.seedsVecBeet = void 0;
    var beet = __importStar(require_beet());
    exports.seedsVecBeet = new beet.FixableBeetArgsStruct([["seeds", beet.array(beet.bytes)]], "SeedsVec");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/LeafInfo.js
var require_LeafInfo = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/LeafInfo.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.leafInfoBeet = void 0;
    var beet = __importStar(require_beet());
    exports.leafInfoBeet = new beet.FixableBeetArgsStruct([
      ["leaf", beet.uniformFixedSizeArray(beet.u8, 32)],
      ["proof", beet.array(beet.uniformFixedSizeArray(beet.u8, 32))]
    ], "LeafInfo");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PayloadType.js
var require_PayloadType = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PayloadType.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.payloadTypeBeet = exports.isPayloadTypeNumber = exports.isPayloadTypeMerkleProof = exports.isPayloadTypeSeeds = exports.isPayloadTypePubkey = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var SeedsVec_1 = require_SeedsVec();
    var LeafInfo_1 = require_LeafInfo();
    var isPayloadTypePubkey = (x) => x.__kind === "Pubkey";
    exports.isPayloadTypePubkey = isPayloadTypePubkey;
    var isPayloadTypeSeeds = (x) => x.__kind === "Seeds";
    exports.isPayloadTypeSeeds = isPayloadTypeSeeds;
    var isPayloadTypeMerkleProof = (x) => x.__kind === "MerkleProof";
    exports.isPayloadTypeMerkleProof = isPayloadTypeMerkleProof;
    var isPayloadTypeNumber = (x) => x.__kind === "Number";
    exports.isPayloadTypeNumber = isPayloadTypeNumber;
    exports.payloadTypeBeet = beet.dataEnum([
      [
        "Pubkey",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([beetSolana.publicKey])]], 'PayloadTypeRecord["Pubkey"]')
      ],
      [
        "Seeds",
        new beet.FixableBeetArgsStruct([["fields", beet.tuple([SeedsVec_1.seedsVecBeet])]], 'PayloadTypeRecord["Seeds"]')
      ],
      [
        "MerkleProof",
        new beet.FixableBeetArgsStruct([["fields", beet.tuple([LeafInfo_1.leafInfoBeet])]], 'PayloadTypeRecord["MerkleProof"]')
      ],
      [
        "Number",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([beet.u64])]], 'PayloadTypeRecord["Number"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Payload.js
var require_Payload = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/Payload.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.payloadBeet = void 0;
    var beet = __importStar(require_beet());
    var PayloadType_1 = require_PayloadType();
    exports.payloadBeet = new beet.FixableBeetArgsStruct([["map", beet.map(beet.utf8String, PayloadType_1.payloadTypeBeet)]], "Payload");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AuthorizationData.js
var require_AuthorizationData = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AuthorizationData.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorizationDataBeet = void 0;
    var beet = __importStar(require_beet());
    var Payload_1 = require_Payload();
    exports.authorizationDataBeet = new beet.FixableBeetArgsStruct([["payload", Payload_1.payloadBeet]], "AuthorizationData");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/DelegateArgs.js
var require_DelegateArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/DelegateArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delegateArgsBeet = exports.isDelegateArgsProgrammableConfigItemV1 = exports.isDelegateArgsCollectionItemV1 = exports.isDelegateArgsDataItemV1 = exports.isDelegateArgsAuthorityItemV1 = exports.isDelegateArgsProgrammableConfigV1 = exports.isDelegateArgsLockedTransferV1 = exports.isDelegateArgsStandardV1 = exports.isDelegateArgsStakingV1 = exports.isDelegateArgsUtilityV1 = exports.isDelegateArgsDataV1 = exports.isDelegateArgsTransferV1 = exports.isDelegateArgsSaleV1 = exports.isDelegateArgsCollectionV1 = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var AuthorizationData_1 = require_AuthorizationData();
    var isDelegateArgsCollectionV1 = (x) => x.__kind === "CollectionV1";
    exports.isDelegateArgsCollectionV1 = isDelegateArgsCollectionV1;
    var isDelegateArgsSaleV1 = (x) => x.__kind === "SaleV1";
    exports.isDelegateArgsSaleV1 = isDelegateArgsSaleV1;
    var isDelegateArgsTransferV1 = (x) => x.__kind === "TransferV1";
    exports.isDelegateArgsTransferV1 = isDelegateArgsTransferV1;
    var isDelegateArgsDataV1 = (x) => x.__kind === "DataV1";
    exports.isDelegateArgsDataV1 = isDelegateArgsDataV1;
    var isDelegateArgsUtilityV1 = (x) => x.__kind === "UtilityV1";
    exports.isDelegateArgsUtilityV1 = isDelegateArgsUtilityV1;
    var isDelegateArgsStakingV1 = (x) => x.__kind === "StakingV1";
    exports.isDelegateArgsStakingV1 = isDelegateArgsStakingV1;
    var isDelegateArgsStandardV1 = (x) => x.__kind === "StandardV1";
    exports.isDelegateArgsStandardV1 = isDelegateArgsStandardV1;
    var isDelegateArgsLockedTransferV1 = (x) => x.__kind === "LockedTransferV1";
    exports.isDelegateArgsLockedTransferV1 = isDelegateArgsLockedTransferV1;
    var isDelegateArgsProgrammableConfigV1 = (x) => x.__kind === "ProgrammableConfigV1";
    exports.isDelegateArgsProgrammableConfigV1 = isDelegateArgsProgrammableConfigV1;
    var isDelegateArgsAuthorityItemV1 = (x) => x.__kind === "AuthorityItemV1";
    exports.isDelegateArgsAuthorityItemV1 = isDelegateArgsAuthorityItemV1;
    var isDelegateArgsDataItemV1 = (x) => x.__kind === "DataItemV1";
    exports.isDelegateArgsDataItemV1 = isDelegateArgsDataItemV1;
    var isDelegateArgsCollectionItemV1 = (x) => x.__kind === "CollectionItemV1";
    exports.isDelegateArgsCollectionItemV1 = isDelegateArgsCollectionItemV1;
    var isDelegateArgsProgrammableConfigItemV1 = (x) => x.__kind === "ProgrammableConfigItemV1";
    exports.isDelegateArgsProgrammableConfigItemV1 = isDelegateArgsProgrammableConfigItemV1;
    exports.delegateArgsBeet = beet.dataEnum([
      [
        "CollectionV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["CollectionV1"]')
      ],
      [
        "SaleV1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'DelegateArgsRecord["SaleV1"]')
      ],
      [
        "TransferV1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'DelegateArgsRecord["TransferV1"]')
      ],
      [
        "DataV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["DataV1"]')
      ],
      [
        "UtilityV1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'DelegateArgsRecord["UtilityV1"]')
      ],
      [
        "StakingV1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'DelegateArgsRecord["StakingV1"]')
      ],
      [
        "StandardV1",
        new beet.BeetArgsStruct([["amount", beet.u64]], 'DelegateArgsRecord["StandardV1"]')
      ],
      [
        "LockedTransferV1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["lockedAddress", beetSolana.publicKey],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'DelegateArgsRecord["LockedTransferV1"]')
      ],
      [
        "ProgrammableConfigV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["ProgrammableConfigV1"]')
      ],
      [
        "AuthorityItemV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["AuthorityItemV1"]')
      ],
      [
        "DataItemV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["DataItemV1"]')
      ],
      [
        "CollectionItemV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["CollectionItemV1"]')
      ],
      [
        "ProgrammableConfigItemV1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'DelegateArgsRecord["ProgrammableConfigItemV1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Delegate.js
var require_Delegate = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Delegate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDelegateInstruction = exports.delegateInstructionDiscriminator = exports.DelegateStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var DelegateArgs_1 = require_DelegateArgs();
    exports.DelegateStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["delegateArgs", DelegateArgs_1.delegateArgsBeet]
    ], "DelegateInstructionArgs");
    exports.delegateInstructionDiscriminator = 44;
    function createDelegateInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const [data] = exports.DelegateStruct.serialize({
        instructionDiscriminator: exports.delegateInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.delegateRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.delegate,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.masterEdition) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.token) !== null && _d !== void 0 ? _d : programId,
          isWritable: accounts.token != null,
          isSigner: false
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_e = accounts.systemProgram) !== null && _e !== void 0 ? _e : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.splTokenProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRulesProgram) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_h = accounts.authorizationRules) !== null && _h !== void 0 ? _h : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDelegateInstruction = createDelegateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedCreateMasterEdition.js
var require_DeprecatedCreateMasterEdition = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedCreateMasterEdition.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedCreateMasterEditionInstruction = exports.deprecatedCreateMasterEditionInstructionDiscriminator = exports.DeprecatedCreateMasterEditionStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedCreateMasterEditionStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedCreateMasterEditionInstructionArgs");
    exports.deprecatedCreateMasterEditionInstructionDiscriminator = 2;
    function createDeprecatedCreateMasterEditionInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c;
      const [data] = exports.DeprecatedCreateMasterEditionStruct.serialize({
        instructionDiscriminator: exports.deprecatedCreateMasterEditionInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.printingMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.oneTimePrintingAuthorizationMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.printingMintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.rent) !== null && _c !== void 0 ? _c : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.oneTimePrintingAuthorizationMintAuthority,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedCreateMasterEditionInstruction = createDeprecatedCreateMasterEditionInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedCreateReservationList.js
var require_DeprecatedCreateReservationList = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedCreateReservationList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedCreateReservationListInstruction = exports.deprecatedCreateReservationListInstructionDiscriminator = exports.DeprecatedCreateReservationListStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedCreateReservationListStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedCreateReservationListInstructionArgs");
    exports.deprecatedCreateReservationListInstructionDiscriminator = 6;
    function createDeprecatedCreateReservationListInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.DeprecatedCreateReservationListStruct.serialize({
        instructionDiscriminator: exports.deprecatedCreateReservationListInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.reservationList,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.resource,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.rent) !== null && _b !== void 0 ? _b : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedCreateReservationListInstruction = createDeprecatedCreateReservationListInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintNewEditionFromMasterEditionViaPrintingToken.js
var require_DeprecatedMintNewEditionFromMasterEditionViaPrintingToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintNewEditionFromMasterEditionViaPrintingToken.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction = exports.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator = exports.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionArgs");
    exports.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator = 3;
    function createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c;
      const [data] = exports.DeprecatedMintNewEditionFromMasterEditionViaPrintingTokenStruct.serialize({
        instructionDiscriminator: exports.deprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.printingMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterTokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMarker,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.burnAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.masterUpdateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.masterMetadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.rent) !== null && _c !== void 0 ? _c : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.reservationList != null) {
        keys.push({
          pubkey: accounts.reservationList,
          isWritable: true,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction = createDeprecatedMintNewEditionFromMasterEditionViaPrintingTokenInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintPrintingTokens.js
var require_DeprecatedMintPrintingTokens = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintPrintingTokens.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedMintPrintingTokensInstruction = exports.deprecatedMintPrintingTokensInstructionDiscriminator = exports.DeprecatedMintPrintingTokensStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedMintPrintingTokensStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedMintPrintingTokensInstructionArgs");
    exports.deprecatedMintPrintingTokensInstructionDiscriminator = 9;
    function createDeprecatedMintPrintingTokensInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.DeprecatedMintPrintingTokensStruct.serialize({
        instructionDiscriminator: exports.deprecatedMintPrintingTokensInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.destination,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.printingMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.rent) !== null && _b !== void 0 ? _b : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedMintPrintingTokensInstruction = createDeprecatedMintPrintingTokensInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintPrintingTokensViaToken.js
var require_DeprecatedMintPrintingTokensViaToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedMintPrintingTokensViaToken.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedMintPrintingTokensViaTokenInstruction = exports.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator = exports.DeprecatedMintPrintingTokensViaTokenStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedMintPrintingTokensViaTokenStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedMintPrintingTokensViaTokenInstructionArgs");
    exports.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator = 8;
    function createDeprecatedMintPrintingTokensViaTokenInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.DeprecatedMintPrintingTokensViaTokenStruct.serialize({
        instructionDiscriminator: exports.deprecatedMintPrintingTokensViaTokenInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.destination,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.oneTimePrintingAuthorizationMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.printingMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.burnAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.rent) !== null && _b !== void 0 ? _b : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedMintPrintingTokensViaTokenInstruction = createDeprecatedMintPrintingTokensViaTokenInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedSetReservationList.js
var require_DeprecatedSetReservationList = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/DeprecatedSetReservationList.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeprecatedSetReservationListInstruction = exports.deprecatedSetReservationListInstructionDiscriminator = exports.DeprecatedSetReservationListStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.DeprecatedSetReservationListStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "DeprecatedSetReservationListInstructionArgs");
    exports.deprecatedSetReservationListInstructionDiscriminator = 5;
    function createDeprecatedSetReservationListInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.DeprecatedSetReservationListStruct.serialize({
        instructionDiscriminator: exports.deprecatedSetReservationListInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.reservationList,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.resource,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createDeprecatedSetReservationListInstruction = createDeprecatedSetReservationListInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/FreezeDelegatedAccount.js
var require_FreezeDelegatedAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/FreezeDelegatedAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFreezeDelegatedAccountInstruction = exports.freezeDelegatedAccountInstructionDiscriminator = exports.FreezeDelegatedAccountStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.FreezeDelegatedAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "FreezeDelegatedAccountInstructionArgs");
    exports.freezeDelegatedAccountInstructionDiscriminator = 26;
    function createFreezeDelegatedAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.FreezeDelegatedAccountStruct.serialize({
        instructionDiscriminator: exports.freezeDelegatedAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.delegate,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createFreezeDelegatedAccountInstruction = createFreezeDelegatedAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/LockArgs.js
var require_LockArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/LockArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lockArgsBeet = exports.isLockArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AuthorizationData_1 = require_AuthorizationData();
    var isLockArgsV1 = (x) => x.__kind === "V1";
    exports.isLockArgsV1 = isLockArgsV1;
    exports.lockArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'LockArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Lock.js
var require_Lock = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Lock.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLockInstruction = exports.lockInstructionDiscriminator = exports.LockStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var LockArgs_1 = require_LockArgs();
    exports.LockStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["lockArgs", LockArgs_1.lockArgsBeet]
    ], "LockInstructionArgs");
    exports.lockInstructionDiscriminator = 46;
    function createLockInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g;
      const [data] = exports.LockStruct.serialize({
        instructionDiscriminator: exports.lockInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.tokenOwner) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.edition) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.splTokenProgram) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRulesProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRules) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createLockInstruction = createLockInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Migrate.js
var require_Migrate = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Migrate.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMigrateInstruction = exports.migrateInstructionDiscriminator = exports.MigrateStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.MigrateStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "MigrateInstructionArgs");
    exports.migrateInstructionDiscriminator = 48;
    function createMigrateInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c;
      const [data] = exports.MigrateStruct.serialize({
        instructionDiscriminator: exports.migrateInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.tokenOwner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMetadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.delegateRecord,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.tokenRecord,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.authorizationRulesProgram) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.authorizationRules) !== null && _c !== void 0 ? _c : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createMigrateInstruction = createMigrateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MintArgs.js
var require_MintArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MintArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mintArgsBeet = exports.isMintArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AuthorizationData_1 = require_AuthorizationData();
    var isMintArgsV1 = (x) => x.__kind === "V1";
    exports.isMintArgsV1 = isMintArgsV1;
    exports.mintArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'MintArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Mint.js
var require_Mint = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Mint.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMintInstruction = exports.mintInstructionDiscriminator = exports.MintStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var MintArgs_1 = require_MintArgs();
    exports.MintStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["mintArgs", MintArgs_1.mintArgsBeet]
    ], "MintInstructionArgs");
    exports.mintInstructionDiscriminator = 43;
    function createMintInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g;
      const [data] = exports.MintStruct.serialize({
        instructionDiscriminator: exports.mintInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenOwner) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.masterEdition) !== null && _b !== void 0 ? _b : programId,
          isWritable: accounts.masterEdition != null,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.delegateRecord) !== null && _d !== void 0 ? _d : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_e = accounts.systemProgram) !== null && _e !== void 0 ? _e : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splAtaProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRulesProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRules) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createMintInstruction = createMintInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MintNewEditionFromMasterEditionViaTokenArgs.js
var require_MintNewEditionFromMasterEditionViaTokenArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MintNewEditionFromMasterEditionViaTokenArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mintNewEditionFromMasterEditionViaTokenArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.mintNewEditionFromMasterEditionViaTokenArgsBeet = new beet.BeetArgsStruct([["edition", beet.u64]], "MintNewEditionFromMasterEditionViaTokenArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/MintNewEditionFromMasterEditionViaToken.js
var require_MintNewEditionFromMasterEditionViaToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/MintNewEditionFromMasterEditionViaToken.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMintNewEditionFromMasterEditionViaTokenInstruction = exports.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator = exports.MintNewEditionFromMasterEditionViaTokenStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var MintNewEditionFromMasterEditionViaTokenArgs_1 = require_MintNewEditionFromMasterEditionViaTokenArgs();
    exports.MintNewEditionFromMasterEditionViaTokenStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      [
        "mintNewEditionFromMasterEditionViaTokenArgs",
        MintNewEditionFromMasterEditionViaTokenArgs_1.mintNewEditionFromMasterEditionViaTokenArgsBeet
      ]
    ], "MintNewEditionFromMasterEditionViaTokenInstructionArgs");
    exports.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator = 11;
    function createMintNewEditionFromMasterEditionViaTokenInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.MintNewEditionFromMasterEditionViaTokenStruct.serialize({
        instructionDiscriminator: exports.mintNewEditionFromMasterEditionViaTokenInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.newMetadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMarkPda,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newMintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.tokenAccountOwner,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.newMetadataUpdateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createMintNewEditionFromMasterEditionViaTokenInstruction = createMintNewEditionFromMasterEditionViaTokenInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/MintNewEditionFromMasterEditionViaVaultProxy.js
var require_MintNewEditionFromMasterEditionViaVaultProxy = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/MintNewEditionFromMasterEditionViaVaultProxy.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMintNewEditionFromMasterEditionViaVaultProxyInstruction = exports.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator = exports.MintNewEditionFromMasterEditionViaVaultProxyStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var MintNewEditionFromMasterEditionViaTokenArgs_1 = require_MintNewEditionFromMasterEditionViaTokenArgs();
    exports.MintNewEditionFromMasterEditionViaVaultProxyStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      [
        "mintNewEditionFromMasterEditionViaTokenArgs",
        MintNewEditionFromMasterEditionViaTokenArgs_1.mintNewEditionFromMasterEditionViaTokenArgsBeet
      ]
    ], "MintNewEditionFromMasterEditionViaVaultProxyInstructionArgs");
    exports.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator = 13;
    function createMintNewEditionFromMasterEditionViaVaultProxyInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.MintNewEditionFromMasterEditionViaVaultProxyStruct.serialize({
        instructionDiscriminator: exports.mintNewEditionFromMasterEditionViaVaultProxyInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.newMetadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMarkPda,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.newMintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.vaultAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.safetyDepositStore,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.safetyDepositBox,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.vault,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.newMetadataUpdateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.tokenVaultProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createMintNewEditionFromMasterEditionViaVaultProxyInstruction = createMintNewEditionFromMasterEditionViaVaultProxyInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PrintArgs.js
var require_PrintArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PrintArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.printArgsBeet = exports.isPrintArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var isPrintArgsV1 = (x) => x.__kind === "V1";
    exports.isPrintArgsV1 = isPrintArgsV1;
    exports.printArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.BeetArgsStruct([["edition", beet.u64]], 'PrintArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Print.js
var require_Print = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Print.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPrintInstruction = exports.printInstructionDiscriminator = exports.PrintStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var PrintArgs_1 = require_PrintArgs();
    exports.PrintStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["printArgs", PrintArgs_1.printArgsBeet]
    ], "PrintInstructionArgs");
    exports.printInstructionDiscriminator = 55;
    function createPrintInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.PrintStruct.serialize({
        instructionDiscriminator: exports.printInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.editionMetadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionTokenAccountOwner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.editionTokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMintAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.editionTokenRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.editionTokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.masterEdition,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.editionMarkerPda,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.masterTokenAccountOwner,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.masterTokenAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.masterMetadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splAtaProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createPrintInstruction = createPrintInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/PuffMetadata.js
var require_PuffMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/PuffMetadata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPuffMetadataInstruction = exports.puffMetadataInstructionDiscriminator = exports.PuffMetadataStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.PuffMetadataStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "PuffMetadataInstructionArgs");
    exports.puffMetadataInstructionDiscriminator = 14;
    function createPuffMetadataInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.PuffMetadataStruct.serialize({
        instructionDiscriminator: exports.puffMetadataInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createPuffMetadataInstruction = createPuffMetadataInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RemoveCreatorVerification.js
var require_RemoveCreatorVerification = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RemoveCreatorVerification.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRemoveCreatorVerificationInstruction = exports.removeCreatorVerificationInstructionDiscriminator = exports.RemoveCreatorVerificationStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.RemoveCreatorVerificationStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "RemoveCreatorVerificationInstructionArgs");
    exports.removeCreatorVerificationInstructionDiscriminator = 28;
    function createRemoveCreatorVerificationInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.RemoveCreatorVerificationStruct.serialize({
        instructionDiscriminator: exports.removeCreatorVerificationInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.creator,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createRemoveCreatorVerificationInstruction = createRemoveCreatorVerificationInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/RevokeArgs.js
var require_RevokeArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/RevokeArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revokeArgsBeet = exports.RevokeArgs = void 0;
    var beet = __importStar(require_beet());
    var RevokeArgs;
    (function(RevokeArgs2) {
      RevokeArgs2[RevokeArgs2["CollectionV1"] = 0] = "CollectionV1";
      RevokeArgs2[RevokeArgs2["SaleV1"] = 1] = "SaleV1";
      RevokeArgs2[RevokeArgs2["TransferV1"] = 2] = "TransferV1";
      RevokeArgs2[RevokeArgs2["DataV1"] = 3] = "DataV1";
      RevokeArgs2[RevokeArgs2["UtilityV1"] = 4] = "UtilityV1";
      RevokeArgs2[RevokeArgs2["StakingV1"] = 5] = "StakingV1";
      RevokeArgs2[RevokeArgs2["StandardV1"] = 6] = "StandardV1";
      RevokeArgs2[RevokeArgs2["LockedTransferV1"] = 7] = "LockedTransferV1";
      RevokeArgs2[RevokeArgs2["ProgrammableConfigV1"] = 8] = "ProgrammableConfigV1";
      RevokeArgs2[RevokeArgs2["MigrationV1"] = 9] = "MigrationV1";
      RevokeArgs2[RevokeArgs2["AuthorityItemV1"] = 10] = "AuthorityItemV1";
      RevokeArgs2[RevokeArgs2["DataItemV1"] = 11] = "DataItemV1";
      RevokeArgs2[RevokeArgs2["CollectionItemV1"] = 12] = "CollectionItemV1";
      RevokeArgs2[RevokeArgs2["ProgrammableConfigItemV1"] = 13] = "ProgrammableConfigItemV1";
    })(RevokeArgs = exports.RevokeArgs || (exports.RevokeArgs = {}));
    exports.revokeArgsBeet = beet.fixedScalarEnum(RevokeArgs);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Revoke.js
var require_Revoke = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Revoke.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRevokeInstruction = exports.revokeInstructionDiscriminator = exports.RevokeStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var RevokeArgs_1 = require_RevokeArgs();
    exports.RevokeStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["revokeArgs", RevokeArgs_1.revokeArgsBeet]
    ], "RevokeInstructionArgs");
    exports.revokeInstructionDiscriminator = 45;
    function createRevokeInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const [data] = exports.RevokeStruct.serialize({
        instructionDiscriminator: exports.revokeInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.delegateRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.delegate,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.masterEdition) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.token) !== null && _d !== void 0 ? _d : programId,
          isWritable: accounts.token != null,
          isSigner: false
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_e = accounts.systemProgram) !== null && _e !== void 0 ? _e : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.splTokenProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRulesProgram) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_h = accounts.authorizationRules) !== null && _h !== void 0 ? _h : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createRevokeInstruction = createRevokeInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RevokeCollectionAuthority.js
var require_RevokeCollectionAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RevokeCollectionAuthority.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRevokeCollectionAuthorityInstruction = exports.revokeCollectionAuthorityInstructionDiscriminator = exports.RevokeCollectionAuthorityStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.RevokeCollectionAuthorityStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "RevokeCollectionAuthorityInstructionArgs");
    exports.revokeCollectionAuthorityInstructionDiscriminator = 24;
    function createRevokeCollectionAuthorityInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.RevokeCollectionAuthorityStruct.serialize({
        instructionDiscriminator: exports.revokeCollectionAuthorityInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.delegateAuthority,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.revokeAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createRevokeCollectionAuthorityInstruction = createRevokeCollectionAuthorityInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RevokeUseAuthority.js
var require_RevokeUseAuthority = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/RevokeUseAuthority.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createRevokeUseAuthorityInstruction = exports.revokeUseAuthorityInstructionDiscriminator = exports.RevokeUseAuthorityStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.RevokeUseAuthorityStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "RevokeUseAuthorityInstructionArgs");
    exports.revokeUseAuthorityInstructionDiscriminator = 21;
    function createRevokeUseAuthorityInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b;
      const [data] = exports.RevokeUseAuthorityStruct.serialize({
        instructionDiscriminator: exports.revokeUseAuthorityInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.useAuthorityRecord,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.owner,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.user,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.ownerTokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.systemProgram) !== null && _b !== void 0 ? _b : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.rent != null) {
        keys.push({
          pubkey: accounts.rent,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createRevokeUseAuthorityInstruction = createRevokeUseAuthorityInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetAndVerifyCollection.js
var require_SetAndVerifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetAndVerifyCollection.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSetAndVerifyCollectionInstruction = exports.setAndVerifyCollectionInstructionDiscriminator = exports.SetAndVerifyCollectionStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.SetAndVerifyCollectionStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "SetAndVerifyCollectionInstructionArgs");
    exports.setAndVerifyCollectionInstructionDiscriminator = 25;
    function createSetAndVerifyCollectionInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.SetAndVerifyCollectionStruct.serialize({
        instructionDiscriminator: exports.setAndVerifyCollectionInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createSetAndVerifyCollectionInstruction = createSetAndVerifyCollectionInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetAndVerifySizedCollectionItem.js
var require_SetAndVerifySizedCollectionItem = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetAndVerifySizedCollectionItem.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSetAndVerifySizedCollectionItemInstruction = exports.setAndVerifySizedCollectionItemInstructionDiscriminator = exports.SetAndVerifySizedCollectionItemStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.SetAndVerifySizedCollectionItemStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "SetAndVerifySizedCollectionItemInstructionArgs");
    exports.setAndVerifySizedCollectionItemInstructionDiscriminator = 32;
    function createSetAndVerifySizedCollectionItemInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.SetAndVerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: exports.setAndVerifySizedCollectionItemInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: true,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createSetAndVerifySizedCollectionItemInstruction = createSetAndVerifySizedCollectionItemInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetCollectionSize.js
var require_SetCollectionSize = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetCollectionSize.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSetCollectionSizeInstruction = exports.setCollectionSizeInstructionDiscriminator = exports.SetCollectionSizeStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var SetCollectionSizeArgs_1 = require_SetCollectionSizeArgs();
    exports.SetCollectionSizeStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["setCollectionSizeArgs", SetCollectionSizeArgs_1.setCollectionSizeArgsBeet]
    ], "SetCollectionSizeInstructionArgs");
    exports.setCollectionSizeInstructionDiscriminator = 34;
    function createSetCollectionSizeInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.SetCollectionSizeStruct.serialize({
        instructionDiscriminator: exports.setCollectionSizeInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.collectionMetadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createSetCollectionSizeInstruction = createSetCollectionSizeInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetTokenStandard.js
var require_SetTokenStandard = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SetTokenStandard.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSetTokenStandardInstruction = exports.setTokenStandardInstructionDiscriminator = exports.SetTokenStandardStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.SetTokenStandardStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "SetTokenStandardInstructionArgs");
    exports.setTokenStandardInstructionDiscriminator = 35;
    function createSetTokenStandardInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.SetTokenStandardStruct.serialize({
        instructionDiscriminator: exports.setTokenStandardInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.edition != null) {
        keys.push({
          pubkey: accounts.edition,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createSetTokenStandardInstruction = createSetTokenStandardInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SignMetadata.js
var require_SignMetadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/SignMetadata.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSignMetadataInstruction = exports.signMetadataInstructionDiscriminator = exports.SignMetadataStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.SignMetadataStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "SignMetadataInstructionArgs");
    exports.signMetadataInstructionDiscriminator = 7;
    function createSignMetadataInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.SignMetadataStruct.serialize({
        instructionDiscriminator: exports.signMetadataInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.creator,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createSignMetadataInstruction = createSignMetadataInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ThawDelegatedAccount.js
var require_ThawDelegatedAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/ThawDelegatedAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createThawDelegatedAccountInstruction = exports.thawDelegatedAccountInstructionDiscriminator = exports.ThawDelegatedAccountStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.ThawDelegatedAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "ThawDelegatedAccountInstructionArgs");
    exports.thawDelegatedAccountInstructionDiscriminator = 27;
    function createThawDelegatedAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a;
      const [data] = exports.ThawDelegatedAccountStruct.serialize({
        instructionDiscriminator: exports.thawDelegatedAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.delegate,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.edition,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createThawDelegatedAccountInstruction = createThawDelegatedAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TransferArgs.js
var require_TransferArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TransferArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transferArgsBeet = exports.isTransferArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AuthorizationData_1 = require_AuthorizationData();
    var isTransferArgsV1 = (x) => x.__kind === "V1";
    exports.isTransferArgsV1 = isTransferArgsV1;
    exports.transferArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([
          ["amount", beet.u64],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'TransferArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Transfer.js
var require_Transfer = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Transfer.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransferInstruction = exports.transferInstructionDiscriminator = exports.TransferStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var TransferArgs_1 = require_TransferArgs();
    exports.TransferStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["transferArgs", TransferArgs_1.transferArgsBeet]
    ], "TransferInstructionArgs");
    exports.transferInstructionDiscriminator = 49;
    function createTransferInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f;
      const [data] = exports.TransferStruct.serialize({
        instructionDiscriminator: exports.transferInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.tokenOwner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.destination,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.destinationOwner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.edition) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.ownerTokenRecord) !== null && _b !== void 0 ? _b : programId,
          isWritable: accounts.ownerTokenRecord != null,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.destinationTokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.destinationTokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splTokenProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.splAtaProgram,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.authorizationRulesProgram) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRules) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createTransferInstruction = createTransferInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TransferOutOfEscrowArgs.js
var require_TransferOutOfEscrowArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/TransferOutOfEscrowArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transferOutOfEscrowArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.transferOutOfEscrowArgsBeet = new beet.BeetArgsStruct([["amount", beet.u64]], "TransferOutOfEscrowArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/TransferOutOfEscrow.js
var require_TransferOutOfEscrow = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/TransferOutOfEscrow.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransferOutOfEscrowInstruction = exports.transferOutOfEscrowInstructionDiscriminator = exports.TransferOutOfEscrowStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var TransferOutOfEscrowArgs_1 = require_TransferOutOfEscrowArgs();
    exports.TransferOutOfEscrowStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["transferOutOfEscrowArgs", TransferOutOfEscrowArgs_1.transferOutOfEscrowArgsBeet]
    ], "TransferOutOfEscrowInstructionArgs");
    exports.transferOutOfEscrowInstructionDiscriminator = 40;
    function createTransferOutOfEscrowInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c;
      const [data] = exports.TransferOutOfEscrowStruct.serialize({
        instructionDiscriminator: exports.transferOutOfEscrowInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.escrow,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.attributeMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.attributeSrc,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.attributeDst,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.escrowMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.escrowAccount,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.systemProgram) !== null && _a !== void 0 ? _a : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.ataProgram) !== null && _b !== void 0 ? _b : splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenProgram) !== null && _c !== void 0 ? _c : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.authority != null) {
        keys.push({
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createTransferOutOfEscrowInstruction = createTransferOutOfEscrowInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UnlockArgs.js
var require_UnlockArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UnlockArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unlockArgsBeet = exports.isUnlockArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AuthorizationData_1 = require_AuthorizationData();
    var isUnlockArgsV1 = (x) => x.__kind === "V1";
    exports.isUnlockArgsV1 = isUnlockArgsV1;
    exports.unlockArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'UnlockArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Unlock.js
var require_Unlock = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Unlock.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUnlockInstruction = exports.unlockInstructionDiscriminator = exports.UnlockStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var UnlockArgs_1 = require_UnlockArgs();
    exports.UnlockStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["unlockArgs", UnlockArgs_1.unlockArgsBeet]
    ], "UnlockInstructionArgs");
    exports.unlockInstructionDiscriminator = 47;
    function createUnlockInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g;
      const [data] = exports.UnlockStruct.serialize({
        instructionDiscriminator: exports.unlockInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.tokenOwner) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.token,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.edition) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.tokenRecord) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.tokenRecord != null,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.splTokenProgram) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRulesProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRules) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUnlockInstruction = createUnlockInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/VerificationArgs.js
var require_VerificationArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/VerificationArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verificationArgsBeet = exports.VerificationArgs = void 0;
    var beet = __importStar(require_beet());
    var VerificationArgs;
    (function(VerificationArgs2) {
      VerificationArgs2[VerificationArgs2["CreatorV1"] = 0] = "CreatorV1";
      VerificationArgs2[VerificationArgs2["CollectionV1"] = 1] = "CollectionV1";
    })(VerificationArgs = exports.VerificationArgs || (exports.VerificationArgs = {}));
    exports.verificationArgsBeet = beet.fixedScalarEnum(VerificationArgs);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Unverify.js
var require_Unverify = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Unverify.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUnverifyInstruction = exports.unverifyInstructionDiscriminator = exports.UnverifyStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var VerificationArgs_1 = require_VerificationArgs();
    exports.UnverifyStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["verificationArgs", VerificationArgs_1.verificationArgsBeet]
    ], "UnverifyInstructionArgs");
    exports.unverifyInstructionDiscriminator = 53;
    function createUnverifyInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d;
      const [data] = exports.UnverifyStruct.serialize({
        instructionDiscriminator: exports.unverifyInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.collectionMint) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.collectionMetadata) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.collectionMetadata != null,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUnverifyInstruction = createUnverifyInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UnverifyCollection.js
var require_UnverifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UnverifyCollection.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUnverifyCollectionInstruction = exports.unverifyCollectionInstructionDiscriminator = exports.UnverifyCollectionStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.UnverifyCollectionStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "UnverifyCollectionInstructionArgs");
    exports.unverifyCollectionInstructionDiscriminator = 22;
    function createUnverifyCollectionInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.UnverifyCollectionStruct.serialize({
        instructionDiscriminator: exports.unverifyCollectionInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUnverifyCollectionInstruction = createUnverifyCollectionInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UnverifySizedCollectionItem.js
var require_UnverifySizedCollectionItem = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UnverifySizedCollectionItem.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUnverifySizedCollectionItemInstruction = exports.unverifySizedCollectionItemInstructionDiscriminator = exports.UnverifySizedCollectionItemStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.UnverifySizedCollectionItemStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "UnverifySizedCollectionItemInstructionArgs");
    exports.unverifySizedCollectionItemInstructionDiscriminator = 31;
    function createUnverifySizedCollectionItemInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.UnverifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: exports.unverifySizedCollectionItemInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUnverifySizedCollectionItemInstruction = createUnverifySizedCollectionItemInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionToggle.js
var require_CollectionToggle = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionToggle.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionToggleBeet = exports.isCollectionToggleSet = exports.isCollectionToggleClear = exports.isCollectionToggleNone = void 0;
    var beet = __importStar(require_beet());
    var Collection_1 = require_Collection();
    var isCollectionToggleNone = (x) => x.__kind === "None";
    exports.isCollectionToggleNone = isCollectionToggleNone;
    var isCollectionToggleClear = (x) => x.__kind === "Clear";
    exports.isCollectionToggleClear = isCollectionToggleClear;
    var isCollectionToggleSet = (x) => x.__kind === "Set";
    exports.isCollectionToggleSet = isCollectionToggleSet;
    exports.collectionToggleBeet = beet.dataEnum([
      ["None", beet.unit],
      ["Clear", beet.unit],
      [
        "Set",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([Collection_1.collectionBeet])]], 'CollectionToggleRecord["Set"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionDetailsToggle.js
var require_CollectionDetailsToggle = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/CollectionDetailsToggle.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.collectionDetailsToggleBeet = exports.isCollectionDetailsToggleSet = exports.isCollectionDetailsToggleClear = exports.isCollectionDetailsToggleNone = void 0;
    var beet = __importStar(require_beet());
    var CollectionDetails_1 = require_CollectionDetails();
    var isCollectionDetailsToggleNone = (x) => x.__kind === "None";
    exports.isCollectionDetailsToggleNone = isCollectionDetailsToggleNone;
    var isCollectionDetailsToggleClear = (x) => x.__kind === "Clear";
    exports.isCollectionDetailsToggleClear = isCollectionDetailsToggleClear;
    var isCollectionDetailsToggleSet = (x) => x.__kind === "Set";
    exports.isCollectionDetailsToggleSet = isCollectionDetailsToggleSet;
    exports.collectionDetailsToggleBeet = beet.dataEnum([
      ["None", beet.unit],
      ["Clear", beet.unit],
      [
        "Set",
        new beet.FixableBeetArgsStruct([["fields", beet.tuple([CollectionDetails_1.collectionDetailsBeet])]], 'CollectionDetailsToggleRecord["Set"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UsesToggle.js
var require_UsesToggle = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UsesToggle.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usesToggleBeet = exports.isUsesToggleSet = exports.isUsesToggleClear = exports.isUsesToggleNone = void 0;
    var beet = __importStar(require_beet());
    var Uses_1 = require_Uses();
    var isUsesToggleNone = (x) => x.__kind === "None";
    exports.isUsesToggleNone = isUsesToggleNone;
    var isUsesToggleClear = (x) => x.__kind === "Clear";
    exports.isUsesToggleClear = isUsesToggleClear;
    var isUsesToggleSet = (x) => x.__kind === "Set";
    exports.isUsesToggleSet = isUsesToggleSet;
    exports.usesToggleBeet = beet.dataEnum([
      ["None", beet.unit],
      ["Clear", beet.unit],
      [
        "Set",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([Uses_1.usesBeet])]], 'UsesToggleRecord["Set"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/RuleSetToggle.js
var require_RuleSetToggle = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/RuleSetToggle.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ruleSetToggleBeet = exports.isRuleSetToggleSet = exports.isRuleSetToggleClear = exports.isRuleSetToggleNone = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var isRuleSetToggleNone = (x) => x.__kind === "None";
    exports.isRuleSetToggleNone = isRuleSetToggleNone;
    var isRuleSetToggleClear = (x) => x.__kind === "Clear";
    exports.isRuleSetToggleClear = isRuleSetToggleClear;
    var isRuleSetToggleSet = (x) => x.__kind === "Set";
    exports.isRuleSetToggleSet = isRuleSetToggleSet;
    exports.ruleSetToggleBeet = beet.dataEnum([
      ["None", beet.unit],
      ["Clear", beet.unit],
      [
        "Set",
        new beet.BeetArgsStruct([["fields", beet.fixedSizeTuple([beetSolana.publicKey])]], 'RuleSetToggleRecord["Set"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UpdateArgs.js
var require_UpdateArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UpdateArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateArgsBeet = exports.isUpdateArgsAsProgrammableConfigItemDelegateV2 = exports.isUpdateArgsAsCollectionItemDelegateV2 = exports.isUpdateArgsAsDataItemDelegateV2 = exports.isUpdateArgsAsProgrammableConfigDelegateV2 = exports.isUpdateArgsAsDataDelegateV2 = exports.isUpdateArgsAsCollectionDelegateV2 = exports.isUpdateArgsAsAuthorityItemDelegateV2 = exports.isUpdateArgsAsUpdateAuthorityV2 = exports.isUpdateArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var Data_1 = require_Data();
    var CollectionToggle_1 = require_CollectionToggle();
    var CollectionDetailsToggle_1 = require_CollectionDetailsToggle();
    var UsesToggle_1 = require_UsesToggle();
    var RuleSetToggle_1 = require_RuleSetToggle();
    var AuthorizationData_1 = require_AuthorizationData();
    var TokenStandard_1 = require_TokenStandard();
    var isUpdateArgsV1 = (x) => x.__kind === "V1";
    exports.isUpdateArgsV1 = isUpdateArgsV1;
    var isUpdateArgsAsUpdateAuthorityV2 = (x) => x.__kind === "AsUpdateAuthorityV2";
    exports.isUpdateArgsAsUpdateAuthorityV2 = isUpdateArgsAsUpdateAuthorityV2;
    var isUpdateArgsAsAuthorityItemDelegateV2 = (x) => x.__kind === "AsAuthorityItemDelegateV2";
    exports.isUpdateArgsAsAuthorityItemDelegateV2 = isUpdateArgsAsAuthorityItemDelegateV2;
    var isUpdateArgsAsCollectionDelegateV2 = (x) => x.__kind === "AsCollectionDelegateV2";
    exports.isUpdateArgsAsCollectionDelegateV2 = isUpdateArgsAsCollectionDelegateV2;
    var isUpdateArgsAsDataDelegateV2 = (x) => x.__kind === "AsDataDelegateV2";
    exports.isUpdateArgsAsDataDelegateV2 = isUpdateArgsAsDataDelegateV2;
    var isUpdateArgsAsProgrammableConfigDelegateV2 = (x) => x.__kind === "AsProgrammableConfigDelegateV2";
    exports.isUpdateArgsAsProgrammableConfigDelegateV2 = isUpdateArgsAsProgrammableConfigDelegateV2;
    var isUpdateArgsAsDataItemDelegateV2 = (x) => x.__kind === "AsDataItemDelegateV2";
    exports.isUpdateArgsAsDataItemDelegateV2 = isUpdateArgsAsDataItemDelegateV2;
    var isUpdateArgsAsCollectionItemDelegateV2 = (x) => x.__kind === "AsCollectionItemDelegateV2";
    exports.isUpdateArgsAsCollectionItemDelegateV2 = isUpdateArgsAsCollectionItemDelegateV2;
    var isUpdateArgsAsProgrammableConfigItemDelegateV2 = (x) => x.__kind === "AsProgrammableConfigItemDelegateV2";
    exports.isUpdateArgsAsProgrammableConfigItemDelegateV2 = isUpdateArgsAsProgrammableConfigItemDelegateV2;
    exports.updateArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([
          ["newUpdateAuthority", beet.coption(beetSolana.publicKey)],
          ["data", beet.coption(Data_1.dataBeet)],
          ["primarySaleHappened", beet.coption(beet.bool)],
          ["isMutable", beet.coption(beet.bool)],
          ["collection", CollectionToggle_1.collectionToggleBeet],
          ["collectionDetails", CollectionDetailsToggle_1.collectionDetailsToggleBeet],
          ["uses", UsesToggle_1.usesToggleBeet],
          ["ruleSet", RuleSetToggle_1.ruleSetToggleBeet],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["V1"]')
      ],
      [
        "AsUpdateAuthorityV2",
        new beet.FixableBeetArgsStruct([
          ["newUpdateAuthority", beet.coption(beetSolana.publicKey)],
          ["data", beet.coption(Data_1.dataBeet)],
          ["primarySaleHappened", beet.coption(beet.bool)],
          ["isMutable", beet.coption(beet.bool)],
          ["collection", CollectionToggle_1.collectionToggleBeet],
          ["collectionDetails", CollectionDetailsToggle_1.collectionDetailsToggleBeet],
          ["uses", UsesToggle_1.usesToggleBeet],
          ["ruleSet", RuleSetToggle_1.ruleSetToggleBeet],
          ["tokenStandard", beet.coption(TokenStandard_1.tokenStandardBeet)],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsUpdateAuthorityV2"]')
      ],
      [
        "AsAuthorityItemDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["newUpdateAuthority", beet.coption(beetSolana.publicKey)],
          ["primarySaleHappened", beet.coption(beet.bool)],
          ["isMutable", beet.coption(beet.bool)],
          ["tokenStandard", beet.coption(TokenStandard_1.tokenStandardBeet)],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsAuthorityItemDelegateV2"]')
      ],
      [
        "AsCollectionDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["collection", CollectionToggle_1.collectionToggleBeet],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsCollectionDelegateV2"]')
      ],
      [
        "AsDataDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["data", beet.coption(Data_1.dataBeet)],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsDataDelegateV2"]')
      ],
      [
        "AsProgrammableConfigDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["ruleSet", RuleSetToggle_1.ruleSetToggleBeet],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsProgrammableConfigDelegateV2"]')
      ],
      [
        "AsDataItemDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["data", beet.coption(Data_1.dataBeet)],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsDataItemDelegateV2"]')
      ],
      [
        "AsCollectionItemDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["collection", CollectionToggle_1.collectionToggleBeet],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsCollectionItemDelegateV2"]')
      ],
      [
        "AsProgrammableConfigItemDelegateV2",
        new beet.FixableBeetArgsStruct([
          ["ruleSet", RuleSetToggle_1.ruleSetToggleBeet],
          ["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]
        ], 'UpdateArgsRecord["AsProgrammableConfigItemDelegateV2"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Update.js
var require_Update = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Update.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateInstruction = exports.updateInstructionDiscriminator = exports.UpdateStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var UpdateArgs_1 = require_UpdateArgs();
    exports.UpdateStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["updateArgs", UpdateArgs_1.updateArgsBeet]
    ], "UpdateInstructionArgs");
    exports.updateInstructionDiscriminator = 50;
    function createUpdateInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f;
      const [data] = exports.UpdateStruct.serialize({
        instructionDiscriminator: exports.updateInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.token) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.edition) !== null && _c !== void 0 ? _c : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.authorizationRulesProgram) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRules) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUpdateInstruction = createUpdateInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdateMetadataAccount.js
var require_UpdateMetadataAccount = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdateMetadataAccount.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateMetadataAccountInstruction = exports.updateMetadataAccountInstructionDiscriminator = exports.UpdateMetadataAccountStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.UpdateMetadataAccountStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "UpdateMetadataAccountInstructionArgs");
    exports.updateMetadataAccountInstructionDiscriminator = 1;
    function createUpdateMetadataAccountInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.UpdateMetadataAccountStruct.serialize({
        instructionDiscriminator: exports.updateMetadataAccountInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUpdateMetadataAccountInstruction = createUpdateMetadataAccountInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UpdateMetadataAccountArgsV2.js
var require_UpdateMetadataAccountArgsV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UpdateMetadataAccountArgsV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.updateMetadataAccountArgsV2Beet = void 0;
    var beet = __importStar(require_beet());
    var beetSolana = __importStar(require_beet_solana());
    var DataV2_1 = require_DataV2();
    exports.updateMetadataAccountArgsV2Beet = new beet.FixableBeetArgsStruct([
      ["data", beet.coption(DataV2_1.dataV2Beet)],
      ["updateAuthority", beet.coption(beetSolana.publicKey)],
      ["primarySaleHappened", beet.coption(beet.bool)],
      ["isMutable", beet.coption(beet.bool)]
    ], "UpdateMetadataAccountArgsV2");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdateMetadataAccountV2.js
var require_UpdateMetadataAccountV2 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdateMetadataAccountV2.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdateMetadataAccountV2Instruction = exports.updateMetadataAccountV2InstructionDiscriminator = exports.UpdateMetadataAccountV2Struct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var UpdateMetadataAccountArgsV2_1 = require_UpdateMetadataAccountArgsV2();
    exports.UpdateMetadataAccountV2Struct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["updateMetadataAccountArgsV2", UpdateMetadataAccountArgsV2_1.updateMetadataAccountArgsV2Beet]
    ], "UpdateMetadataAccountV2InstructionArgs");
    exports.updateMetadataAccountV2InstructionDiscriminator = 15;
    function createUpdateMetadataAccountV2Instruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.UpdateMetadataAccountV2Struct.serialize({
        instructionDiscriminator: exports.updateMetadataAccountV2InstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.updateAuthority,
          isWritable: false,
          isSigner: true
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUpdateMetadataAccountV2Instruction = createUpdateMetadataAccountV2Instruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdatePrimarySaleHappenedViaToken.js
var require_UpdatePrimarySaleHappenedViaToken = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/UpdatePrimarySaleHappenedViaToken.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUpdatePrimarySaleHappenedViaTokenInstruction = exports.updatePrimarySaleHappenedViaTokenInstructionDiscriminator = exports.UpdatePrimarySaleHappenedViaTokenStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.UpdatePrimarySaleHappenedViaTokenStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "UpdatePrimarySaleHappenedViaTokenInstructionArgs");
    exports.updatePrimarySaleHappenedViaTokenInstructionDiscriminator = 4;
    function createUpdatePrimarySaleHappenedViaTokenInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.UpdatePrimarySaleHappenedViaTokenStruct.serialize({
        instructionDiscriminator: exports.updatePrimarySaleHappenedViaTokenInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.owner,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.token,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUpdatePrimarySaleHappenedViaTokenInstruction = createUpdatePrimarySaleHappenedViaTokenInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UseArgs.js
var require_UseArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UseArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useArgsBeet = exports.isUseArgsV1 = void 0;
    var beet = __importStar(require_beet());
    var AuthorizationData_1 = require_AuthorizationData();
    var isUseArgsV1 = (x) => x.__kind === "V1";
    exports.isUseArgsV1 = isUseArgsV1;
    exports.useArgsBeet = beet.dataEnum([
      [
        "V1",
        new beet.FixableBeetArgsStruct([["authorizationData", beet.coption(AuthorizationData_1.authorizationDataBeet)]], 'UseArgsRecord["V1"]')
      ]
    ]);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Use.js
var require_Use = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Use.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUseInstruction = exports.useInstructionDiscriminator = exports.UseStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var UseArgs_1 = require_UseArgs();
    exports.UseStruct = new beet.FixableBeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["useArgs", UseArgs_1.useArgsBeet]
    ], "UseInstructionArgs");
    exports.useInstructionDiscriminator = 51;
    function createUseInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e, _f, _g;
      const [data] = exports.UseStruct.serialize({
        instructionDiscriminator: exports.useInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: accounts.delegateRecord != null,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.token) !== null && _b !== void 0 ? _b : programId,
          isWritable: accounts.token != null,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.edition) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.edition != null,
          isSigner: false
        },
        {
          pubkey: accounts.payer,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_d = accounts.systemProgram) !== null && _d !== void 0 ? _d : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.splTokenProgram) !== null && _e !== void 0 ? _e : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_f = accounts.authorizationRulesProgram) !== null && _f !== void 0 ? _f : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_g = accounts.authorizationRules) !== null && _g !== void 0 ? _g : programId,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUseInstruction = createUseInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UtilizeArgs.js
var require_UtilizeArgs = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/UtilizeArgs.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utilizeArgsBeet = void 0;
    var beet = __importStar(require_beet());
    exports.utilizeArgsBeet = new beet.BeetArgsStruct([["numberOfUses", beet.u64]], "UtilizeArgs");
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Utilize.js
var require_Utilize = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Utilize.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUtilizeInstruction = exports.utilizeInstructionDiscriminator = exports.UtilizeStruct = void 0;
    var splToken = __importStar(require_cjs3());
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var UtilizeArgs_1 = require_UtilizeArgs();
    exports.UtilizeStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["utilizeArgs", UtilizeArgs_1.utilizeArgsBeet]
    ], "UtilizeInstructionArgs");
    exports.utilizeInstructionDiscriminator = 19;
    function createUtilizeInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d;
      const [data] = exports.UtilizeStruct.serialize({
        instructionDiscriminator: exports.utilizeInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.tokenAccount,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.mint,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.useAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.owner,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_a = accounts.tokenProgram) !== null && _a !== void 0 ? _a : splToken.TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.ataProgram) !== null && _b !== void 0 ? _b : splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.systemProgram) !== null && _c !== void 0 ? _c : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.rent) !== null && _d !== void 0 ? _d : web3.SYSVAR_RENT_PUBKEY,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.useAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.useAuthorityRecord,
          isWritable: true,
          isSigner: false
        });
      }
      if (accounts.burner != null) {
        if (accounts.useAuthorityRecord == null) {
          throw new Error("When providing 'burner' then 'accounts.useAuthorityRecord' need(s) to be provided as well.");
        }
        keys.push({
          pubkey: accounts.burner,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createUtilizeInstruction = createUtilizeInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Verify.js
var require_Verify = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/Verify.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVerifyInstruction = exports.verifyInstructionDiscriminator = exports.VerifyStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    var VerificationArgs_1 = require_VerificationArgs();
    exports.VerifyStruct = new beet.BeetArgsStruct([
      ["instructionDiscriminator", beet.u8],
      ["verificationArgs", VerificationArgs_1.verificationArgsBeet]
    ], "VerifyInstructionArgs");
    exports.verifyInstructionDiscriminator = 52;
    function createVerifyInstruction(accounts, args, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      var _a, _b, _c, _d, _e;
      const [data] = exports.VerifyStruct.serialize({
        instructionDiscriminator: exports.verifyInstructionDiscriminator,
        ...args
      });
      const keys = [
        {
          pubkey: accounts.authority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: (_a = accounts.delegateRecord) !== null && _a !== void 0 ? _a : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: (_b = accounts.collectionMint) !== null && _b !== void 0 ? _b : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_c = accounts.collectionMetadata) !== null && _c !== void 0 ? _c : programId,
          isWritable: accounts.collectionMetadata != null,
          isSigner: false
        },
        {
          pubkey: (_d = accounts.collectionMasterEdition) !== null && _d !== void 0 ? _d : programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: (_e = accounts.systemProgram) !== null && _e !== void 0 ? _e : web3.SystemProgram.programId,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.sysvarInstructions,
          isWritable: false,
          isSigner: false
        }
      ];
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createVerifyInstruction = createVerifyInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/VerifyCollection.js
var require_VerifyCollection = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/VerifyCollection.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVerifyCollectionInstruction = exports.verifyCollectionInstructionDiscriminator = exports.VerifyCollectionStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.VerifyCollectionStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "VerifyCollectionInstructionArgs");
    exports.verifyCollectionInstructionDiscriminator = 18;
    function createVerifyCollectionInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.VerifyCollectionStruct.serialize({
        instructionDiscriminator: exports.verifyCollectionInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createVerifyCollectionInstruction = createVerifyCollectionInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/VerifySizedCollectionItem.js
var require_VerifySizedCollectionItem = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/VerifySizedCollectionItem.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createVerifySizedCollectionItemInstruction = exports.verifySizedCollectionItemInstructionDiscriminator = exports.VerifySizedCollectionItemStruct = void 0;
    var beet = __importStar(require_beet());
    var web3 = __importStar((init_index_browser_esm(), __toCommonJS(index_browser_esm_exports)));
    exports.VerifySizedCollectionItemStruct = new beet.BeetArgsStruct([["instructionDiscriminator", beet.u8]], "VerifySizedCollectionItemInstructionArgs");
    exports.verifySizedCollectionItemInstructionDiscriminator = 30;
    function createVerifySizedCollectionItemInstruction(accounts, programId = new web3.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")) {
      const [data] = exports.VerifySizedCollectionItemStruct.serialize({
        instructionDiscriminator: exports.verifySizedCollectionItemInstructionDiscriminator
      });
      const keys = [
        {
          pubkey: accounts.metadata,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionAuthority,
          isWritable: false,
          isSigner: true
        },
        {
          pubkey: accounts.payer,
          isWritable: true,
          isSigner: true
        },
        {
          pubkey: accounts.collectionMint,
          isWritable: false,
          isSigner: false
        },
        {
          pubkey: accounts.collection,
          isWritable: true,
          isSigner: false
        },
        {
          pubkey: accounts.collectionMasterEditionAccount,
          isWritable: false,
          isSigner: false
        }
      ];
      if (accounts.collectionAuthorityRecord != null) {
        keys.push({
          pubkey: accounts.collectionAuthorityRecord,
          isWritable: false,
          isSigner: false
        });
      }
      const ix = new web3.TransactionInstruction({
        programId,
        keys,
        data
      });
      return ix;
    }
    exports.createVerifySizedCollectionItemInstruction = createVerifySizedCollectionItemInstruction;
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/index.js
var require_instructions9 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/instructions/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproveCollectionAuthority(), exports);
    __exportStar(require_ApproveUseAuthority(), exports);
    __exportStar(require_BubblegumSetCollectionSize(), exports);
    __exportStar(require_Burn(), exports);
    __exportStar(require_BurnEditionNft(), exports);
    __exportStar(require_BurnNft(), exports);
    __exportStar(require_CloseEscrowAccount(), exports);
    __exportStar(require_Collect(), exports);
    __exportStar(require_ConvertMasterEditionV1ToV2(), exports);
    __exportStar(require_Create(), exports);
    __exportStar(require_CreateEscrowAccount(), exports);
    __exportStar(require_CreateMasterEdition(), exports);
    __exportStar(require_CreateMasterEditionV3(), exports);
    __exportStar(require_CreateMetadataAccount(), exports);
    __exportStar(require_CreateMetadataAccountV2(), exports);
    __exportStar(require_CreateMetadataAccountV3(), exports);
    __exportStar(require_Delegate(), exports);
    __exportStar(require_DeprecatedCreateMasterEdition(), exports);
    __exportStar(require_DeprecatedCreateReservationList(), exports);
    __exportStar(require_DeprecatedMintNewEditionFromMasterEditionViaPrintingToken(), exports);
    __exportStar(require_DeprecatedMintPrintingTokens(), exports);
    __exportStar(require_DeprecatedMintPrintingTokensViaToken(), exports);
    __exportStar(require_DeprecatedSetReservationList(), exports);
    __exportStar(require_FreezeDelegatedAccount(), exports);
    __exportStar(require_Lock(), exports);
    __exportStar(require_Migrate(), exports);
    __exportStar(require_Mint(), exports);
    __exportStar(require_MintNewEditionFromMasterEditionViaToken(), exports);
    __exportStar(require_MintNewEditionFromMasterEditionViaVaultProxy(), exports);
    __exportStar(require_Print(), exports);
    __exportStar(require_PuffMetadata(), exports);
    __exportStar(require_RemoveCreatorVerification(), exports);
    __exportStar(require_Revoke(), exports);
    __exportStar(require_RevokeCollectionAuthority(), exports);
    __exportStar(require_RevokeUseAuthority(), exports);
    __exportStar(require_SetAndVerifyCollection(), exports);
    __exportStar(require_SetAndVerifySizedCollectionItem(), exports);
    __exportStar(require_SetCollectionSize(), exports);
    __exportStar(require_SetTokenStandard(), exports);
    __exportStar(require_SignMetadata(), exports);
    __exportStar(require_ThawDelegatedAccount(), exports);
    __exportStar(require_Transfer(), exports);
    __exportStar(require_TransferOutOfEscrow(), exports);
    __exportStar(require_Unlock(), exports);
    __exportStar(require_Unverify(), exports);
    __exportStar(require_UnverifyCollection(), exports);
    __exportStar(require_UnverifySizedCollectionItem(), exports);
    __exportStar(require_Update(), exports);
    __exportStar(require_UpdateMetadataAccount(), exports);
    __exportStar(require_UpdateMetadataAccountV2(), exports);
    __exportStar(require_UpdatePrimarySaleHappenedViaToken(), exports);
    __exportStar(require_Use(), exports);
    __exportStar(require_Utilize(), exports);
    __exportStar(require_Verify(), exports);
    __exportStar(require_VerifyCollection(), exports);
    __exportStar(require_VerifySizedCollectionItem(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AuthorityType.js
var require_AuthorityType = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/AuthorityType.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authorityTypeBeet = exports.AuthorityType = void 0;
    var beet = __importStar(require_beet());
    var AuthorityType;
    (function(AuthorityType2) {
      AuthorityType2[AuthorityType2["None"] = 0] = "None";
      AuthorityType2[AuthorityType2["Metadata"] = 1] = "Metadata";
      AuthorityType2[AuthorityType2["Holder"] = 2] = "Holder";
      AuthorityType2[AuthorityType2["MetadataDelegate"] = 3] = "MetadataDelegate";
      AuthorityType2[AuthorityType2["TokenDelegate"] = 4] = "TokenDelegate";
    })(AuthorityType = exports.AuthorityType || (exports.AuthorityType = {}));
    exports.authorityTypeBeet = beet.fixedScalarEnum(AuthorityType);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MetadataDelegateRole.js
var require_MetadataDelegateRole = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MetadataDelegateRole.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metadataDelegateRoleBeet = exports.MetadataDelegateRole = void 0;
    var beet = __importStar(require_beet());
    var MetadataDelegateRole;
    (function(MetadataDelegateRole2) {
      MetadataDelegateRole2[MetadataDelegateRole2["AuthorityItem"] = 0] = "AuthorityItem";
      MetadataDelegateRole2[MetadataDelegateRole2["Collection"] = 1] = "Collection";
      MetadataDelegateRole2[MetadataDelegateRole2["Use"] = 2] = "Use";
      MetadataDelegateRole2[MetadataDelegateRole2["Data"] = 3] = "Data";
      MetadataDelegateRole2[MetadataDelegateRole2["ProgrammableConfig"] = 4] = "ProgrammableConfig";
      MetadataDelegateRole2[MetadataDelegateRole2["DataItem"] = 5] = "DataItem";
      MetadataDelegateRole2[MetadataDelegateRole2["CollectionItem"] = 6] = "CollectionItem";
      MetadataDelegateRole2[MetadataDelegateRole2["ProgrammableConfigItem"] = 7] = "ProgrammableConfigItem";
    })(MetadataDelegateRole = exports.MetadataDelegateRole || (exports.MetadataDelegateRole = {}));
    exports.metadataDelegateRoleBeet = beet.fixedScalarEnum(MetadataDelegateRole);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MigrationType.js
var require_MigrationType = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/MigrationType.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.migrationTypeBeet = exports.MigrationType = void 0;
    var beet = __importStar(require_beet());
    var MigrationType;
    (function(MigrationType2) {
      MigrationType2[MigrationType2["CollectionV1"] = 0] = "CollectionV1";
      MigrationType2[MigrationType2["ProgrammableV1"] = 1] = "ProgrammableV1";
    })(MigrationType = exports.MigrationType || (exports.MigrationType = {}));
    exports.migrationTypeBeet = beet.fixedScalarEnum(MigrationType);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PayloadKey.js
var require_PayloadKey = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/PayloadKey.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.payloadKeyBeet = exports.PayloadKey = void 0;
    var beet = __importStar(require_beet());
    var PayloadKey;
    (function(PayloadKey2) {
      PayloadKey2[PayloadKey2["Amount"] = 0] = "Amount";
      PayloadKey2[PayloadKey2["Authority"] = 1] = "Authority";
      PayloadKey2[PayloadKey2["AuthoritySeeds"] = 2] = "AuthoritySeeds";
      PayloadKey2[PayloadKey2["Delegate"] = 3] = "Delegate";
      PayloadKey2[PayloadKey2["DelegateSeeds"] = 4] = "DelegateSeeds";
      PayloadKey2[PayloadKey2["Destination"] = 5] = "Destination";
      PayloadKey2[PayloadKey2["DestinationSeeds"] = 6] = "DestinationSeeds";
      PayloadKey2[PayloadKey2["Holder"] = 7] = "Holder";
      PayloadKey2[PayloadKey2["Source"] = 8] = "Source";
      PayloadKey2[PayloadKey2["SourceSeeds"] = 9] = "SourceSeeds";
    })(PayloadKey = exports.PayloadKey || (exports.PayloadKey = {}));
    exports.payloadKeyBeet = beet.fixedScalarEnum(PayloadKey);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/index.js
var require_types4 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/types/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ApproveUseAuthorityArgs(), exports);
    __exportStar(require_AssetData(), exports);
    __exportStar(require_AuthorityType(), exports);
    __exportStar(require_AuthorizationData(), exports);
    __exportStar(require_BurnArgs(), exports);
    __exportStar(require_Collection(), exports);
    __exportStar(require_CollectionDetails(), exports);
    __exportStar(require_CollectionDetailsToggle(), exports);
    __exportStar(require_CollectionToggle(), exports);
    __exportStar(require_CreateArgs(), exports);
    __exportStar(require_CreateMasterEditionArgs(), exports);
    __exportStar(require_CreateMetadataAccountArgsV3(), exports);
    __exportStar(require_Creator(), exports);
    __exportStar(require_Data(), exports);
    __exportStar(require_DataV2(), exports);
    __exportStar(require_DelegateArgs(), exports);
    __exportStar(require_EscrowAuthority(), exports);
    __exportStar(require_Key(), exports);
    __exportStar(require_LeafInfo(), exports);
    __exportStar(require_LockArgs(), exports);
    __exportStar(require_MetadataDelegateRole(), exports);
    __exportStar(require_MigrationType(), exports);
    __exportStar(require_MintArgs(), exports);
    __exportStar(require_MintNewEditionFromMasterEditionViaTokenArgs(), exports);
    __exportStar(require_Payload(), exports);
    __exportStar(require_PayloadKey(), exports);
    __exportStar(require_PayloadType(), exports);
    __exportStar(require_PrintArgs(), exports);
    __exportStar(require_PrintSupply(), exports);
    __exportStar(require_ProgrammableConfig(), exports);
    __exportStar(require_Reservation(), exports);
    __exportStar(require_ReservationV1(), exports);
    __exportStar(require_RevokeArgs(), exports);
    __exportStar(require_RuleSetToggle(), exports);
    __exportStar(require_SeedsVec(), exports);
    __exportStar(require_SetCollectionSizeArgs(), exports);
    __exportStar(require_TokenDelegateRole(), exports);
    __exportStar(require_TokenStandard(), exports);
    __exportStar(require_TokenState(), exports);
    __exportStar(require_TransferArgs(), exports);
    __exportStar(require_TransferOutOfEscrowArgs(), exports);
    __exportStar(require_UnlockArgs(), exports);
    __exportStar(require_UpdateArgs(), exports);
    __exportStar(require_UpdateMetadataAccountArgsV2(), exports);
    __exportStar(require_UseArgs(), exports);
    __exportStar(require_UseMethod(), exports);
    __exportStar(require_Uses(), exports);
    __exportStar(require_UsesToggle(), exports);
    __exportStar(require_UtilizeArgs(), exports);
    __exportStar(require_VerificationArgs(), exports);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/index.js
var require_generated = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/generated/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PROGRAM_ID = exports.PROGRAM_ADDRESS = void 0;
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    __exportStar(require_accounts(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_instructions9(), exports);
    __exportStar(require_types4(), exports);
    exports.PROGRAM_ADDRESS = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
    exports.PROGRAM_ID = new web3_js_1.PublicKey(exports.PROGRAM_ADDRESS);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/errors.js
var require_errors4 = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cusper = void 0;
    var cusper_1 = require_cusper();
    var generated_1 = require_generated();
    exports.cusper = (0, cusper_1.initCusper)(generated_1.errorFromCode);
  }
});

// node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/mpl-token-metadata.js
var require_mpl_token_metadata = __commonJS({
  "node_modules/@metaplex-foundation/mpl-token-metadata/dist/src/mpl-token-metadata.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_errors4(), exports);
    __exportStar(require_generated(), exports);
  }
});
export default require_mpl_token_metadata();
//# sourceMappingURL=@metaplex-foundation_mpl-token-metadata.js.map
